use libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn ferror(__stream: *mut FILE) -> libc::c_int;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
}
pub type size_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type yaml_char_t = libc::c_uchar;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_version_directive_s {
    pub major: libc::c_int,
    pub minor: libc::c_int,
}
pub type yaml_version_directive_t = yaml_version_directive_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_tag_directive_s {
    pub handle: *mut yaml_char_t,
    pub prefix: *mut yaml_char_t,
}
pub type yaml_tag_directive_t = yaml_tag_directive_s;
pub type yaml_encoding_e = libc::c_uint;
pub const YAML_UTF16BE_ENCODING: yaml_encoding_e = 3;
pub const YAML_UTF16LE_ENCODING: yaml_encoding_e = 2;
pub const YAML_UTF8_ENCODING: yaml_encoding_e = 1;
pub const YAML_ANY_ENCODING: yaml_encoding_e = 0;
pub type yaml_encoding_t = yaml_encoding_e;
pub type yaml_break_e = libc::c_uint;
pub const YAML_CRLN_BREAK: yaml_break_e = 3;
pub const YAML_LN_BREAK: yaml_break_e = 2;
pub const YAML_CR_BREAK: yaml_break_e = 1;
pub const YAML_ANY_BREAK: yaml_break_e = 0;
pub type yaml_break_t = yaml_break_e;
pub type yaml_error_type_e = libc::c_uint;
pub const YAML_EMITTER_ERROR: yaml_error_type_e = 7;
pub const YAML_WRITER_ERROR: yaml_error_type_e = 6;
pub const YAML_COMPOSER_ERROR: yaml_error_type_e = 5;
pub const YAML_PARSER_ERROR: yaml_error_type_e = 4;
pub const YAML_SCANNER_ERROR: yaml_error_type_e = 3;
pub const YAML_READER_ERROR: yaml_error_type_e = 2;
pub const YAML_MEMORY_ERROR: yaml_error_type_e = 1;
pub const YAML_NO_ERROR: yaml_error_type_e = 0;
pub type yaml_error_type_t = yaml_error_type_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_mark_s {
    pub index: size_t,
    pub line: size_t,
    pub column: size_t,
}
pub type yaml_mark_t = yaml_mark_s;
pub type yaml_scalar_style_e = libc::c_uint;
pub const YAML_FOLDED_SCALAR_STYLE: yaml_scalar_style_e = 5;
pub const YAML_LITERAL_SCALAR_STYLE: yaml_scalar_style_e = 4;
pub const YAML_DOUBLE_QUOTED_SCALAR_STYLE: yaml_scalar_style_e = 3;
pub const YAML_SINGLE_QUOTED_SCALAR_STYLE: yaml_scalar_style_e = 2;
pub const YAML_PLAIN_SCALAR_STYLE: yaml_scalar_style_e = 1;
pub const YAML_ANY_SCALAR_STYLE: yaml_scalar_style_e = 0;
pub type yaml_scalar_style_t = yaml_scalar_style_e;
pub type yaml_sequence_style_e = libc::c_uint;
pub const YAML_FLOW_SEQUENCE_STYLE: yaml_sequence_style_e = 2;
pub const YAML_BLOCK_SEQUENCE_STYLE: yaml_sequence_style_e = 1;
pub const YAML_ANY_SEQUENCE_STYLE: yaml_sequence_style_e = 0;
pub type yaml_sequence_style_t = yaml_sequence_style_e;
pub type yaml_mapping_style_e = libc::c_uint;
pub const YAML_FLOW_MAPPING_STYLE: yaml_mapping_style_e = 2;
pub const YAML_BLOCK_MAPPING_STYLE: yaml_mapping_style_e = 1;
pub const YAML_ANY_MAPPING_STYLE: yaml_mapping_style_e = 0;
pub type yaml_mapping_style_t = yaml_mapping_style_e;
pub type yaml_token_type_e = libc::c_uint;
pub const YAML_SCALAR_TOKEN: yaml_token_type_e = 21;
pub const YAML_TAG_TOKEN: yaml_token_type_e = 20;
pub const YAML_ANCHOR_TOKEN: yaml_token_type_e = 19;
pub const YAML_ALIAS_TOKEN: yaml_token_type_e = 18;
pub const YAML_VALUE_TOKEN: yaml_token_type_e = 17;
pub const YAML_KEY_TOKEN: yaml_token_type_e = 16;
pub const YAML_FLOW_ENTRY_TOKEN: yaml_token_type_e = 15;
pub const YAML_BLOCK_ENTRY_TOKEN: yaml_token_type_e = 14;
pub const YAML_FLOW_MAPPING_END_TOKEN: yaml_token_type_e = 13;
pub const YAML_FLOW_MAPPING_START_TOKEN: yaml_token_type_e = 12;
pub const YAML_FLOW_SEQUENCE_END_TOKEN: yaml_token_type_e = 11;
pub const YAML_FLOW_SEQUENCE_START_TOKEN: yaml_token_type_e = 10;
pub const YAML_BLOCK_END_TOKEN: yaml_token_type_e = 9;
pub const YAML_BLOCK_MAPPING_START_TOKEN: yaml_token_type_e = 8;
pub const YAML_BLOCK_SEQUENCE_START_TOKEN: yaml_token_type_e = 7;
pub const YAML_DOCUMENT_END_TOKEN: yaml_token_type_e = 6;
pub const YAML_DOCUMENT_START_TOKEN: yaml_token_type_e = 5;
pub const YAML_TAG_DIRECTIVE_TOKEN: yaml_token_type_e = 4;
pub const YAML_VERSION_DIRECTIVE_TOKEN: yaml_token_type_e = 3;
pub const YAML_STREAM_END_TOKEN: yaml_token_type_e = 2;
pub const YAML_STREAM_START_TOKEN: yaml_token_type_e = 1;
pub const YAML_NO_TOKEN: yaml_token_type_e = 0;
pub type yaml_token_type_t = yaml_token_type_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_token_s {
    pub type_0: yaml_token_type_t,
    pub data: C2RustUnnamed,
    pub start_mark: yaml_mark_t,
    pub end_mark: yaml_mark_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed {
    pub stream_start: C2RustUnnamed_6,
    pub alias: C2RustUnnamed_5,
    pub anchor: C2RustUnnamed_4,
    pub tag: C2RustUnnamed_3,
    pub scalar: C2RustUnnamed_2,
    pub version_directive: C2RustUnnamed_1,
    pub tag_directive: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_0 {
    pub handle: *mut yaml_char_t,
    pub prefix: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub major: libc::c_int,
    pub minor: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub value: *mut yaml_char_t,
    pub length: size_t,
    pub style: yaml_scalar_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub handle: *mut yaml_char_t,
    pub suffix: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub value: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_5 {
    pub value: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_6 {
    pub encoding: yaml_encoding_t,
}
pub type yaml_token_t = yaml_token_s;
pub type yaml_event_type_e = libc::c_uint;
pub const YAML_MAPPING_END_EVENT: yaml_event_type_e = 10;
pub const YAML_MAPPING_START_EVENT: yaml_event_type_e = 9;
pub const YAML_SEQUENCE_END_EVENT: yaml_event_type_e = 8;
pub const YAML_SEQUENCE_START_EVENT: yaml_event_type_e = 7;
pub const YAML_SCALAR_EVENT: yaml_event_type_e = 6;
pub const YAML_ALIAS_EVENT: yaml_event_type_e = 5;
pub const YAML_DOCUMENT_END_EVENT: yaml_event_type_e = 4;
pub const YAML_DOCUMENT_START_EVENT: yaml_event_type_e = 3;
pub const YAML_STREAM_END_EVENT: yaml_event_type_e = 2;
pub const YAML_STREAM_START_EVENT: yaml_event_type_e = 1;
pub const YAML_NO_EVENT: yaml_event_type_e = 0;
pub type yaml_event_type_t = yaml_event_type_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_event_s {
    pub type_0: yaml_event_type_t,
    pub data: C2RustUnnamed_7,
    pub start_mark: yaml_mark_t,
    pub end_mark: yaml_mark_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub stream_start: C2RustUnnamed_15,
    pub document_start: C2RustUnnamed_13,
    pub document_end: C2RustUnnamed_12,
    pub alias: C2RustUnnamed_11,
    pub scalar: C2RustUnnamed_10,
    pub sequence_start: C2RustUnnamed_9,
    pub mapping_start: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_8 {
    pub anchor: *mut yaml_char_t,
    pub tag: *mut yaml_char_t,
    pub implicit: libc::c_int,
    pub style: yaml_mapping_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub anchor: *mut yaml_char_t,
    pub tag: *mut yaml_char_t,
    pub implicit: libc::c_int,
    pub style: yaml_sequence_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub anchor: *mut yaml_char_t,
    pub tag: *mut yaml_char_t,
    pub value: *mut yaml_char_t,
    pub length: size_t,
    pub plain_implicit: libc::c_int,
    pub quoted_implicit: libc::c_int,
    pub style: yaml_scalar_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_11 {
    pub anchor: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub implicit: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_13 {
    pub version_directive: *mut yaml_version_directive_t,
    pub tag_directives: C2RustUnnamed_14,
    pub implicit: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_15 {
    pub encoding: yaml_encoding_t,
}
pub type yaml_event_t = yaml_event_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
    pub top: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub error: yaml_error_type_t,
}
pub type yaml_node_type_e = libc::c_uint;
pub const YAML_MAPPING_NODE: yaml_node_type_e = 3;
pub const YAML_SEQUENCE_NODE: yaml_node_type_e = 2;
pub const YAML_SCALAR_NODE: yaml_node_type_e = 1;
pub const YAML_NO_NODE: yaml_node_type_e = 0;
pub type yaml_node_type_t = yaml_node_type_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_node_s {
    pub type_0: yaml_node_type_t,
    pub tag: *mut yaml_char_t,
    pub data: C2RustUnnamed_18,
    pub start_mark: yaml_mark_t,
    pub end_mark: yaml_mark_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub scalar: C2RustUnnamed_23,
    pub sequence: C2RustUnnamed_21,
    pub mapping: C2RustUnnamed_19,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub pairs: C2RustUnnamed_20,
    pub style: yaml_mapping_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub start: *mut yaml_node_pair_t,
    pub end: *mut yaml_node_pair_t,
    pub top: *mut yaml_node_pair_t,
}
pub type yaml_node_pair_t = yaml_node_pair_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_node_pair_s {
    pub key: libc::c_int,
    pub value: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub items: C2RustUnnamed_22,
    pub style: yaml_sequence_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub start: *mut yaml_node_item_t,
    pub end: *mut yaml_node_item_t,
    pub top: *mut yaml_node_item_t,
}
pub type yaml_node_item_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub value: *mut yaml_char_t,
    pub length: size_t,
    pub style: yaml_scalar_style_t,
}
pub type yaml_node_t = yaml_node_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_document_s {
    pub nodes: C2RustUnnamed_25,
    pub version_directive: *mut yaml_version_directive_t,
    pub tag_directives: C2RustUnnamed_24,
    pub start_implicit: libc::c_int,
    pub end_implicit: libc::c_int,
    pub start_mark: yaml_mark_t,
    pub end_mark: yaml_mark_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_24 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_25 {
    pub start: *mut yaml_node_t,
    pub end: *mut yaml_node_t,
    pub top: *mut yaml_node_t,
}
pub type yaml_document_t = yaml_document_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
    pub top: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_27 {
    pub start: *mut yaml_node_t,
    pub end: *mut yaml_node_t,
    pub top: *mut yaml_node_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
    pub error: yaml_error_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_29 {
    pub error: yaml_error_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub start: *mut yaml_node_item_t,
    pub end: *mut yaml_node_item_t,
    pub top: *mut yaml_node_item_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_31 {
    pub error: yaml_error_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
    pub start: *mut yaml_node_pair_t,
    pub end: *mut yaml_node_pair_t,
    pub top: *mut yaml_node_pair_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_33 {
    pub error: yaml_error_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_34 {
    pub error: yaml_error_type_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_35 {
    pub error: yaml_error_type_t,
}
pub type yaml_read_handler_t =
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_uchar, size_t, *mut size_t) -> libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_simple_key_s {
    pub possible: libc::c_int,
    pub required: libc::c_int,
    pub token_number: size_t,
    pub mark: yaml_mark_t,
}
pub type yaml_simple_key_t = yaml_simple_key_s;
pub type yaml_parser_state_e = libc::c_uint;
pub const YAML_PARSE_END_STATE: yaml_parser_state_e = 23;
pub const YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE: yaml_parser_state_e = 22;
pub const YAML_PARSE_FLOW_MAPPING_VALUE_STATE: yaml_parser_state_e = 21;
pub const YAML_PARSE_FLOW_MAPPING_KEY_STATE: yaml_parser_state_e = 20;
pub const YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE: yaml_parser_state_e = 19;
pub const YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE: yaml_parser_state_e = 18;
pub const YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE: yaml_parser_state_e = 17;
pub const YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE: yaml_parser_state_e = 16;
pub const YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE: yaml_parser_state_e = 15;
pub const YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE: yaml_parser_state_e = 14;
pub const YAML_PARSE_BLOCK_MAPPING_VALUE_STATE: yaml_parser_state_e = 13;
pub const YAML_PARSE_BLOCK_MAPPING_KEY_STATE: yaml_parser_state_e = 12;
pub const YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE: yaml_parser_state_e = 11;
pub const YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE: yaml_parser_state_e = 10;
pub const YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE: yaml_parser_state_e = 9;
pub const YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE: yaml_parser_state_e = 8;
pub const YAML_PARSE_FLOW_NODE_STATE: yaml_parser_state_e = 7;
pub const YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE: yaml_parser_state_e = 6;
pub const YAML_PARSE_BLOCK_NODE_STATE: yaml_parser_state_e = 5;
pub const YAML_PARSE_DOCUMENT_END_STATE: yaml_parser_state_e = 4;
pub const YAML_PARSE_DOCUMENT_CONTENT_STATE: yaml_parser_state_e = 3;
pub const YAML_PARSE_DOCUMENT_START_STATE: yaml_parser_state_e = 2;
pub const YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE: yaml_parser_state_e = 1;
pub const YAML_PARSE_STREAM_START_STATE: yaml_parser_state_e = 0;
pub type yaml_parser_state_t = yaml_parser_state_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_alias_data_s {
    pub anchor: *mut yaml_char_t,
    pub index: libc::c_int,
    pub mark: yaml_mark_t,
}
pub type yaml_alias_data_t = yaml_alias_data_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_parser_s {
    pub error: yaml_error_type_t,
    pub problem: *const libc::c_char,
    pub problem_offset: size_t,
    pub problem_value: libc::c_int,
    pub problem_mark: yaml_mark_t,
    pub context: *const libc::c_char,
    pub context_mark: yaml_mark_t,
    pub read_handler: Option<yaml_read_handler_t>,
    pub read_handler_data: *mut libc::c_void,
    pub input: C2RustUnnamed_45,
    pub eof: libc::c_int,
    pub buffer: C2RustUnnamed_44,
    pub unread: size_t,
    pub raw_buffer: C2RustUnnamed_43,
    pub encoding: yaml_encoding_t,
    pub offset: size_t,
    pub mark: yaml_mark_t,
    pub stream_start_produced: libc::c_int,
    pub stream_end_produced: libc::c_int,
    pub flow_level: libc::c_int,
    pub tokens: C2RustUnnamed_42,
    pub tokens_parsed: size_t,
    pub token_available: libc::c_int,
    pub indents: C2RustUnnamed_41,
    pub indent: libc::c_int,
    pub simple_key_allowed: libc::c_int,
    pub simple_keys: C2RustUnnamed_40,
    pub states: C2RustUnnamed_39,
    pub state: yaml_parser_state_t,
    pub marks: C2RustUnnamed_38,
    pub tag_directives: C2RustUnnamed_37,
    pub aliases: C2RustUnnamed_36,
    pub document: *mut yaml_document_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
    pub start: *mut yaml_alias_data_t,
    pub end: *mut yaml_alias_data_t,
    pub top: *mut yaml_alias_data_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_37 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
    pub top: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_38 {
    pub start: *mut yaml_mark_t,
    pub end: *mut yaml_mark_t,
    pub top: *mut yaml_mark_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_39 {
    pub start: *mut yaml_parser_state_t,
    pub end: *mut yaml_parser_state_t,
    pub top: *mut yaml_parser_state_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_40 {
    pub start: *mut yaml_simple_key_t,
    pub end: *mut yaml_simple_key_t,
    pub top: *mut yaml_simple_key_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_41 {
    pub start: *mut libc::c_int,
    pub end: *mut libc::c_int,
    pub top: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_42 {
    pub start: *mut yaml_token_t,
    pub end: *mut yaml_token_t,
    pub head: *mut yaml_token_t,
    pub tail: *mut yaml_token_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_43 {
    pub start: *mut libc::c_uchar,
    pub end: *mut libc::c_uchar,
    pub pointer: *mut libc::c_uchar,
    pub last: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_44 {
    pub start: *mut yaml_char_t,
    pub end: *mut yaml_char_t,
    pub pointer: *mut yaml_char_t,
    pub last: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_45 {
    pub string: C2RustUnnamed_46,
    pub file: *mut FILE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_46 {
    pub start: *const libc::c_uchar,
    pub end: *const libc::c_uchar,
    pub current: *const libc::c_uchar,
}
pub type yaml_parser_t = yaml_parser_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_string_t {
    pub start: *mut yaml_char_t,
    pub end: *mut yaml_char_t,
    pub pointer: *mut yaml_char_t,
}
pub type ptrdiff_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_47 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_48 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
    pub top: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct loader_ctx {
    pub start: *mut libc::c_int,
    pub end: *mut libc::c_int,
    pub top: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_49 {
    pub start: *mut yaml_node_pair_t,
    pub end: *mut yaml_node_pair_t,
    pub top: *mut yaml_node_pair_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_50 {
    pub start: *mut yaml_node_item_t,
    pub end: *mut yaml_node_item_t,
    pub top: *mut yaml_node_item_t,
}
pub type yaml_write_handler_t =
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_uchar, size_t) -> libc::c_int;
pub type yaml_emitter_state_e = libc::c_uint;
pub const YAML_EMIT_END_STATE: yaml_emitter_state_e = 17;
pub const YAML_EMIT_BLOCK_MAPPING_VALUE_STATE: yaml_emitter_state_e = 16;
pub const YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE: yaml_emitter_state_e = 15;
pub const YAML_EMIT_BLOCK_MAPPING_KEY_STATE: yaml_emitter_state_e = 14;
pub const YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE: yaml_emitter_state_e = 13;
pub const YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE: yaml_emitter_state_e = 12;
pub const YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE: yaml_emitter_state_e = 11;
pub const YAML_EMIT_FLOW_MAPPING_VALUE_STATE: yaml_emitter_state_e = 10;
pub const YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE: yaml_emitter_state_e = 9;
pub const YAML_EMIT_FLOW_MAPPING_KEY_STATE: yaml_emitter_state_e = 8;
pub const YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE: yaml_emitter_state_e = 7;
pub const YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE: yaml_emitter_state_e = 6;
pub const YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE: yaml_emitter_state_e = 5;
pub const YAML_EMIT_DOCUMENT_END_STATE: yaml_emitter_state_e = 4;
pub const YAML_EMIT_DOCUMENT_CONTENT_STATE: yaml_emitter_state_e = 3;
pub const YAML_EMIT_DOCUMENT_START_STATE: yaml_emitter_state_e = 2;
pub const YAML_EMIT_FIRST_DOCUMENT_START_STATE: yaml_emitter_state_e = 1;
pub const YAML_EMIT_STREAM_START_STATE: yaml_emitter_state_e = 0;
pub type yaml_emitter_state_t = yaml_emitter_state_e;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_anchors_s {
    pub references: libc::c_int,
    pub anchor: libc::c_int,
    pub serialized: libc::c_int,
}
pub type yaml_anchors_t = yaml_anchors_s;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct yaml_emitter_s {
    pub error: yaml_error_type_t,
    pub problem: *const libc::c_char,
    pub write_handler: Option<yaml_write_handler_t>,
    pub write_handler_data: *mut libc::c_void,
    pub output: C2RustUnnamed_60,
    pub buffer: C2RustUnnamed_59,
    pub raw_buffer: C2RustUnnamed_58,
    pub encoding: yaml_encoding_t,
    pub canonical: libc::c_int,
    pub best_indent: libc::c_int,
    pub best_width: libc::c_int,
    pub unicode: libc::c_int,
    pub line_break: yaml_break_t,
    pub states: C2RustUnnamed_57,
    pub state: yaml_emitter_state_t,
    pub events: C2RustUnnamed_56,
    pub indents: C2RustUnnamed_55,
    pub tag_directives: C2RustUnnamed_54,
    pub indent: libc::c_int,
    pub flow_level: libc::c_int,
    pub root_context: libc::c_int,
    pub sequence_context: libc::c_int,
    pub mapping_context: libc::c_int,
    pub simple_key_context: libc::c_int,
    pub line: libc::c_int,
    pub column: libc::c_int,
    pub whitespace: libc::c_int,
    pub indention: libc::c_int,
    pub open_ended: libc::c_int,
    pub anchor_data: C2RustUnnamed_53,
    pub tag_data: C2RustUnnamed_52,
    pub scalar_data: C2RustUnnamed_51,
    pub opened: libc::c_int,
    pub closed: libc::c_int,
    pub anchors: *mut yaml_anchors_t,
    pub last_anchor_id: libc::c_int,
    pub document: *mut yaml_document_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_51 {
    pub value: *mut yaml_char_t,
    pub length: size_t,
    pub multiline: libc::c_int,
    pub flow_plain_allowed: libc::c_int,
    pub block_plain_allowed: libc::c_int,
    pub single_quoted_allowed: libc::c_int,
    pub block_allowed: libc::c_int,
    pub style: yaml_scalar_style_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_52 {
    pub handle: *mut yaml_char_t,
    pub handle_length: size_t,
    pub suffix: *mut yaml_char_t,
    pub suffix_length: size_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_53 {
    pub anchor: *mut yaml_char_t,
    pub anchor_length: size_t,
    pub alias: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_54 {
    pub start: *mut yaml_tag_directive_t,
    pub end: *mut yaml_tag_directive_t,
    pub top: *mut yaml_tag_directive_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_55 {
    pub start: *mut libc::c_int,
    pub end: *mut libc::c_int,
    pub top: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_56 {
    pub start: *mut yaml_event_t,
    pub end: *mut yaml_event_t,
    pub head: *mut yaml_event_t,
    pub tail: *mut yaml_event_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_57 {
    pub start: *mut yaml_emitter_state_t,
    pub end: *mut yaml_emitter_state_t,
    pub top: *mut yaml_emitter_state_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_58 {
    pub start: *mut libc::c_uchar,
    pub end: *mut libc::c_uchar,
    pub pointer: *mut libc::c_uchar,
    pub last: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_59 {
    pub start: *mut yaml_char_t,
    pub end: *mut yaml_char_t,
    pub pointer: *mut yaml_char_t,
    pub last: *mut yaml_char_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_60 {
    pub string: C2RustUnnamed_61,
    pub file: *mut FILE,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_61 {
    pub buffer: *mut libc::c_uchar,
    pub size: size_t,
    pub size_written: *mut size_t,
}
pub type yaml_emitter_t = yaml_emitter_s;
#[no_mangle]
pub unsafe extern "C" fn yaml_get_version_string() -> *const libc::c_char {
    return b"0.2.5\0" as *const u8 as *const libc::c_char;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_get_version(
    mut major: *mut libc::c_int,
    mut minor: *mut libc::c_int,
    mut patch: *mut libc::c_int,
) {
    *major = 0 as libc::c_int;
    *minor = 2 as libc::c_int;
    *patch = 5 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_token_delete(mut token: *mut yaml_token_t) {
    if !token.is_null() {
    } else {
        __assert_fail(
            b"token\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            586 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 39], &[libc::c_char; 39]>(
                b"void yaml_token_delete(yaml_token_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_2519: {
        if !token.is_null() {
        } else {
            __assert_fail(
                b"token\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                586 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 39], &[libc::c_char; 39]>(
                    b"void yaml_token_delete(yaml_token_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    match (*token).type_0 as libc::c_uint {
        4 => {
            yaml_free((*token).data.tag_directive.handle as *mut libc::c_void);
            yaml_free((*token).data.tag_directive.prefix as *mut libc::c_void);
        }
        18 => {
            yaml_free((*token).data.alias.value as *mut libc::c_void);
        }
        19 => {
            yaml_free((*token).data.anchor.value as *mut libc::c_void);
        }
        20 => {
            yaml_free((*token).data.tag.handle as *mut libc::c_void);
            yaml_free((*token).data.tag.suffix as *mut libc::c_void);
        }
        21 => {
            yaml_free((*token).data.scalar.value as *mut libc::c_void);
        }
        _ => {}
    }
    memset(
        token as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn yaml_free(mut ptr: *mut libc::c_void) {
    if !ptr.is_null() {
        free(ptr);
    }
}
#[no_mangle]
pub unsafe extern "C" fn yaml_stream_end_event_initialize(
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            690 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 53], &[libc::c_char; 53]>(
                b"int yaml_stream_end_event_initialize(yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_2831: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                690 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 53], &[libc::c_char; 53]>(
                    b"int yaml_stream_end_event_initialize(yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_STREAM_END_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_start_event_initialize(
    mut event: *mut yaml_event_t,
    mut version_directive: *mut yaml_version_directive_t,
    mut tag_directives_start: *mut yaml_tag_directive_t,
    mut tag_directives_end: *mut yaml_tag_directive_t,
    mut implicit: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut context: C2RustUnnamed_17 = C2RustUnnamed_17 {
        error: YAML_NO_ERROR,
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut version_directive_copy: *mut yaml_version_directive_t =
        0 as *mut yaml_version_directive_t;
    let mut tag_directives_copy: C2RustUnnamed_16 = {
        let mut init = C2RustUnnamed_16 {
            start: 0 as *mut yaml_tag_directive_t,
            end: 0 as *mut yaml_tag_directive_t,
            top: 0 as *mut yaml_tag_directive_t,
        };
        init
    };
    let mut value: yaml_tag_directive_t = {
        let mut init = yaml_tag_directive_s {
            handle: 0 as *mut yaml_char_t,
            prefix: 0 as *mut yaml_char_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            720 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 138],
                &[libc::c_char; 138],
            >(
                b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
            ))
                .as_ptr(),
        );
    }
    'c_3990: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                720 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 138],
                    &[libc::c_char; 138],
                >(
                    b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !tag_directives_start.is_null() && !tag_directives_end.is_null()
        || tag_directives_start == tag_directives_end
    {
    } else {
        __assert_fail(
            b"(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)\0"
                as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            722 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 138],
                &[libc::c_char; 138],
            >(
                b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
            ))
                .as_ptr(),
        );
    }
    'c_3935: {
        if !tag_directives_start.is_null() && !tag_directives_end.is_null()
            || tag_directives_start == tag_directives_end
        {
        } else {
            __assert_fail(
                b"(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)\0"
                    as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                722 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 138],
                    &[libc::c_char; 138],
                >(
                    b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !version_directive.is_null() {
        version_directive_copy =
            yaml_malloc(::core::mem::size_of::<yaml_version_directive_t>() as libc::c_ulong)
                as *mut yaml_version_directive_t;
        if version_directive_copy.is_null() {
            current_block = 13859505213438211373;
        } else {
            (*version_directive_copy).major = (*version_directive).major;
            (*version_directive_copy).minor = (*version_directive).minor;
            current_block = 11006700562992250127;
        }
    } else {
        current_block = 11006700562992250127;
    }
    match current_block {
        11006700562992250127 => {
            if tag_directives_start != tag_directives_end {
                let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
                tag_directives_copy.start =
                    yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                        ::core::mem::size_of::<yaml_tag_directive_t>() as libc::c_ulong,
                    )) as *mut yaml_tag_directive_t;
                if if !(tag_directives_copy.start).is_null() {
                    tag_directives_copy.top = tag_directives_copy.start;
                    tag_directives_copy.end =
                        (tag_directives_copy.start).offset(16 as libc::c_int as isize);
                    1 as libc::c_int
                } else {
                    context.error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0
                {
                    current_block = 13859505213438211373;
                } else {
                    tag_directive = tag_directives_start;
                    loop {
                        if !(tag_directive != tag_directives_end) {
                            current_block = 4808432441040389987;
                            break;
                        }
                        if !((*tag_directive).handle).is_null() {
                        } else {
                            __assert_fail(
                                b"tag_directive->handle\0" as *const u8
                                    as *const libc::c_char,
                                b"./api.c\0" as *const u8 as *const libc::c_char,
                                738 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 138],
                                    &[libc::c_char; 138],
                                >(
                                    b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                        'c_3779: {
                            if !((*tag_directive).handle).is_null() {
                            } else {
                                __assert_fail(
                                    b"tag_directive->handle\0" as *const u8
                                        as *const libc::c_char,
                                    b"./api.c\0" as *const u8 as *const libc::c_char,
                                    738 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 138],
                                        &[libc::c_char; 138],
                                    >(
                                        b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                        };
                        if !((*tag_directive).prefix).is_null() {
                        } else {
                            __assert_fail(
                                b"tag_directive->prefix\0" as *const u8
                                    as *const libc::c_char,
                                b"./api.c\0" as *const u8 as *const libc::c_char,
                                739 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 138],
                                    &[libc::c_char; 138],
                                >(
                                    b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                                ))
                                    .as_ptr(),
                            );
                        }
                        'c_3741: {
                            if !((*tag_directive).prefix).is_null() {
                            } else {
                                __assert_fail(
                                    b"tag_directive->prefix\0" as *const u8
                                        as *const libc::c_char,
                                    b"./api.c\0" as *const u8 as *const libc::c_char,
                                    739 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 138],
                                        &[libc::c_char; 138],
                                    >(
                                        b"int yaml_document_start_event_initialize(yaml_event_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                        };
                        if yaml_check_utf8(
                            (*tag_directive).handle,
                            strlen((*tag_directive).handle as *mut libc::c_char),
                        ) == 0
                        {
                            current_block = 13859505213438211373;
                            break;
                        }
                        if yaml_check_utf8(
                            (*tag_directive).prefix,
                            strlen((*tag_directive).prefix as *mut libc::c_char),
                        ) == 0
                        {
                            current_block = 13859505213438211373;
                            break;
                        }
                        value.handle = yaml_strdup((*tag_directive).handle);
                        value.prefix = yaml_strdup((*tag_directive).prefix);
                        if (value.handle).is_null() || (value.prefix).is_null() {
                            current_block = 13859505213438211373;
                            break;
                        }
                        if if tag_directives_copy.top != tag_directives_copy.end
                            || yaml_stack_extend(
                                &mut tag_directives_copy.start as *mut *mut yaml_tag_directive_t
                                    as *mut *mut libc::c_void,
                                &mut tag_directives_copy.top as *mut *mut yaml_tag_directive_t
                                    as *mut *mut libc::c_void,
                                &mut tag_directives_copy.end as *mut *mut yaml_tag_directive_t
                                    as *mut *mut libc::c_void,
                            ) != 0
                        {
                            let fresh0 = tag_directives_copy.top;
                            tag_directives_copy.top = (tag_directives_copy.top).offset(1);
                            *fresh0 = value;
                            1 as libc::c_int
                        } else {
                            context.error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            current_block = 13859505213438211373;
                            break;
                        }
                        value.handle = 0 as *mut yaml_char_t;
                        value.prefix = 0 as *mut yaml_char_t;
                        tag_directive = tag_directive.offset(1);
                        tag_directive;
                    }
                }
            } else {
                current_block = 4808432441040389987;
            }
            match current_block {
                13859505213438211373 => {}
                _ => {
                    memset(
                        event as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                    );
                    (*event).type_0 = YAML_DOCUMENT_START_EVENT;
                    (*event).start_mark = mark;
                    (*event).end_mark = mark;
                    (*event).data.document_start.version_directive = version_directive_copy;
                    (*event).data.document_start.tag_directives.start = tag_directives_copy.start;
                    (*event).data.document_start.tag_directives.end = tag_directives_copy.top;
                    (*event).data.document_start.implicit = implicit;
                    return 1 as libc::c_int;
                }
            }
        }
        _ => {}
    }
    yaml_free(version_directive_copy as *mut libc::c_void);
    while !(tag_directives_copy.start == tag_directives_copy.top) {
        tag_directives_copy.top = (tag_directives_copy.top).offset(-1);
        let mut value_0: yaml_tag_directive_t = *tag_directives_copy.top;
        yaml_free(value_0.handle as *mut libc::c_void);
        yaml_free(value_0.prefix as *mut libc::c_void);
    }
    yaml_free(tag_directives_copy.start as *mut libc::c_void);
    tag_directives_copy.end = 0 as *mut yaml_tag_directive_t;
    tag_directives_copy.top = tag_directives_copy.end;
    tag_directives_copy.start = tag_directives_copy.top;
    yaml_free(value.handle as *mut libc::c_void);
    yaml_free(value.prefix as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_stack_extend(
    mut start: *mut *mut libc::c_void,
    mut top: *mut *mut libc::c_void,
    mut end: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut new_start: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*end as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
        >= (2147483647 as libc::c_int / 2 as libc::c_int) as libc::c_long
    {
        return 0 as libc::c_int;
    }
    new_start = yaml_realloc(
        *start,
        ((*end as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
            * 2 as libc::c_int as libc::c_long) as size_t,
    );
    if new_start.is_null() {
        return 0 as libc::c_int;
    }
    *top = (new_start as *mut libc::c_char).offset(
        (*top as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
            as isize,
    ) as *mut libc::c_void;
    *end = (new_start as *mut libc::c_char).offset(
        ((*end as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
            * 2 as libc::c_int as libc::c_long) as isize,
    ) as *mut libc::c_void;
    *start = new_start;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_realloc(
    mut ptr: *mut libc::c_void,
    mut size: size_t,
) -> *mut libc::c_void {
    return if !ptr.is_null() {
        realloc(
            ptr,
            if size != 0 {
                size
            } else {
                1 as libc::c_int as libc::c_ulong
            },
        )
    } else {
        malloc(if size != 0 {
            size
        } else {
            1 as libc::c_int as libc::c_ulong
        })
    };
}
#[no_mangle]
pub unsafe extern "C" fn yaml_strdup(mut str: *const yaml_char_t) -> *mut yaml_char_t {
    if str.is_null() {
        return 0 as *mut yaml_char_t;
    }
    return strdup(str as *mut libc::c_char) as *mut yaml_char_t;
}
unsafe extern "C" fn yaml_check_utf8(
    mut start: *const yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut end: *const yaml_char_t = start.offset(length as isize);
    let mut pointer: *const yaml_char_t = start;
    while pointer < end {
        let mut octet: libc::c_uchar = 0;
        let mut width: libc::c_uint = 0;
        let mut value: libc::c_uint = 0;
        let mut k: size_t = 0;
        octet = *pointer.offset(0 as libc::c_int as isize);
        width = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
            1 as libc::c_int
        } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
            2 as libc::c_int
        } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
            3 as libc::c_int
        } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
            4 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        value = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
            octet as libc::c_int & 0x7f as libc::c_int
        } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
            octet as libc::c_int & 0x1f as libc::c_int
        } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
            octet as libc::c_int & 0xf as libc::c_int
        } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
            octet as libc::c_int & 0x7 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        if width == 0 {
            return 0 as libc::c_int;
        }
        if pointer.offset(width as isize) > end {
            return 0 as libc::c_int;
        }
        k = 1 as libc::c_int as size_t;
        while k < width as libc::c_ulong {
            octet = *pointer.offset(k as isize);
            if octet as libc::c_int & 0xc0 as libc::c_int != 0x80 as libc::c_int {
                return 0 as libc::c_int;
            }
            value = (value << 6 as libc::c_int)
                .wrapping_add((octet as libc::c_int & 0x3f as libc::c_int) as libc::c_uint);
            k = k.wrapping_add(1);
            k;
        }
        if !(width == 1 as libc::c_int as libc::c_uint
            || width == 2 as libc::c_int as libc::c_uint
                && value >= 0x80 as libc::c_int as libc::c_uint
            || width == 3 as libc::c_int as libc::c_uint
                && value >= 0x800 as libc::c_int as libc::c_uint
            || width == 4 as libc::c_int as libc::c_uint
                && value >= 0x10000 as libc::c_int as libc::c_uint)
        {
            return 0 as libc::c_int;
        }
        pointer = pointer.offset(width as isize);
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_malloc(mut size: size_t) -> *mut libc::c_void {
    return malloc(if size != 0 {
        size
    } else {
        1 as libc::c_int as libc::c_ulong
    });
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_end_event_initialize(
    mut event: *mut yaml_event_t,
    mut implicit: libc::c_int,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            785 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"int yaml_document_end_event_initialize(yaml_event_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_4102: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                785 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"int yaml_document_end_event_initialize(yaml_event_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_DOCUMENT_END_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    (*event).data.document_end.implicit = implicit;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_alias_event_initialize(
    mut event: *mut yaml_event_t,
    mut anchor: *const yaml_char_t,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut anchor_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            802 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 69], &[libc::c_char; 69]>(
                b"int yaml_alias_event_initialize(yaml_event_t *, const yaml_char_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_4286: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                802 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 69], &[libc::c_char; 69]>(
                    b"int yaml_alias_event_initialize(yaml_event_t *, const yaml_char_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !anchor.is_null() {
    } else {
        __assert_fail(
            b"anchor\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            803 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 69], &[libc::c_char; 69]>(
                b"int yaml_alias_event_initialize(yaml_event_t *, const yaml_char_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_4252: {
        if !anchor.is_null() {
        } else {
            __assert_fail(
                b"anchor\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                803 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 69], &[libc::c_char; 69]>(
                    b"int yaml_alias_event_initialize(yaml_event_t *, const yaml_char_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if yaml_check_utf8(anchor, strlen(anchor as *mut libc::c_char)) == 0 {
        return 0 as libc::c_int;
    }
    anchor_copy = yaml_strdup(anchor);
    if anchor_copy.is_null() {
        return 0 as libc::c_int;
    }
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_ALIAS_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    (*event).data.alias.anchor = anchor_copy;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_scalar_event_initialize(
    mut event: *mut yaml_event_t,
    mut anchor: *const yaml_char_t,
    mut tag: *const yaml_char_t,
    mut value: *const yaml_char_t,
    mut length: libc::c_int,
    mut plain_implicit: libc::c_int,
    mut quoted_implicit: libc::c_int,
    mut style: yaml_scalar_style_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut anchor_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut value_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            832 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 148],
                &[libc::c_char; 148],
            >(
                b"int yaml_scalar_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, const yaml_char_t *, int, int, int, yaml_scalar_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_4686: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                832 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 148],
                    &[libc::c_char; 148],
                >(
                    b"int yaml_scalar_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, const yaml_char_t *, int, int, int, yaml_scalar_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !value.is_null() {
    } else {
        __assert_fail(
            b"value\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            833 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 148],
                &[libc::c_char; 148],
            >(
                b"int yaml_scalar_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, const yaml_char_t *, int, int, int, yaml_scalar_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_4653: {
        if !value.is_null() {
        } else {
            __assert_fail(
                b"value\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                833 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 148],
                    &[libc::c_char; 148],
                >(
                    b"int yaml_scalar_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, const yaml_char_t *, int, int, int, yaml_scalar_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !anchor.is_null() {
        if yaml_check_utf8(anchor, strlen(anchor as *mut libc::c_char)) == 0 {
            current_block = 11451684389794204919;
        } else {
            anchor_copy = yaml_strdup(anchor);
            if anchor_copy.is_null() {
                current_block = 11451684389794204919;
            } else {
                current_block = 2473556513754201174;
            }
        }
    } else {
        current_block = 2473556513754201174;
    }
    match current_block {
        2473556513754201174 => {
            if !tag.is_null() {
                if yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0 {
                    current_block = 11451684389794204919;
                } else {
                    tag_copy = yaml_strdup(tag);
                    if tag_copy.is_null() {
                        current_block = 11451684389794204919;
                    } else {
                        current_block = 2868539653012386629;
                    }
                }
            } else {
                current_block = 2868539653012386629;
            }
            match current_block {
                11451684389794204919 => {}
                _ => {
                    if length < 0 as libc::c_int {
                        length = strlen(value as *mut libc::c_char) as libc::c_int;
                    }
                    if !(yaml_check_utf8(value, length as size_t) == 0) {
                        value_copy =
                            yaml_malloc((length + 1 as libc::c_int) as size_t) as *mut yaml_char_t;
                        if !value_copy.is_null() {
                            memcpy(
                                value_copy as *mut libc::c_void,
                                value as *const libc::c_void,
                                length as libc::c_ulong,
                            );
                            *value_copy.offset(length as isize) = '\0' as i32 as yaml_char_t;
                            memset(
                                event as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                            );
                            (*event).type_0 = YAML_SCALAR_EVENT;
                            (*event).start_mark = mark;
                            (*event).end_mark = mark;
                            (*event).data.scalar.anchor = anchor_copy;
                            (*event).data.scalar.tag = tag_copy;
                            (*event).data.scalar.value = value_copy;
                            (*event).data.scalar.length = length as size_t;
                            (*event).data.scalar.plain_implicit = plain_implicit;
                            (*event).data.scalar.quoted_implicit = quoted_implicit;
                            (*event).data.scalar.style = style;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
        _ => {}
    }
    yaml_free(anchor_copy as *mut libc::c_void);
    yaml_free(tag_copy as *mut libc::c_void);
    yaml_free(value_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_sequence_start_event_initialize(
    mut event: *mut yaml_event_t,
    mut anchor: *const yaml_char_t,
    mut tag: *const yaml_char_t,
    mut implicit: libc::c_int,
    mut style: yaml_sequence_style_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut anchor_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            883 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 127],
                &[libc::c_char; 127],
            >(
                b"int yaml_sequence_start_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_sequence_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_4930: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                883 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 127],
                    &[libc::c_char; 127],
                >(
                    b"int yaml_sequence_start_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_sequence_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !anchor.is_null() {
        if yaml_check_utf8(anchor, strlen(anchor as *mut libc::c_char)) == 0 {
            current_block = 2510574010389209623;
        } else {
            anchor_copy = yaml_strdup(anchor);
            if anchor_copy.is_null() {
                current_block = 2510574010389209623;
            } else {
                current_block = 15427931788582360902;
            }
        }
    } else {
        current_block = 15427931788582360902;
    }
    match current_block {
        15427931788582360902 => {
            if !tag.is_null() {
                if yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0 {
                    current_block = 2510574010389209623;
                } else {
                    tag_copy = yaml_strdup(tag);
                    if tag_copy.is_null() {
                        current_block = 2510574010389209623;
                    } else {
                        current_block = 1394248824506584008;
                    }
                }
            } else {
                current_block = 1394248824506584008;
            }
            match current_block {
                2510574010389209623 => {}
                _ => {
                    memset(
                        event as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                    );
                    (*event).type_0 = YAML_SEQUENCE_START_EVENT;
                    (*event).start_mark = mark;
                    (*event).end_mark = mark;
                    (*event).data.sequence_start.anchor = anchor_copy;
                    (*event).data.sequence_start.tag = tag_copy;
                    (*event).data.sequence_start.implicit = implicit;
                    (*event).data.sequence_start.style = style;
                    return 1 as libc::c_int;
                }
            }
        }
        _ => {}
    }
    yaml_free(anchor_copy as *mut libc::c_void);
    yaml_free(tag_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_sequence_end_event_initialize(
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            918 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                b"int yaml_sequence_end_event_initialize(yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_5029: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                918 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                    b"int yaml_sequence_end_event_initialize(yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_SEQUENCE_END_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_mapping_start_event_initialize(
    mut event: *mut yaml_event_t,
    mut anchor: *const yaml_char_t,
    mut tag: *const yaml_char_t,
    mut implicit: libc::c_int,
    mut style: yaml_mapping_style_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut anchor_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            938 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 125],
                &[libc::c_char; 125],
            >(
                b"int yaml_mapping_start_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_mapping_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_5274: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                938 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 125],
                    &[libc::c_char; 125],
                >(
                    b"int yaml_mapping_start_event_initialize(yaml_event_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_mapping_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !anchor.is_null() {
        if yaml_check_utf8(anchor, strlen(anchor as *mut libc::c_char)) == 0 {
            current_block = 8111824274182843135;
        } else {
            anchor_copy = yaml_strdup(anchor);
            if anchor_copy.is_null() {
                current_block = 8111824274182843135;
            } else {
                current_block = 15427931788582360902;
            }
        }
    } else {
        current_block = 15427931788582360902;
    }
    match current_block {
        15427931788582360902 => {
            if !tag.is_null() {
                if yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0 {
                    current_block = 8111824274182843135;
                } else {
                    tag_copy = yaml_strdup(tag);
                    if tag_copy.is_null() {
                        current_block = 8111824274182843135;
                    } else {
                        current_block = 1394248824506584008;
                    }
                }
            } else {
                current_block = 1394248824506584008;
            }
            match current_block {
                8111824274182843135 => {}
                _ => {
                    memset(
                        event as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                    );
                    (*event).type_0 = YAML_MAPPING_START_EVENT;
                    (*event).start_mark = mark;
                    (*event).end_mark = mark;
                    (*event).data.mapping_start.anchor = anchor_copy;
                    (*event).data.mapping_start.tag = tag_copy;
                    (*event).data.mapping_start.implicit = implicit;
                    (*event).data.mapping_start.style = style;
                    return 1 as libc::c_int;
                }
            }
        }
        _ => {}
    }
    yaml_free(anchor_copy as *mut libc::c_void);
    yaml_free(tag_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_mapping_end_event_initialize(
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            973 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                b"int yaml_mapping_end_event_initialize(yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_5373: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                973 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                    b"int yaml_mapping_end_event_initialize(yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_MAPPING_END_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_event_delete(mut event: *mut yaml_event_t) {
    let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            989 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 39], &[libc::c_char; 39]>(
                b"void yaml_event_delete(yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_5609: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                989 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 39], &[libc::c_char; 39]>(
                    b"void yaml_event_delete(yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    match (*event).type_0 as libc::c_uint {
        3 => {
            yaml_free((*event).data.document_start.version_directive as *mut libc::c_void);
            tag_directive = (*event).data.document_start.tag_directives.start;
            while tag_directive != (*event).data.document_start.tag_directives.end {
                yaml_free((*tag_directive).handle as *mut libc::c_void);
                yaml_free((*tag_directive).prefix as *mut libc::c_void);
                tag_directive = tag_directive.offset(1);
                tag_directive;
            }
            yaml_free((*event).data.document_start.tag_directives.start as *mut libc::c_void);
        }
        5 => {
            yaml_free((*event).data.alias.anchor as *mut libc::c_void);
        }
        6 => {
            yaml_free((*event).data.scalar.anchor as *mut libc::c_void);
            yaml_free((*event).data.scalar.tag as *mut libc::c_void);
            yaml_free((*event).data.scalar.value as *mut libc::c_void);
        }
        7 => {
            yaml_free((*event).data.sequence_start.anchor as *mut libc::c_void);
            yaml_free((*event).data.sequence_start.tag as *mut libc::c_void);
        }
        9 => {
            yaml_free((*event).data.mapping_start.anchor as *mut libc::c_void);
            yaml_free((*event).data.mapping_start.tag as *mut libc::c_void);
        }
        _ => {}
    }
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_initialize(
    mut document: *mut yaml_document_t,
    mut version_directive: *mut yaml_version_directive_t,
    mut tag_directives_start: *mut yaml_tag_directive_t,
    mut tag_directives_end: *mut yaml_tag_directive_t,
    mut start_implicit: libc::c_int,
    mut end_implicit: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut context: C2RustUnnamed_28 = C2RustUnnamed_28 {
        error: YAML_NO_ERROR,
    };
    let mut nodes: C2RustUnnamed_27 = {
        let mut init = C2RustUnnamed_27 {
            start: 0 as *mut yaml_node_t,
            end: 0 as *mut yaml_node_t,
            top: 0 as *mut yaml_node_t,
        };
        init
    };
    let mut version_directive_copy: *mut yaml_version_directive_t =
        0 as *mut yaml_version_directive_t;
    let mut tag_directives_copy: C2RustUnnamed_26 = {
        let mut init = C2RustUnnamed_26 {
            start: 0 as *mut yaml_tag_directive_t,
            end: 0 as *mut yaml_tag_directive_t,
            top: 0 as *mut yaml_tag_directive_t,
        };
        init
    };
    let mut value: yaml_tag_directive_t = {
        let mut init = yaml_tag_directive_s {
            handle: 0 as *mut yaml_char_t,
            prefix: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1059 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 134],
                &[libc::c_char; 134],
            >(
                b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
            ))
                .as_ptr(),
        );
    }
    'c_6507: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1059 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 134],
                    &[libc::c_char; 134],
                >(
                    b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !tag_directives_start.is_null() && !tag_directives_end.is_null()
        || tag_directives_start == tag_directives_end
    {
    } else {
        __assert_fail(
            b"(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)\0"
                as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1061 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 134],
                &[libc::c_char; 134],
            >(
                b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
            ))
                .as_ptr(),
        );
    }
    'c_6453: {
        if !tag_directives_start.is_null() && !tag_directives_end.is_null()
            || tag_directives_start == tag_directives_end
        {
        } else {
            __assert_fail(
                b"(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)\0"
                    as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1061 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 134],
                    &[libc::c_char; 134],
                >(
                    b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    nodes.start = yaml_malloc(
        (16 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<yaml_node_t>() as libc::c_ulong),
    ) as *mut yaml_node_t;
    if !(if !(nodes.start).is_null() {
        nodes.top = nodes.start;
        nodes.end = (nodes.start).offset(16 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        context.error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if !version_directive.is_null() {
            version_directive_copy =
                yaml_malloc(::core::mem::size_of::<yaml_version_directive_t>() as libc::c_ulong)
                    as *mut yaml_version_directive_t;
            if version_directive_copy.is_null() {
                current_block = 18211063102940156569;
            } else {
                (*version_directive_copy).major = (*version_directive).major;
                (*version_directive_copy).minor = (*version_directive).minor;
                current_block = 8515828400728868193;
            }
        } else {
            current_block = 8515828400728868193;
        }
        match current_block {
            18211063102940156569 => {}
            _ => {
                if tag_directives_start != tag_directives_end {
                    let mut tag_directive: *mut yaml_tag_directive_t =
                        0 as *mut yaml_tag_directive_t;
                    tag_directives_copy.start =
                        yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                            ::core::mem::size_of::<yaml_tag_directive_t>() as libc::c_ulong,
                        )) as *mut yaml_tag_directive_t;
                    if if !(tag_directives_copy.start).is_null() {
                        tag_directives_copy.top = tag_directives_copy.start;
                        tag_directives_copy.end =
                            (tag_directives_copy.start).offset(16 as libc::c_int as isize);
                        1 as libc::c_int
                    } else {
                        context.error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0
                    {
                        current_block = 18211063102940156569;
                    } else {
                        tag_directive = tag_directives_start;
                        loop {
                            if !(tag_directive != tag_directives_end) {
                                current_block = 15089075282327824602;
                                break;
                            }
                            if !((*tag_directive).handle).is_null() {
                            } else {
                                __assert_fail(
                                    b"tag_directive->handle\0" as *const u8
                                        as *const libc::c_char,
                                    b"./api.c\0" as *const u8 as *const libc::c_char,
                                    1079 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 134],
                                        &[libc::c_char; 134],
                                    >(
                                        b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                            'c_6260: {
                                if !((*tag_directive).handle).is_null() {
                                } else {
                                    __assert_fail(
                                        b"tag_directive->handle\0" as *const u8
                                            as *const libc::c_char,
                                        b"./api.c\0" as *const u8 as *const libc::c_char,
                                        1079 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 134],
                                            &[libc::c_char; 134],
                                        >(
                                            b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                }
                            };
                            if !((*tag_directive).prefix).is_null() {
                            } else {
                                __assert_fail(
                                    b"tag_directive->prefix\0" as *const u8
                                        as *const libc::c_char,
                                    b"./api.c\0" as *const u8 as *const libc::c_char,
                                    1080 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 134],
                                        &[libc::c_char; 134],
                                    >(
                                        b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                                    ))
                                        .as_ptr(),
                                );
                            }
                            'c_6223: {
                                if !((*tag_directive).prefix).is_null() {
                                } else {
                                    __assert_fail(
                                        b"tag_directive->prefix\0" as *const u8
                                            as *const libc::c_char,
                                        b"./api.c\0" as *const u8 as *const libc::c_char,
                                        1080 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 134],
                                            &[libc::c_char; 134],
                                        >(
                                            b"int yaml_document_initialize(yaml_document_t *, yaml_version_directive_t *, yaml_tag_directive_t *, yaml_tag_directive_t *, int, int)\0",
                                        ))
                                            .as_ptr(),
                                    );
                                }
                            };
                            if yaml_check_utf8(
                                (*tag_directive).handle,
                                strlen((*tag_directive).handle as *mut libc::c_char),
                            ) == 0
                            {
                                current_block = 18211063102940156569;
                                break;
                            }
                            if yaml_check_utf8(
                                (*tag_directive).prefix,
                                strlen((*tag_directive).prefix as *mut libc::c_char),
                            ) == 0
                            {
                                current_block = 18211063102940156569;
                                break;
                            }
                            value.handle = yaml_strdup((*tag_directive).handle);
                            value.prefix = yaml_strdup((*tag_directive).prefix);
                            if (value.handle).is_null() || (value.prefix).is_null() {
                                current_block = 18211063102940156569;
                                break;
                            }
                            if if tag_directives_copy.top != tag_directives_copy.end
                                || yaml_stack_extend(
                                    &mut tag_directives_copy.start as *mut *mut yaml_tag_directive_t
                                        as *mut *mut libc::c_void,
                                    &mut tag_directives_copy.top as *mut *mut yaml_tag_directive_t
                                        as *mut *mut libc::c_void,
                                    &mut tag_directives_copy.end as *mut *mut yaml_tag_directive_t
                                        as *mut *mut libc::c_void,
                                ) != 0
                            {
                                let fresh1 = tag_directives_copy.top;
                                tag_directives_copy.top = (tag_directives_copy.top).offset(1);
                                *fresh1 = value;
                                1 as libc::c_int
                            } else {
                                context.error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                current_block = 18211063102940156569;
                                break;
                            }
                            value.handle = 0 as *mut yaml_char_t;
                            value.prefix = 0 as *mut yaml_char_t;
                            tag_directive = tag_directive.offset(1);
                            tag_directive;
                        }
                    }
                } else {
                    current_block = 15089075282327824602;
                }
                match current_block {
                    18211063102940156569 => {}
                    _ => {
                        memset(
                            document as *mut libc::c_void,
                            0 as libc::c_int,
                            ::core::mem::size_of::<yaml_document_t>() as libc::c_ulong,
                        );
                        (*document).nodes.start = nodes.start;
                        (*document).nodes.end = nodes.end;
                        (*document).nodes.top = nodes.start;
                        (*document).version_directive = version_directive_copy;
                        (*document).tag_directives.start = tag_directives_copy.start;
                        (*document).tag_directives.end = tag_directives_copy.top;
                        (*document).start_implicit = start_implicit;
                        (*document).end_implicit = end_implicit;
                        (*document).start_mark = mark;
                        (*document).end_mark = mark;
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(nodes.start as *mut libc::c_void);
    nodes.end = 0 as *mut yaml_node_t;
    nodes.top = nodes.end;
    nodes.start = nodes.top;
    yaml_free(version_directive_copy as *mut libc::c_void);
    while !(tag_directives_copy.start == tag_directives_copy.top) {
        tag_directives_copy.top = (tag_directives_copy.top).offset(-1);
        let mut value_0: yaml_tag_directive_t = *tag_directives_copy.top;
        yaml_free(value_0.handle as *mut libc::c_void);
        yaml_free(value_0.prefix as *mut libc::c_void);
    }
    yaml_free(tag_directives_copy.start as *mut libc::c_void);
    tag_directives_copy.end = 0 as *mut yaml_tag_directive_t;
    tag_directives_copy.top = tag_directives_copy.end;
    tag_directives_copy.start = tag_directives_copy.top;
    yaml_free(value.handle as *mut libc::c_void);
    yaml_free(value.prefix as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_delete(mut document: *mut yaml_document_t) {
    let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1127 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
                b"void yaml_document_delete(yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_6822: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1127 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
                    b"void yaml_document_delete(yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    while !((*document).nodes.start == (*document).nodes.top) {
        (*document).nodes.top = ((*document).nodes.top).offset(-1);
        let mut node: yaml_node_t = *(*document).nodes.top;
        yaml_free(node.tag as *mut libc::c_void);
        match node.type_0 as libc::c_uint {
            1 => {
                yaml_free(node.data.scalar.value as *mut libc::c_void);
            }
            2 => {
                yaml_free(node.data.sequence.items.start as *mut libc::c_void);
                node.data.sequence.items.end = 0 as *mut yaml_node_item_t;
                node.data.sequence.items.top = node.data.sequence.items.end;
                node.data.sequence.items.start = node.data.sequence.items.top;
            }
            3 => {
                yaml_free(node.data.mapping.pairs.start as *mut libc::c_void);
                node.data.mapping.pairs.end = 0 as *mut yaml_node_pair_t;
                node.data.mapping.pairs.top = node.data.mapping.pairs.end;
                node.data.mapping.pairs.start = node.data.mapping.pairs.top;
            }
            _ => {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"./api.c\0" as *const u8 as *const libc::c_char,
                    1143 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
                        b"void yaml_document_delete(yaml_document_t *)\0",
                    ))
                    .as_ptr(),
                );
                'c_6662: {
                    __assert_fail(
                        b"0\0" as *const u8 as *const libc::c_char,
                        b"./api.c\0" as *const u8 as *const libc::c_char,
                        1143 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<&[u8; 45], &[libc::c_char; 45]>(
                            b"void yaml_document_delete(yaml_document_t *)\0",
                        ))
                        .as_ptr(),
                    );
                };
            }
        }
    }
    yaml_free((*document).nodes.start as *mut libc::c_void);
    (*document).nodes.end = 0 as *mut yaml_node_t;
    (*document).nodes.top = (*document).nodes.end;
    (*document).nodes.start = (*document).nodes.top;
    yaml_free((*document).version_directive as *mut libc::c_void);
    tag_directive = (*document).tag_directives.start;
    while tag_directive != (*document).tag_directives.end {
        yaml_free((*tag_directive).handle as *mut libc::c_void);
        yaml_free((*tag_directive).prefix as *mut libc::c_void);
        tag_directive = tag_directive.offset(1);
        tag_directive;
    }
    yaml_free((*document).tag_directives.start as *mut libc::c_void);
    memset(
        document as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_document_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_get_node(
    mut document: *mut yaml_document_t,
    mut index: libc::c_int,
) -> *mut yaml_node_t {
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1167 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"yaml_node_t *yaml_document_get_node(yaml_document_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_6897: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1167 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"yaml_node_t *yaml_document_get_node(yaml_document_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if index > 0 as libc::c_int
        && ((*document).nodes.start).offset(index as isize) <= (*document).nodes.top
    {
        return ((*document).nodes.start)
            .offset(index as isize)
            .offset(-(1 as libc::c_int as isize));
    }
    return 0 as *mut yaml_node_t;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_get_root_node(
    mut document: *mut yaml_document_t,
) -> *mut yaml_node_t {
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1182 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"yaml_node_t *yaml_document_get_root_node(yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_6958: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1182 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"yaml_node_t *yaml_document_get_root_node(yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*document).nodes.top != (*document).nodes.start {
        return (*document).nodes.start;
    }
    return 0 as *mut yaml_node_t;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_add_scalar(
    mut document: *mut yaml_document_t,
    mut tag: *const yaml_char_t,
    mut value: *const yaml_char_t,
    mut length: libc::c_int,
    mut style: yaml_scalar_style_t,
) -> libc::c_int {
    let mut context: C2RustUnnamed_29 = C2RustUnnamed_29 {
        error: YAML_NO_ERROR,
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut value_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1207 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 116],
                &[libc::c_char; 116],
            >(
                b"int yaml_document_add_scalar(yaml_document_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_scalar_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_7356: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1207 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 116],
                    &[libc::c_char; 116],
                >(
                    b"int yaml_document_add_scalar(yaml_document_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_scalar_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !value.is_null() {
    } else {
        __assert_fail(
            b"value\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1208 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 116],
                &[libc::c_char; 116],
            >(
                b"int yaml_document_add_scalar(yaml_document_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_scalar_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_7323: {
        if !value.is_null() {
        } else {
            __assert_fail(
                b"value\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1208 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 116],
                    &[libc::c_char; 116],
                >(
                    b"int yaml_document_add_scalar(yaml_document_t *, const yaml_char_t *, const yaml_char_t *, int, yaml_scalar_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if tag.is_null() {
        tag = b"tag:yaml.org,2002:str\0" as *const u8 as *const libc::c_char as *mut yaml_char_t;
    }
    if !(yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0) {
        tag_copy = yaml_strdup(tag);
        if !tag_copy.is_null() {
            if length < 0 as libc::c_int {
                length = strlen(value as *mut libc::c_char) as libc::c_int;
            }
            if !(yaml_check_utf8(value, length as size_t) == 0) {
                value_copy = yaml_malloc((length + 1 as libc::c_int) as size_t) as *mut yaml_char_t;
                if !value_copy.is_null() {
                    memcpy(
                        value_copy as *mut libc::c_void,
                        value as *const libc::c_void,
                        length as libc::c_ulong,
                    );
                    *value_copy.offset(length as isize) = '\0' as i32 as yaml_char_t;
                    memset(
                        &mut node as *mut yaml_node_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                    );
                    node.type_0 = YAML_SCALAR_NODE;
                    node.tag = tag_copy;
                    node.start_mark = mark;
                    node.end_mark = mark;
                    node.data.scalar.value = value_copy;
                    node.data.scalar.length = length as size_t;
                    node.data.scalar.style = style;
                    if !(if (*document).nodes.top != (*document).nodes.end
                        || yaml_stack_extend(
                            &mut (*document).nodes.start as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*document).nodes.top as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*document).nodes.end as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                        ) != 0
                    {
                        let fresh2 = (*document).nodes.top;
                        (*document).nodes.top = ((*document).nodes.top).offset(1);
                        *fresh2 = node;
                        1 as libc::c_int
                    } else {
                        context.error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        return ((*document).nodes.top).offset_from((*document).nodes.start)
                            as libc::c_long as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(tag_copy as *mut libc::c_void);
    yaml_free(value_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_add_sequence(
    mut document: *mut yaml_document_t,
    mut tag: *const yaml_char_t,
    mut style: yaml_sequence_style_t,
) -> libc::c_int {
    let mut context: C2RustUnnamed_31 = C2RustUnnamed_31 {
        error: YAML_NO_ERROR,
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut items: C2RustUnnamed_30 = {
        let mut init = C2RustUnnamed_30 {
            start: 0 as *mut yaml_node_item_t,
            end: 0 as *mut yaml_node_item_t,
            top: 0 as *mut yaml_node_item_t,
        };
        init
    };
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1260 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 94],
                &[libc::c_char; 94],
            >(
                b"int yaml_document_add_sequence(yaml_document_t *, const yaml_char_t *, yaml_sequence_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_7754: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1260 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 94],
                    &[libc::c_char; 94],
                >(
                    b"int yaml_document_add_sequence(yaml_document_t *, const yaml_char_t *, yaml_sequence_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if tag.is_null() {
        tag = b"tag:yaml.org,2002:seq\0" as *const u8 as *const libc::c_char as *mut yaml_char_t;
    }
    if !(yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0) {
        tag_copy = yaml_strdup(tag);
        if !tag_copy.is_null() {
            items.start = yaml_malloc(
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<yaml_node_item_t>() as libc::c_ulong),
            ) as *mut yaml_node_item_t;
            if !(if !(items.start).is_null() {
                items.top = items.start;
                items.end = (items.start).offset(16 as libc::c_int as isize);
                1 as libc::c_int
            } else {
                context.error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                memset(
                    &mut node as *mut yaml_node_t as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                );
                node.type_0 = YAML_SEQUENCE_NODE;
                node.tag = tag_copy;
                node.start_mark = mark;
                node.end_mark = mark;
                node.data.sequence.items.start = items.start;
                node.data.sequence.items.end = items.end;
                node.data.sequence.items.top = items.start;
                node.data.sequence.style = style;
                if !(if (*document).nodes.top != (*document).nodes.end
                    || yaml_stack_extend(
                        &mut (*document).nodes.start as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*document).nodes.top as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*document).nodes.end as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                    ) != 0
                {
                    let fresh3 = (*document).nodes.top;
                    (*document).nodes.top = ((*document).nodes.top).offset(1);
                    *fresh3 = node;
                    1 as libc::c_int
                } else {
                    context.error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    return ((*document).nodes.top).offset_from((*document).nodes.start)
                        as libc::c_long as libc::c_int;
                }
            }
        }
    }
    yaml_free(items.start as *mut libc::c_void);
    items.end = 0 as *mut yaml_node_item_t;
    items.top = items.end;
    items.start = items.top;
    yaml_free(tag_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_add_mapping(
    mut document: *mut yaml_document_t,
    mut tag: *const yaml_char_t,
    mut style: yaml_mapping_style_t,
) -> libc::c_int {
    let mut context: C2RustUnnamed_33 = C2RustUnnamed_33 {
        error: YAML_NO_ERROR,
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut tag_copy: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut pairs: C2RustUnnamed_32 = {
        let mut init = C2RustUnnamed_32 {
            start: 0 as *mut yaml_node_pair_t,
            end: 0 as *mut yaml_node_pair_t,
            top: 0 as *mut yaml_node_pair_t,
        };
        init
    };
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1305 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 92],
                &[libc::c_char; 92],
            >(
                b"int yaml_document_add_mapping(yaml_document_t *, const yaml_char_t *, yaml_mapping_style_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_8153: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1305 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 92],
                    &[libc::c_char; 92],
                >(
                    b"int yaml_document_add_mapping(yaml_document_t *, const yaml_char_t *, yaml_mapping_style_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if tag.is_null() {
        tag = b"tag:yaml.org,2002:map\0" as *const u8 as *const libc::c_char as *mut yaml_char_t;
    }
    if !(yaml_check_utf8(tag, strlen(tag as *mut libc::c_char)) == 0) {
        tag_copy = yaml_strdup(tag);
        if !tag_copy.is_null() {
            pairs.start = yaml_malloc(
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<yaml_node_pair_t>() as libc::c_ulong),
            ) as *mut yaml_node_pair_t;
            if !(if !(pairs.start).is_null() {
                pairs.top = pairs.start;
                pairs.end = (pairs.start).offset(16 as libc::c_int as isize);
                1 as libc::c_int
            } else {
                context.error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                memset(
                    &mut node as *mut yaml_node_t as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                );
                node.type_0 = YAML_MAPPING_NODE;
                node.tag = tag_copy;
                node.start_mark = mark;
                node.end_mark = mark;
                node.data.mapping.pairs.start = pairs.start;
                node.data.mapping.pairs.end = pairs.end;
                node.data.mapping.pairs.top = pairs.start;
                node.data.mapping.style = style;
                if !(if (*document).nodes.top != (*document).nodes.end
                    || yaml_stack_extend(
                        &mut (*document).nodes.start as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*document).nodes.top as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*document).nodes.end as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                    ) != 0
                {
                    let fresh4 = (*document).nodes.top;
                    (*document).nodes.top = ((*document).nodes.top).offset(1);
                    *fresh4 = node;
                    1 as libc::c_int
                } else {
                    context.error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    return ((*document).nodes.top).offset_from((*document).nodes.start)
                        as libc::c_long as libc::c_int;
                }
            }
        }
    }
    yaml_free(pairs.start as *mut libc::c_void);
    pairs.end = 0 as *mut yaml_node_pair_t;
    pairs.top = pairs.end;
    pairs.start = pairs.top;
    yaml_free(tag_copy as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_append_sequence_item(
    mut document: *mut yaml_document_t,
    mut sequence: libc::c_int,
    mut item: libc::c_int,
) -> libc::c_int {
    let mut context: C2RustUnnamed_34 = C2RustUnnamed_34 {
        error: YAML_NO_ERROR,
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1342 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8530: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1342 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                    b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if sequence > 0 as libc::c_int
        && ((*document).nodes.start).offset(sequence as isize) <= (*document).nodes.top
    {
    } else {
        __assert_fail(
            b"sequence > 0 && document->nodes.start + sequence <= document->nodes.top\0"
                as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1344 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8464: {
        if sequence > 0 as libc::c_int
            && ((*document).nodes.start).offset(sequence as isize) <= (*document).nodes.top
        {
        } else {
            __assert_fail(
                b"sequence > 0 && document->nodes.start + sequence <= document->nodes.top\0"
                    as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1344 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                    b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize)).type_0
        as libc::c_uint
        == YAML_SEQUENCE_NODE as libc::c_int as libc::c_uint
    {
    } else {
        __assert_fail(
            b"document->nodes.start[sequence-1].type == YAML_SEQUENCE_NODE\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1346 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8403: {
        if (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize)).type_0
            as libc::c_uint
            == YAML_SEQUENCE_NODE as libc::c_int as libc::c_uint
        {
        } else {
            __assert_fail(
                b"document->nodes.start[sequence-1].type == YAML_SEQUENCE_NODE\0" as *const u8
                    as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1346 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                    b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if item > 0 as libc::c_int
        && ((*document).nodes.start).offset(item as isize) <= (*document).nodes.top
    {
    } else {
        __assert_fail(
            b"item > 0 && document->nodes.start + item <= document->nodes.top\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1348 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8335: {
        if item > 0 as libc::c_int
            && ((*document).nodes.start).offset(item as isize) <= (*document).nodes.top
        {
        } else {
            __assert_fail(
                b"item > 0 && document->nodes.start + item <= document->nodes.top\0" as *const u8
                    as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1348 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 68], &[libc::c_char; 68]>(
                    b"int yaml_document_append_sequence_item(yaml_document_t *, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if if (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize))
        .data
        .sequence
        .items
        .top
        != (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize))
            .data
            .sequence
            .items
            .end
        || yaml_stack_extend(
            &mut (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize))
                .data
                .sequence
                .items
                .start as *mut *mut yaml_node_item_t as *mut *mut libc::c_void,
            &mut (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize))
                .data
                .sequence
                .items
                .top as *mut *mut yaml_node_item_t as *mut *mut libc::c_void,
            &mut (*((*document).nodes.start).offset((sequence - 1 as libc::c_int) as isize))
                .data
                .sequence
                .items
                .end as *mut *mut yaml_node_item_t as *mut *mut libc::c_void,
        ) != 0
    {
        let ref mut fresh5 = (*((*document).nodes.start)
            .offset((sequence - 1 as libc::c_int) as isize))
        .data
        .sequence
        .items
        .top;
        let fresh6 = *fresh5;
        *fresh5 = (*fresh5).offset(1);
        *fresh6 = item;
        1 as libc::c_int
    } else {
        context.error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_document_append_mapping_pair(
    mut document: *mut yaml_document_t,
    mut mapping: libc::c_int,
    mut key: libc::c_int,
    mut value: libc::c_int,
) -> libc::c_int {
    let mut context: C2RustUnnamed_35 = C2RustUnnamed_35 {
        error: YAML_NO_ERROR,
    };
    let mut pair: yaml_node_pair_t = yaml_node_pair_t { key: 0, value: 0 };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1372 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8989: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1372 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if mapping > 0 as libc::c_int
        && ((*document).nodes.start).offset(mapping as isize) <= (*document).nodes.top
    {
    } else {
        __assert_fail(
            b"mapping > 0 && document->nodes.start + mapping <= document->nodes.top\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1374 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8922: {
        if mapping > 0 as libc::c_int
            && ((*document).nodes.start).offset(mapping as isize) <= (*document).nodes.top
        {
        } else {
            __assert_fail(
                b"mapping > 0 && document->nodes.start + mapping <= document->nodes.top\0"
                    as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1374 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize)).type_0
        as libc::c_uint
        == YAML_MAPPING_NODE as libc::c_int as libc::c_uint
    {
    } else {
        __assert_fail(
            b"document->nodes.start[mapping-1].type == YAML_MAPPING_NODE\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1376 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8861: {
        if (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize)).type_0
            as libc::c_uint
            == YAML_MAPPING_NODE as libc::c_int as libc::c_uint
        {
        } else {
            __assert_fail(
                b"document->nodes.start[mapping-1].type == YAML_MAPPING_NODE\0" as *const u8
                    as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1376 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if key > 0 as libc::c_int
        && ((*document).nodes.start).offset(key as isize) <= (*document).nodes.top
    {
    } else {
        __assert_fail(
            b"key > 0 && document->nodes.start + key <= document->nodes.top\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1378 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8794: {
        if key > 0 as libc::c_int
            && ((*document).nodes.start).offset(key as isize) <= (*document).nodes.top
        {
        } else {
            __assert_fail(
                b"key > 0 && document->nodes.start + key <= document->nodes.top\0" as *const u8
                    as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1378 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if value > 0 as libc::c_int
        && ((*document).nodes.start).offset(value as isize) <= (*document).nodes.top
    {
    } else {
        __assert_fail(
            b"value > 0 && document->nodes.start + value <= document->nodes.top\0" as *const u8
                as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            1380 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_8727: {
        if value > 0 as libc::c_int
            && ((*document).nodes.start).offset(value as isize) <= (*document).nodes.top
        {
        } else {
            __assert_fail(
                b"value > 0 && document->nodes.start + value <= document->nodes.top\0" as *const u8
                    as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                1380 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_document_append_mapping_pair(yaml_document_t *, int, int, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    pair.key = key;
    pair.value = value;
    if if (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize))
        .data
        .mapping
        .pairs
        .top
        != (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize))
            .data
            .mapping
            .pairs
            .end
        || yaml_stack_extend(
            &mut (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize))
                .data
                .mapping
                .pairs
                .start as *mut *mut yaml_node_pair_t as *mut *mut libc::c_void,
            &mut (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize))
                .data
                .mapping
                .pairs
                .top as *mut *mut yaml_node_pair_t as *mut *mut libc::c_void,
            &mut (*((*document).nodes.start).offset((mapping - 1 as libc::c_int) as isize))
                .data
                .mapping
                .pairs
                .end as *mut *mut yaml_node_pair_t as *mut *mut libc::c_void,
        ) != 0
    {
        let ref mut fresh7 = (*((*document).nodes.start)
            .offset((mapping - 1 as libc::c_int) as isize))
        .data
        .mapping
        .pairs
        .top;
        let fresh8 = *fresh7;
        *fresh7 = (*fresh7).offset(1);
        *fresh8 = pair;
        1 as libc::c_int
    } else {
        context.error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_initialize(mut parser: *mut yaml_parser_t) -> libc::c_int {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            179 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 44], &[libc::c_char; 44]>(
                b"int yaml_parser_initialize(yaml_parser_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10026: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                179 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 44], &[libc::c_char; 44]>(
                    b"int yaml_parser_initialize(yaml_parser_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        parser as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_parser_t>() as libc::c_ulong,
    );
    (*parser).raw_buffer.start = yaml_malloc(16384 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !((*parser).raw_buffer.start).is_null() {
        (*parser).raw_buffer.pointer = (*parser).raw_buffer.start;
        (*parser).raw_buffer.last = (*parser).raw_buffer.pointer;
        (*parser).raw_buffer.end =
            ((*parser).raw_buffer.start).offset(16384 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        (*parser).buffer.start =
            yaml_malloc((16384 as libc::c_int * 3 as libc::c_int) as size_t) as *mut yaml_char_t;
        if !(if !((*parser).buffer.start).is_null() {
            (*parser).buffer.pointer = (*parser).buffer.start;
            (*parser).buffer.last = (*parser).buffer.pointer;
            (*parser).buffer.end =
                ((*parser).buffer.start).offset((16384 as libc::c_int * 3 as libc::c_int) as isize);
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0)
        {
            (*parser).tokens.start = yaml_malloc(
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<yaml_token_t>() as libc::c_ulong),
            ) as *mut yaml_token_t;
            if !(if !((*parser).tokens.start).is_null() {
                (*parser).tokens.tail = (*parser).tokens.start;
                (*parser).tokens.head = (*parser).tokens.tail;
                (*parser).tokens.end = ((*parser).tokens.start).offset(16 as libc::c_int as isize);
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                (*parser).indents.start = yaml_malloc(
                    (16 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
                ) as *mut libc::c_int;
                if !(if !((*parser).indents.start).is_null() {
                    (*parser).indents.top = (*parser).indents.start;
                    (*parser).indents.end =
                        ((*parser).indents.start).offset(16 as libc::c_int as isize);
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    (*parser).simple_keys.start =
                        yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                            ::core::mem::size_of::<yaml_simple_key_t>() as libc::c_ulong,
                        )) as *mut yaml_simple_key_t;
                    if !(if !((*parser).simple_keys.start).is_null() {
                        (*parser).simple_keys.top = (*parser).simple_keys.start;
                        (*parser).simple_keys.end =
                            ((*parser).simple_keys.start).offset(16 as libc::c_int as isize);
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        (*parser).states.start =
                            yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                                ::core::mem::size_of::<yaml_parser_state_t>() as libc::c_ulong,
                            )) as *mut yaml_parser_state_t;
                        if !(if !((*parser).states.start).is_null() {
                            (*parser).states.top = (*parser).states.start;
                            (*parser).states.end =
                                ((*parser).states.start).offset(16 as libc::c_int as isize);
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0)
                        {
                            (*parser).marks.start =
                                yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                                    ::core::mem::size_of::<yaml_mark_t>() as libc::c_ulong,
                                )) as *mut yaml_mark_t;
                            if !(if !((*parser).marks.start).is_null() {
                                (*parser).marks.top = (*parser).marks.start;
                                (*parser).marks.end =
                                    ((*parser).marks.start).offset(16 as libc::c_int as isize);
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0)
                            {
                                (*parser).tag_directives.start =
                                    yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                                        ::core::mem::size_of::<yaml_tag_directive_t>()
                                            as libc::c_ulong,
                                    ))
                                        as *mut yaml_tag_directive_t;
                                if !(if !((*parser).tag_directives.start).is_null() {
                                    (*parser).tag_directives.top = (*parser).tag_directives.start;
                                    (*parser).tag_directives.end = ((*parser).tag_directives.start)
                                        .offset(16 as libc::c_int as isize);
                                    1 as libc::c_int
                                } else {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    0 as libc::c_int
                                } == 0)
                                {
                                    return 1 as libc::c_int;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    yaml_free((*parser).raw_buffer.start as *mut libc::c_void);
    (*parser).raw_buffer.end = 0 as *mut libc::c_uchar;
    (*parser).raw_buffer.pointer = (*parser).raw_buffer.end;
    (*parser).raw_buffer.start = (*parser).raw_buffer.pointer;
    yaml_free((*parser).buffer.start as *mut libc::c_void);
    (*parser).buffer.end = 0 as *mut yaml_char_t;
    (*parser).buffer.pointer = (*parser).buffer.end;
    (*parser).buffer.start = (*parser).buffer.pointer;
    yaml_free((*parser).tokens.start as *mut libc::c_void);
    (*parser).tokens.end = 0 as *mut yaml_token_t;
    (*parser).tokens.tail = (*parser).tokens.end;
    (*parser).tokens.head = (*parser).tokens.tail;
    (*parser).tokens.start = (*parser).tokens.head;
    yaml_free((*parser).indents.start as *mut libc::c_void);
    (*parser).indents.end = 0 as *mut libc::c_int;
    (*parser).indents.top = (*parser).indents.end;
    (*parser).indents.start = (*parser).indents.top;
    yaml_free((*parser).simple_keys.start as *mut libc::c_void);
    (*parser).simple_keys.end = 0 as *mut yaml_simple_key_t;
    (*parser).simple_keys.top = (*parser).simple_keys.end;
    (*parser).simple_keys.start = (*parser).simple_keys.top;
    yaml_free((*parser).states.start as *mut libc::c_void);
    (*parser).states.end = 0 as *mut yaml_parser_state_t;
    (*parser).states.top = (*parser).states.end;
    (*parser).states.start = (*parser).states.top;
    yaml_free((*parser).marks.start as *mut libc::c_void);
    (*parser).marks.end = 0 as *mut yaml_mark_t;
    (*parser).marks.top = (*parser).marks.end;
    (*parser).marks.start = (*parser).marks.top;
    yaml_free((*parser).tag_directives.start as *mut libc::c_void);
    (*parser).tag_directives.end = 0 as *mut yaml_tag_directive_t;
    (*parser).tag_directives.top = (*parser).tag_directives.end;
    (*parser).tag_directives.start = (*parser).tag_directives.top;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_delete(mut parser: *mut yaml_parser_t) {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            222 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"void yaml_parser_delete(yaml_parser_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10422: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                222 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"void yaml_parser_delete(yaml_parser_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    yaml_free((*parser).raw_buffer.start as *mut libc::c_void);
    (*parser).raw_buffer.end = 0 as *mut libc::c_uchar;
    (*parser).raw_buffer.pointer = (*parser).raw_buffer.end;
    (*parser).raw_buffer.start = (*parser).raw_buffer.pointer;
    yaml_free((*parser).buffer.start as *mut libc::c_void);
    (*parser).buffer.end = 0 as *mut yaml_char_t;
    (*parser).buffer.pointer = (*parser).buffer.end;
    (*parser).buffer.start = (*parser).buffer.pointer;
    while !((*parser).tokens.head == (*parser).tokens.tail) {
        let fresh9 = (*parser).tokens.head;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        yaml_token_delete(fresh9);
    }
    yaml_free((*parser).tokens.start as *mut libc::c_void);
    (*parser).tokens.end = 0 as *mut yaml_token_t;
    (*parser).tokens.tail = (*parser).tokens.end;
    (*parser).tokens.head = (*parser).tokens.tail;
    (*parser).tokens.start = (*parser).tokens.head;
    yaml_free((*parser).indents.start as *mut libc::c_void);
    (*parser).indents.end = 0 as *mut libc::c_int;
    (*parser).indents.top = (*parser).indents.end;
    (*parser).indents.start = (*parser).indents.top;
    yaml_free((*parser).simple_keys.start as *mut libc::c_void);
    (*parser).simple_keys.end = 0 as *mut yaml_simple_key_t;
    (*parser).simple_keys.top = (*parser).simple_keys.end;
    (*parser).simple_keys.start = (*parser).simple_keys.top;
    yaml_free((*parser).states.start as *mut libc::c_void);
    (*parser).states.end = 0 as *mut yaml_parser_state_t;
    (*parser).states.top = (*parser).states.end;
    (*parser).states.start = (*parser).states.top;
    yaml_free((*parser).marks.start as *mut libc::c_void);
    (*parser).marks.end = 0 as *mut yaml_mark_t;
    (*parser).marks.top = (*parser).marks.end;
    (*parser).marks.start = (*parser).marks.top;
    while !((*parser).tag_directives.start == (*parser).tag_directives.top) {
        (*parser).tag_directives.top = ((*parser).tag_directives.top).offset(-1);
        let mut tag_directive: yaml_tag_directive_t = *(*parser).tag_directives.top;
        yaml_free(tag_directive.handle as *mut libc::c_void);
        yaml_free(tag_directive.prefix as *mut libc::c_void);
    }
    yaml_free((*parser).tag_directives.start as *mut libc::c_void);
    (*parser).tag_directives.end = 0 as *mut yaml_tag_directive_t;
    (*parser).tag_directives.top = (*parser).tag_directives.end;
    (*parser).tag_directives.start = (*parser).tag_directives.top;
    memset(
        parser as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_parser_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_set_input_string(
    mut parser: *mut yaml_parser_t,
    mut input: *const libc::c_uchar,
    mut size: size_t,
) {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            292 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 82],
                &[libc::c_char; 82],
            >(
                b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_10687: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                292 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 82],
                    &[libc::c_char; 82],
                >(
                    b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*parser).read_handler).is_none() {
    } else {
        __assert_fail(
            b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            293 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 82],
                &[libc::c_char; 82],
            >(
                b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_10649: {
        if ((*parser).read_handler).is_none() {
        } else {
            __assert_fail(
                b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                293 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 82],
                    &[libc::c_char; 82],
                >(
                    b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !input.is_null() {
    } else {
        __assert_fail(
            b"input\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            294 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 82],
                &[libc::c_char; 82],
            >(
                b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
            ))
                .as_ptr(),
        );
    }
    'c_10616: {
        if !input.is_null() {
        } else {
            __assert_fail(
                b"input\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                294 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 82],
                    &[libc::c_char; 82],
                >(
                    b"void yaml_parser_set_input_string(yaml_parser_t *, const unsigned char *, size_t)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    (*parser).read_handler = Some(
        yaml_string_read_handler
            as unsafe extern "C" fn(
                *mut libc::c_void,
                *mut libc::c_uchar,
                size_t,
                *mut size_t,
            ) -> libc::c_int,
    );
    (*parser).read_handler_data = parser as *mut libc::c_void;
    (*parser).input.string.start = input;
    (*parser).input.string.current = input;
    (*parser).input.string.end = input.offset(size as isize);
}
unsafe extern "C" fn yaml_string_read_handler(
    mut data: *mut libc::c_void,
    mut buffer: *mut libc::c_uchar,
    mut size: size_t,
    mut size_read: *mut size_t,
) -> libc::c_int {
    let mut parser: *mut yaml_parser_t = data as *mut yaml_parser_t;
    if (*parser).input.string.current == (*parser).input.string.end {
        *size_read = 0 as libc::c_int as size_t;
        return 1 as libc::c_int;
    }
    if size
        > ((*parser).input.string.end).offset_from((*parser).input.string.current) as libc::c_long
            as size_t
    {
        size = ((*parser).input.string.end).offset_from((*parser).input.string.current)
            as libc::c_long as size_t;
    }
    memcpy(
        buffer as *mut libc::c_void,
        (*parser).input.string.current as *const libc::c_void,
        size,
    );
    (*parser).input.string.current = ((*parser).input.string.current).offset(size as isize);
    *size_read = size;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_set_input_file(
    mut parser: *mut yaml_parser_t,
    mut file: *mut FILE,
) {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            311 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10864: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                311 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                    b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if ((*parser).read_handler).is_none() {
    } else {
        __assert_fail(
            b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            312 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10826: {
        if ((*parser).read_handler).is_none() {
        } else {
            __assert_fail(
                b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                312 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                    b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !file.is_null() {
    } else {
        __assert_fail(
            b"file\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            313 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10792: {
        if !file.is_null() {
        } else {
            __assert_fail(
                b"file\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                313 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                    b"void yaml_parser_set_input_file(yaml_parser_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*parser).read_handler = Some(
        yaml_file_read_handler
            as unsafe extern "C" fn(
                *mut libc::c_void,
                *mut libc::c_uchar,
                size_t,
                *mut size_t,
            ) -> libc::c_int,
    );
    (*parser).read_handler_data = parser as *mut libc::c_void;
    (*parser).input.file = file;
}
unsafe extern "C" fn yaml_file_read_handler(
    mut data: *mut libc::c_void,
    mut buffer: *mut libc::c_uchar,
    mut size: size_t,
    mut size_read: *mut size_t,
) -> libc::c_int {
    let mut parser: *mut yaml_parser_t = data as *mut yaml_parser_t;
    *size_read = fread(
        buffer as *mut libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        size,
        (*parser).input.file,
    );
    return (ferror((*parser).input.file) == 0) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_set_input(
    mut parser: *mut yaml_parser_t,
    mut handler: Option<yaml_read_handler_t>,
    mut data: *mut libc::c_void,
) {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            329 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10990: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                329 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                    b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if ((*parser).read_handler).is_none() {
    } else {
        __assert_fail(
            b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            330 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10952: {
        if ((*parser).read_handler).is_none() {
        } else {
            __assert_fail(
                b"!parser->read_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                330 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                    b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if handler.is_some() {
    } else {
        __assert_fail(
            b"handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            331 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_10919: {
        if handler.is_some() {
        } else {
            __assert_fail(
                b"handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                331 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 75], &[libc::c_char; 75]>(
                    b"void yaml_parser_set_input(yaml_parser_t *, yaml_read_handler_t *, void *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*parser).read_handler = handler;
    (*parser).read_handler_data = data;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_set_encoding(
    mut parser: *mut yaml_parser_t,
    mut encoding: yaml_encoding_t,
) {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            344 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 64], &[libc::c_char; 64]>(
                b"void yaml_parser_set_encoding(yaml_parser_t *, yaml_encoding_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_11075: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                344 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 64], &[libc::c_char; 64]>(
                    b"void yaml_parser_set_encoding(yaml_parser_t *, yaml_encoding_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*parser).encoding as u64 == 0 {
    } else {
        __assert_fail(
            b"!parser->encoding\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            345 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 64], &[libc::c_char; 64]>(
                b"void yaml_parser_set_encoding(yaml_parser_t *, yaml_encoding_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_11036: {
        if (*parser).encoding as u64 == 0 {
        } else {
            __assert_fail(
                b"!parser->encoding\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                345 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 64], &[libc::c_char; 64]>(
                    b"void yaml_parser_set_encoding(yaml_parser_t *, yaml_encoding_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*parser).encoding = encoding;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_queue_extend(
    mut start: *mut *mut libc::c_void,
    mut head: *mut *mut libc::c_void,
    mut tail: *mut *mut libc::c_void,
    mut end: *mut *mut libc::c_void,
) -> libc::c_int {
    if *start == *head && *tail == *end {
        let mut new_start: *mut libc::c_void = yaml_realloc(
            *start,
            ((*end as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
                * 2 as libc::c_int as libc::c_long) as size_t,
        );
        if new_start.is_null() {
            return 0 as libc::c_int;
        }
        *head = (new_start as *mut libc::c_char).offset(
            (*head as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
                as isize,
        ) as *mut libc::c_void;
        *tail = (new_start as *mut libc::c_char).offset(
            (*tail as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
                as isize,
        ) as *mut libc::c_void;
        *end = (new_start as *mut libc::c_char).offset(
            ((*end as *mut libc::c_char).offset_from(*start as *mut libc::c_char) as libc::c_long
                * 2 as libc::c_int as libc::c_long) as isize,
        ) as *mut libc::c_void;
        *start = new_start;
    }
    if *tail == *end {
        if *head != *tail {
            memmove(
                *start,
                *head,
                (*tail as *mut libc::c_char).offset_from(*head as *mut libc::c_char) as libc::c_long
                    as libc::c_ulong,
            );
        }
        *tail = (*start as *mut libc::c_char).offset(
            (*tail as *mut libc::c_char).offset_from(*head as *mut libc::c_char) as libc::c_long
                as isize,
        ) as *mut libc::c_void;
        *head = *start;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_string_extend(
    mut start: *mut *mut yaml_char_t,
    mut pointer: *mut *mut yaml_char_t,
    mut end: *mut *mut yaml_char_t,
) -> libc::c_int {
    let mut new_start: *mut yaml_char_t = yaml_realloc(
        *start as *mut libc::c_void,
        ((*end).offset_from(*start) as libc::c_long * 2 as libc::c_int as libc::c_long) as size_t,
    ) as *mut yaml_char_t;
    if new_start.is_null() {
        return 0 as libc::c_int;
    }
    memset(
        new_start.offset((*end).offset_from(*start) as libc::c_long as isize) as *mut libc::c_void,
        0 as libc::c_int,
        (*end).offset_from(*start) as libc::c_long as libc::c_ulong,
    );
    *pointer = new_start.offset((*pointer).offset_from(*start) as libc::c_long as isize);
    *end = new_start.offset(
        ((*end).offset_from(*start) as libc::c_long * 2 as libc::c_int as libc::c_long) as isize,
    );
    *start = new_start;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_string_join(
    mut a_start: *mut *mut yaml_char_t,
    mut a_pointer: *mut *mut yaml_char_t,
    mut a_end: *mut *mut yaml_char_t,
    mut b_start: *mut *mut yaml_char_t,
    mut b_pointer: *mut *mut yaml_char_t,
    mut b_end: *mut *mut yaml_char_t,
) -> libc::c_int {
    if *b_start == *b_pointer {
        return 1 as libc::c_int;
    }
    while (*a_end).offset_from(*a_pointer) as libc::c_long
        <= (*b_pointer).offset_from(*b_start) as libc::c_long
    {
        if yaml_string_extend(a_start, a_pointer, a_end) == 0 {
            return 0 as libc::c_int;
        }
    }
    memcpy(
        *a_pointer as *mut libc::c_void,
        *b_start as *const libc::c_void,
        (*b_pointer).offset_from(*b_start) as libc::c_long as libc::c_ulong,
    );
    *a_pointer = (*a_pointer).offset((*b_pointer).offset_from(*b_start) as libc::c_long as isize);
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_break(
    mut emitter: *mut yaml_emitter_t,
    mut line_break: yaml_break_t,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            574 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"void yaml_emitter_set_break(yaml_emitter_t *, yaml_break_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64774: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                574 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"void yaml_emitter_set_break(yaml_emitter_t *, yaml_break_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).line_break = line_break;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_unicode(
    mut emitter: *mut yaml_emitter_t,
    mut unicode: libc::c_int,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            562 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 53], &[libc::c_char; 53]>(
                b"void yaml_emitter_set_unicode(yaml_emitter_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64729: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                562 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 53], &[libc::c_char; 53]>(
                    b"void yaml_emitter_set_unicode(yaml_emitter_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).unicode = (unicode != 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_width(
    mut emitter: *mut yaml_emitter_t,
    mut width: libc::c_int,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            550 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 51], &[libc::c_char; 51]>(
                b"void yaml_emitter_set_width(yaml_emitter_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64681: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                550 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 51], &[libc::c_char; 51]>(
                    b"void yaml_emitter_set_width(yaml_emitter_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).best_width = if width >= 0 as libc::c_int {
        width
    } else {
        -(1 as libc::c_int)
    };
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_indent(
    mut emitter: *mut yaml_emitter_t,
    mut indent: libc::c_int,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            538 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 52], &[libc::c_char; 52]>(
                b"void yaml_emitter_set_indent(yaml_emitter_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64628: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                538 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 52], &[libc::c_char; 52]>(
                    b"void yaml_emitter_set_indent(yaml_emitter_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).best_indent = if (1 as libc::c_int) < indent && indent < 10 as libc::c_int {
        indent
    } else {
        2 as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_canonical(
    mut emitter: *mut yaml_emitter_t,
    mut canonical: libc::c_int,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            526 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                b"void yaml_emitter_set_canonical(yaml_emitter_t *, int)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64572: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                526 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                    b"void yaml_emitter_set_canonical(yaml_emitter_t *, int)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).canonical = (canonical != 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_encoding(
    mut emitter: *mut yaml_emitter_t,
    mut encoding: yaml_encoding_t,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            513 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
                b"void yaml_emitter_set_encoding(yaml_emitter_t *, yaml_encoding_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64524: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                513 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
                    b"void yaml_emitter_set_encoding(yaml_emitter_t *, yaml_encoding_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*emitter).encoding as u64 == 0 {
    } else {
        __assert_fail(
            b"!emitter->encoding\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            514 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
                b"void yaml_emitter_set_encoding(yaml_emitter_t *, yaml_encoding_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64486: {
        if (*emitter).encoding as u64 == 0 {
        } else {
            __assert_fail(
                b"!emitter->encoding\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                514 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 66], &[libc::c_char; 66]>(
                    b"void yaml_emitter_set_encoding(yaml_emitter_t *, yaml_encoding_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).encoding = encoding;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_output(
    mut emitter: *mut yaml_emitter_t,
    mut handler: Option<yaml_write_handler_t>,
    mut data: *mut libc::c_void,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            498 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 79], &[libc::c_char; 79]>(
                b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64440: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                498 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 79],
                    &[libc::c_char; 79],
                >(
                    b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*emitter).write_handler).is_none() {
    } else {
        __assert_fail(
            b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            499 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 79], &[libc::c_char; 79]>(
                b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64402: {
        if ((*emitter).write_handler).is_none() {
        } else {
            __assert_fail(
                b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                499 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 79],
                    &[libc::c_char; 79],
                >(
                    b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if handler.is_some() {
    } else {
        __assert_fail(
            b"handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            500 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 79], &[libc::c_char; 79]>(
                b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64369: {
        if handler.is_some() {
        } else {
            __assert_fail(
                b"handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                500 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 79],
                    &[libc::c_char; 79],
                >(
                    b"void yaml_emitter_set_output(yaml_emitter_t *, yaml_write_handler_t *, void *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    (*emitter).write_handler = handler;
    (*emitter).write_handler_data = data;
}
unsafe extern "C" fn yaml_file_write_handler(
    mut data: *mut libc::c_void,
    mut buffer: *mut libc::c_uchar,
    mut size: size_t,
) -> libc::c_int {
    let mut emitter: *mut yaml_emitter_t = data as *mut yaml_emitter_t;
    return (fwrite(
        buffer as *const libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        size,
        (*emitter).output.file,
    ) == size) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_output_file(
    mut emitter: *mut yaml_emitter_t,
    mut file: *mut FILE,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            480 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64314: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                480 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if ((*emitter).write_handler).is_none() {
    } else {
        __assert_fail(
            b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            481 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64276: {
        if ((*emitter).write_handler).is_none() {
        } else {
            __assert_fail(
                b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                481 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !file.is_null() {
    } else {
        __assert_fail(
            b"file\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            482 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_64244: {
        if !file.is_null() {
        } else {
            __assert_fail(
                b"file\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                482 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 60], &[libc::c_char; 60]>(
                    b"void yaml_emitter_set_output_file(yaml_emitter_t *, FILE *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).write_handler = Some(
        yaml_file_write_handler
            as unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_uchar, size_t) -> libc::c_int,
    );
    (*emitter).write_handler_data = emitter as *mut libc::c_void;
    (*emitter).output.file = file;
}
unsafe extern "C" fn yaml_string_write_handler(
    mut data: *mut libc::c_void,
    mut buffer: *mut libc::c_uchar,
    mut size: size_t,
) -> libc::c_int {
    let mut emitter: *mut yaml_emitter_t = data as *mut yaml_emitter_t;
    if ((*emitter).output.string.size).wrapping_sub(*(*emitter).output.string.size_written) < size {
        memcpy(
            ((*emitter).output.string.buffer)
                .offset(*(*emitter).output.string.size_written as isize)
                as *mut libc::c_void,
            buffer as *const libc::c_void,
            ((*emitter).output.string.size).wrapping_sub(*(*emitter).output.string.size_written),
        );
        *(*emitter).output.string.size_written = (*emitter).output.string.size;
        return 0 as libc::c_int;
    }
    memcpy(
        ((*emitter).output.string.buffer).offset(*(*emitter).output.string.size_written as isize)
            as *mut libc::c_void,
        buffer as *const libc::c_void,
        size,
    );
    *(*emitter).output.string.size_written = (*(*emitter).output.string.size_written
        as libc::c_ulong)
        .wrapping_add(size) as size_t as size_t;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_set_output_string(
    mut emitter: *mut yaml_emitter_t,
    mut output: *mut libc::c_uchar,
    mut size: size_t,
    mut size_written: *mut size_t,
) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            460 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 89],
                &[libc::c_char; 89],
            >(
                b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_64150: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                460 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 89],
                    &[libc::c_char; 89],
                >(
                    b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*emitter).write_handler).is_none() {
    } else {
        __assert_fail(
            b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            461 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 89],
                &[libc::c_char; 89],
            >(
                b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_64112: {
        if ((*emitter).write_handler).is_none() {
        } else {
            __assert_fail(
                b"!emitter->write_handler\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                461 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 89],
                    &[libc::c_char; 89],
                >(
                    b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if !output.is_null() {
    } else {
        __assert_fail(
            b"output\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            462 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 89],
                &[libc::c_char; 89],
            >(
                b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_64079: {
        if !output.is_null() {
        } else {
            __assert_fail(
                b"output\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                462 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 89],
                    &[libc::c_char; 89],
                >(
                    b"void yaml_emitter_set_output_string(yaml_emitter_t *, unsigned char *, size_t, size_t *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    (*emitter).write_handler = Some(
        yaml_string_write_handler
            as unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_uchar, size_t) -> libc::c_int,
    );
    (*emitter).write_handler_data = emitter as *mut libc::c_void;
    (*emitter).output.string.buffer = output;
    (*emitter).output.string.size = size;
    (*emitter).output.string.size_written = size_written;
    *size_written = 0 as libc::c_int as size_t;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_delete(mut emitter: *mut yaml_emitter_t) {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            394 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 43], &[libc::c_char; 43]>(
                b"void yaml_emitter_delete(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_63863: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                394 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 43], &[libc::c_char; 43]>(
                    b"void yaml_emitter_delete(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    yaml_free((*emitter).buffer.start as *mut libc::c_void);
    (*emitter).buffer.end = 0 as *mut yaml_char_t;
    (*emitter).buffer.pointer = (*emitter).buffer.end;
    (*emitter).buffer.start = (*emitter).buffer.pointer;
    yaml_free((*emitter).raw_buffer.start as *mut libc::c_void);
    (*emitter).raw_buffer.end = 0 as *mut libc::c_uchar;
    (*emitter).raw_buffer.pointer = (*emitter).raw_buffer.end;
    (*emitter).raw_buffer.start = (*emitter).raw_buffer.pointer;
    yaml_free((*emitter).states.start as *mut libc::c_void);
    (*emitter).states.end = 0 as *mut yaml_emitter_state_t;
    (*emitter).states.top = (*emitter).states.end;
    (*emitter).states.start = (*emitter).states.top;
    while !((*emitter).events.head == (*emitter).events.tail) {
        let fresh10 = (*emitter).events.head;
        (*emitter).events.head = ((*emitter).events.head).offset(1);
        yaml_event_delete(fresh10);
    }
    yaml_free((*emitter).events.start as *mut libc::c_void);
    (*emitter).events.end = 0 as *mut yaml_event_t;
    (*emitter).events.tail = (*emitter).events.end;
    (*emitter).events.head = (*emitter).events.tail;
    (*emitter).events.start = (*emitter).events.head;
    yaml_free((*emitter).indents.start as *mut libc::c_void);
    (*emitter).indents.end = 0 as *mut libc::c_int;
    (*emitter).indents.top = (*emitter).indents.end;
    (*emitter).indents.start = (*emitter).indents.top;
    while !((*emitter).tag_directives.start == (*emitter).tag_directives.top) {
        (*emitter).tag_directives.top = ((*emitter).tag_directives.top).offset(-1);
        let mut tag_directive: yaml_tag_directive_t = *(*emitter).tag_directives.top;
        yaml_free(tag_directive.handle as *mut libc::c_void);
        yaml_free(tag_directive.prefix as *mut libc::c_void);
    }
    yaml_free((*emitter).tag_directives.start as *mut libc::c_void);
    (*emitter).tag_directives.end = 0 as *mut yaml_tag_directive_t;
    (*emitter).tag_directives.top = (*emitter).tag_directives.end;
    (*emitter).tag_directives.start = (*emitter).tag_directives.top;
    yaml_free((*emitter).anchors as *mut libc::c_void);
    memset(
        emitter as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_emitter_t>() as libc::c_ulong,
    );
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_initialize(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            357 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 46], &[libc::c_char; 46]>(
                b"int yaml_emitter_initialize(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_63526: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                357 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 46], &[libc::c_char; 46]>(
                    b"int yaml_emitter_initialize(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        emitter as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_emitter_t>() as libc::c_ulong,
    );
    (*emitter).buffer.start = yaml_malloc(16384 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !((*emitter).buffer.start).is_null() {
        (*emitter).buffer.pointer = (*emitter).buffer.start;
        (*emitter).buffer.last = (*emitter).buffer.pointer;
        (*emitter).buffer.end = ((*emitter).buffer.start).offset(16384 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        (*emitter).raw_buffer.start =
            yaml_malloc((16384 as libc::c_int * 2 as libc::c_int + 2 as libc::c_int) as size_t)
                as *mut yaml_char_t;
        if !(if !((*emitter).raw_buffer.start).is_null() {
            (*emitter).raw_buffer.pointer = (*emitter).raw_buffer.start;
            (*emitter).raw_buffer.last = (*emitter).raw_buffer.pointer;
            (*emitter).raw_buffer.end = ((*emitter).raw_buffer.start)
                .offset((16384 as libc::c_int * 2 as libc::c_int + 2 as libc::c_int) as isize);
            1 as libc::c_int
        } else {
            (*emitter).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0)
        {
            (*emitter).states.start = yaml_malloc(
                (16 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<yaml_emitter_state_t>() as libc::c_ulong),
            ) as *mut yaml_emitter_state_t;
            if !(if !((*emitter).states.start).is_null() {
                (*emitter).states.top = (*emitter).states.start;
                (*emitter).states.end =
                    ((*emitter).states.start).offset(16 as libc::c_int as isize);
                1 as libc::c_int
            } else {
                (*emitter).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                (*emitter).events.start = yaml_malloc(
                    (16 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<yaml_event_t>() as libc::c_ulong),
                ) as *mut yaml_event_t;
                if !(if !((*emitter).events.start).is_null() {
                    (*emitter).events.tail = (*emitter).events.start;
                    (*emitter).events.head = (*emitter).events.tail;
                    (*emitter).events.end =
                        ((*emitter).events.start).offset(16 as libc::c_int as isize);
                    1 as libc::c_int
                } else {
                    (*emitter).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    (*emitter).indents.start =
                        yaml_malloc(
                            (16 as libc::c_int as libc::c_ulong).wrapping_mul(
                                ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                            ),
                        ) as *mut libc::c_int;
                    if !(if !((*emitter).indents.start).is_null() {
                        (*emitter).indents.top = (*emitter).indents.start;
                        (*emitter).indents.end =
                            ((*emitter).indents.start).offset(16 as libc::c_int as isize);
                        1 as libc::c_int
                    } else {
                        (*emitter).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        (*emitter).tag_directives.start =
                            yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                                ::core::mem::size_of::<yaml_tag_directive_t>() as libc::c_ulong,
                            )) as *mut yaml_tag_directive_t;
                        if !(if !((*emitter).tag_directives.start).is_null() {
                            (*emitter).tag_directives.top = (*emitter).tag_directives.start;
                            (*emitter).tag_directives.end = ((*emitter).tag_directives.start)
                                .offset(16 as libc::c_int as isize);
                            1 as libc::c_int
                        } else {
                            (*emitter).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0)
                        {
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_free((*emitter).buffer.start as *mut libc::c_void);
    (*emitter).buffer.end = 0 as *mut yaml_char_t;
    (*emitter).buffer.pointer = (*emitter).buffer.end;
    (*emitter).buffer.start = (*emitter).buffer.pointer;
    yaml_free((*emitter).raw_buffer.start as *mut libc::c_void);
    (*emitter).raw_buffer.end = 0 as *mut libc::c_uchar;
    (*emitter).raw_buffer.pointer = (*emitter).raw_buffer.end;
    (*emitter).raw_buffer.start = (*emitter).raw_buffer.pointer;
    yaml_free((*emitter).states.start as *mut libc::c_void);
    (*emitter).states.end = 0 as *mut yaml_emitter_state_t;
    (*emitter).states.top = (*emitter).states.end;
    (*emitter).states.start = (*emitter).states.top;
    yaml_free((*emitter).events.start as *mut libc::c_void);
    (*emitter).events.end = 0 as *mut yaml_event_t;
    (*emitter).events.tail = (*emitter).events.end;
    (*emitter).events.head = (*emitter).events.tail;
    (*emitter).events.start = (*emitter).events.head;
    yaml_free((*emitter).indents.start as *mut libc::c_void);
    (*emitter).indents.end = 0 as *mut libc::c_int;
    (*emitter).indents.top = (*emitter).indents.end;
    (*emitter).indents.start = (*emitter).indents.top;
    yaml_free((*emitter).tag_directives.start as *mut libc::c_void);
    (*emitter).tag_directives.end = 0 as *mut yaml_tag_directive_t;
    (*emitter).tag_directives.top = (*emitter).tag_directives.end;
    (*emitter).tag_directives.start = (*emitter).tag_directives.top;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_stream_start_event_initialize(
    mut event: *mut yaml_event_t,
    mut encoding: yaml_encoding_t,
) -> libc::c_int {
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./api.c\0" as *const u8 as *const libc::c_char,
            674 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                b"int yaml_stream_start_event_initialize(yaml_event_t *, yaml_encoding_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_2731: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./api.c\0" as *const u8 as *const libc::c_char,
                674 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 72], &[libc::c_char; 72]>(
                    b"int yaml_stream_start_event_initialize(yaml_event_t *, yaml_encoding_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_STREAM_START_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    (*event).data.stream_start.encoding = encoding;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_open(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            67 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
                b"int yaml_emitter_open(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_88195: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                67 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
                    b"int yaml_emitter_open(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*emitter).opened == 0 {
    } else {
        __assert_fail(
            b"!emitter->opened\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            68 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
                b"int yaml_emitter_open(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_88156: {
        if (*emitter).opened == 0 {
        } else {
            __assert_fail(
                b"!emitter->opened\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                68 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 40], &[libc::c_char; 40]>(
                    b"int yaml_emitter_open(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_STREAM_START_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    event.data.stream_start.encoding = YAML_ANY_ENCODING;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    (*emitter).opened = 1 as libc::c_int;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_close(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            91 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"int yaml_emitter_close(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_88350: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                91 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"int yaml_emitter_close(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*emitter).opened != 0 {
    } else {
        __assert_fail(
            b"emitter->opened\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            92 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"int yaml_emitter_close(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_88313: {
        if (*emitter).opened != 0 {
        } else {
            __assert_fail(
                b"emitter->opened\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                92 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"int yaml_emitter_close(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*emitter).closed != 0 {
        return 1 as libc::c_int;
    }
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_STREAM_END_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    (*emitter).closed = 1 as libc::c_int;
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_dump(
    mut emitter: *mut yaml_emitter_t,
    mut document: *mut yaml_document_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            117 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_90191: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                117 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                    b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./dumper.c\0" as *const u8 as *const libc::c_char,
            118 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_90159: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                118 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                    b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).document = document;
    if (*emitter).opened == 0 {
        if yaml_emitter_open(emitter) == 0 {
            current_block = 1960405538654103744;
        } else {
            current_block = 7502529970979898288;
        }
    } else {
        current_block = 7502529970979898288;
    }
    match current_block {
        7502529970979898288 => {
            if (*document).nodes.start == (*document).nodes.top {
                if !(yaml_emitter_close(emitter) == 0) {
                    yaml_emitter_delete_document_and_anchors(emitter);
                    return 1 as libc::c_int;
                }
            } else {
                if (*emitter).opened != 0 {
                } else {
                    __assert_fail(
                        b"emitter->opened\0" as *const u8 as *const libc::c_char,
                        b"./dumper.c\0" as *const u8 as *const libc::c_char,
                        132 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                            b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
                        ))
                        .as_ptr(),
                    );
                }
                'c_90072: {
                    if (*emitter).opened != 0 {
                    } else {
                        __assert_fail(
                            b"emitter->opened\0" as *const u8 as *const libc::c_char,
                            b"./dumper.c\0" as *const u8 as *const libc::c_char,
                            132 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<&[u8; 59], &[libc::c_char; 59]>(
                                b"int yaml_emitter_dump(yaml_emitter_t *, yaml_document_t *)\0",
                            ))
                            .as_ptr(),
                        );
                    }
                };
                (*emitter).anchors = yaml_malloc(
                    (::core::mem::size_of::<yaml_anchors_t>() as libc::c_ulong)
                        .wrapping_mul(((*document).nodes.top).offset_from((*document).nodes.start)
                            as libc::c_long as libc::c_ulong),
                ) as *mut yaml_anchors_t;
                if !((*emitter).anchors).is_null() {
                    memset(
                        (*emitter).anchors as *mut libc::c_void,
                        0 as libc::c_int,
                        (::core::mem::size_of::<yaml_anchors_t>() as libc::c_ulong).wrapping_mul(
                            ((*document).nodes.top).offset_from((*document).nodes.start)
                                as libc::c_long as libc::c_ulong,
                        ),
                    );
                    memset(
                        &mut event as *mut yaml_event_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                    );
                    event.type_0 = YAML_DOCUMENT_START_EVENT;
                    event.start_mark = mark;
                    event.end_mark = mark;
                    event.data.document_start.version_directive = (*document).version_directive;
                    event.data.document_start.tag_directives.start =
                        (*document).tag_directives.start;
                    event.data.document_start.tag_directives.end = (*document).tag_directives.end;
                    event.data.document_start.implicit = (*document).start_implicit;
                    if !(yaml_emitter_emit(emitter, &mut event) == 0) {
                        yaml_emitter_anchor_node(emitter, 1 as libc::c_int);
                        if !(yaml_emitter_dump_node(emitter, 1 as libc::c_int) == 0) {
                            memset(
                                &mut event as *mut yaml_event_t as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                            );
                            event.type_0 = YAML_DOCUMENT_END_EVENT;
                            event.start_mark = mark;
                            event.end_mark = mark;
                            event.data.document_end.implicit = (*document).end_implicit;
                            if !(yaml_emitter_emit(emitter, &mut event) == 0) {
                                yaml_emitter_delete_document_and_anchors(emitter);
                                return 1 as libc::c_int;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    yaml_emitter_delete_document_and_anchors(emitter);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_delete_document_and_anchors(mut emitter: *mut yaml_emitter_t) {
    let mut index: libc::c_int = 0;
    if ((*emitter).anchors).is_null() {
        yaml_document_delete((*emitter).document);
        (*emitter).document = 0 as *mut yaml_document_t;
        return;
    }
    index = 0 as libc::c_int;
    while ((*(*emitter).document).nodes.start).offset(index as isize)
        < (*(*emitter).document).nodes.top
    {
        let mut node: yaml_node_t = *((*(*emitter).document).nodes.start).offset(index as isize);
        if (*((*emitter).anchors).offset(index as isize)).serialized == 0 {
            yaml_free(node.tag as *mut libc::c_void);
            if node.type_0 as libc::c_uint == YAML_SCALAR_NODE as libc::c_int as libc::c_uint {
                yaml_free(node.data.scalar.value as *mut libc::c_void);
            }
        }
        if node.type_0 as libc::c_uint == YAML_SEQUENCE_NODE as libc::c_int as libc::c_uint {
            yaml_free(node.data.sequence.items.start as *mut libc::c_void);
            node.data.sequence.items.end = 0 as *mut yaml_node_item_t;
            node.data.sequence.items.top = node.data.sequence.items.end;
            node.data.sequence.items.start = node.data.sequence.items.top;
        }
        if node.type_0 as libc::c_uint == YAML_MAPPING_NODE as libc::c_int as libc::c_uint {
            yaml_free(node.data.mapping.pairs.start as *mut libc::c_void);
            node.data.mapping.pairs.end = 0 as *mut yaml_node_pair_t;
            node.data.mapping.pairs.top = node.data.mapping.pairs.end;
            node.data.mapping.pairs.start = node.data.mapping.pairs.top;
        }
        index += 1;
        index;
    }
    yaml_free((*(*emitter).document).nodes.start as *mut libc::c_void);
    (*(*emitter).document).nodes.end = 0 as *mut yaml_node_t;
    (*(*emitter).document).nodes.top = (*(*emitter).document).nodes.end;
    (*(*emitter).document).nodes.start = (*(*emitter).document).nodes.top;
    yaml_free((*emitter).anchors as *mut libc::c_void);
    (*emitter).anchors = 0 as *mut yaml_anchors_t;
    (*emitter).last_anchor_id = 0 as libc::c_int;
    (*emitter).document = 0 as *mut yaml_document_t;
}
unsafe extern "C" fn yaml_emitter_anchor_node(
    mut emitter: *mut yaml_emitter_t,
    mut index: libc::c_int,
) {
    let mut node: *mut yaml_node_t = ((*(*emitter).document).nodes.start)
        .offset(index as isize)
        .offset(-(1 as libc::c_int as isize));
    let mut item: *mut yaml_node_item_t = 0 as *mut yaml_node_item_t;
    let mut pair: *mut yaml_node_pair_t = 0 as *mut yaml_node_pair_t;
    let ref mut fresh11 =
        (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).references;
    *fresh11 += 1;
    *fresh11;
    if (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).references
        == 1 as libc::c_int
    {
        match (*node).type_0 as libc::c_uint {
            2 => {
                item = (*node).data.sequence.items.start;
                while item < (*node).data.sequence.items.top {
                    yaml_emitter_anchor_node(emitter, *item);
                    item = item.offset(1);
                    item;
                }
            }
            3 => {
                pair = (*node).data.mapping.pairs.start;
                while pair < (*node).data.mapping.pairs.top {
                    yaml_emitter_anchor_node(emitter, (*pair).key);
                    yaml_emitter_anchor_node(emitter, (*pair).value);
                    pair = pair.offset(1);
                    pair;
                }
            }
            _ => {}
        }
    } else if (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).references
        == 2 as libc::c_int
    {
        (*emitter).last_anchor_id += 1;
        (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).anchor =
            (*emitter).last_anchor_id;
    }
}
unsafe extern "C" fn yaml_emitter_generate_anchor(
    mut emitter: *mut yaml_emitter_t,
    mut anchor_id: libc::c_int,
) -> *mut yaml_char_t {
    let mut anchor: *mut yaml_char_t = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if anchor.is_null() {
        return 0 as *mut yaml_char_t;
    }
    sprintf(
        anchor as *mut libc::c_char,
        b"id%03d\0" as *const u8 as *const libc::c_char,
        anchor_id,
    );
    return anchor;
}
unsafe extern "C" fn yaml_emitter_dump_node(
    mut emitter: *mut yaml_emitter_t,
    mut index: libc::c_int,
) -> libc::c_int {
    let mut node: *mut yaml_node_t = ((*(*emitter).document).nodes.start)
        .offset(index as isize)
        .offset(-(1 as libc::c_int as isize));
    let mut anchor_id: libc::c_int =
        (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).anchor;
    let mut anchor: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if anchor_id != 0 {
        anchor = yaml_emitter_generate_anchor(emitter, anchor_id);
        if anchor.is_null() {
            return 0 as libc::c_int;
        }
    }
    if (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).serialized != 0 {
        return yaml_emitter_dump_alias(emitter, anchor);
    }
    (*((*emitter).anchors).offset((index - 1 as libc::c_int) as isize)).serialized =
        1 as libc::c_int;
    match (*node).type_0 as libc::c_uint {
        1 => return yaml_emitter_dump_scalar(emitter, node, anchor),
        2 => return yaml_emitter_dump_sequence(emitter, node, anchor),
        3 => return yaml_emitter_dump_mapping(emitter, node, anchor),
        _ => {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"./dumper.c\0" as *const u8 as *const libc::c_char,
                289 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 50], &[libc::c_char; 50]>(
                    b"int yaml_emitter_dump_node(yaml_emitter_t *, int)\0",
                ))
                .as_ptr(),
            );
            'c_88799: {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"./dumper.c\0" as *const u8 as *const libc::c_char,
                    289 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<&[u8; 50], &[libc::c_char; 50]>(
                        b"int yaml_emitter_dump_node(yaml_emitter_t *, int)\0",
                    ))
                    .as_ptr(),
                );
            };
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_dump_alias(
    mut emitter: *mut yaml_emitter_t,
    mut anchor: *mut yaml_char_t,
) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_ALIAS_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    event.data.alias.anchor = anchor;
    return yaml_emitter_emit(emitter, &mut event);
}
unsafe extern "C" fn yaml_emitter_dump_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut node: *mut yaml_node_t,
    mut anchor: *mut yaml_char_t,
) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut plain_implicit: libc::c_int = (strcmp(
        (*node).tag as *mut libc::c_char,
        b"tag:yaml.org,2002:str\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int) as libc::c_int;
    let mut quoted_implicit: libc::c_int = (strcmp(
        (*node).tag as *mut libc::c_char,
        b"tag:yaml.org,2002:str\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int) as libc::c_int;
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_SCALAR_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    event.data.scalar.anchor = anchor;
    event.data.scalar.tag = (*node).tag;
    event.data.scalar.value = (*node).data.scalar.value;
    event.data.scalar.length = (*node).data.scalar.length;
    event.data.scalar.plain_implicit = plain_implicit;
    event.data.scalar.quoted_implicit = quoted_implicit;
    event.data.scalar.style = (*node).data.scalar.style;
    return yaml_emitter_emit(emitter, &mut event);
}
unsafe extern "C" fn yaml_emitter_dump_sequence(
    mut emitter: *mut yaml_emitter_t,
    mut node: *mut yaml_node_t,
    mut anchor: *mut yaml_char_t,
) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut implicit: libc::c_int = (strcmp(
        (*node).tag as *mut libc::c_char,
        b"tag:yaml.org,2002:seq\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int) as libc::c_int;
    let mut item: *mut yaml_node_item_t = 0 as *mut yaml_node_item_t;
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_SEQUENCE_START_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    event.data.sequence_start.anchor = anchor;
    event.data.sequence_start.tag = (*node).tag;
    event.data.sequence_start.implicit = implicit;
    event.data.sequence_start.style = (*node).data.sequence.style;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    item = (*node).data.sequence.items.start;
    while item < (*node).data.sequence.items.top {
        if yaml_emitter_dump_node(emitter, *item) == 0 {
            return 0 as libc::c_int;
        }
        item = item.offset(1);
        item;
    }
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_SEQUENCE_END_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_dump_mapping(
    mut emitter: *mut yaml_emitter_t,
    mut node: *mut yaml_node_t,
    mut anchor: *mut yaml_char_t,
) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut mark: yaml_mark_t = {
        let mut init = yaml_mark_s {
            index: 0 as libc::c_int as size_t,
            line: 0 as libc::c_int as size_t,
            column: 0 as libc::c_int as size_t,
        };
        init
    };
    let mut implicit: libc::c_int = (strcmp(
        (*node).tag as *mut libc::c_char,
        b"tag:yaml.org,2002:map\0" as *const u8 as *const libc::c_char,
    ) == 0 as libc::c_int) as libc::c_int;
    let mut pair: *mut yaml_node_pair_t = 0 as *mut yaml_node_pair_t;
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_MAPPING_START_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    event.data.mapping_start.anchor = anchor;
    event.data.mapping_start.tag = (*node).tag;
    event.data.mapping_start.implicit = implicit;
    event.data.mapping_start.style = (*node).data.mapping.style;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    pair = (*node).data.mapping.pairs.start;
    while pair < (*node).data.mapping.pairs.top {
        if yaml_emitter_dump_node(emitter, (*pair).key) == 0 {
            return 0 as libc::c_int;
        }
        if yaml_emitter_dump_node(emitter, (*pair).value) == 0 {
            return 0 as libc::c_int;
        }
        pair = pair.offset(1);
        pair;
    }
    memset(
        &mut event as *mut yaml_event_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    event.type_0 = YAML_MAPPING_END_EVENT;
    event.start_mark = mark;
    event.end_mark = mark;
    if yaml_emitter_emit(emitter, &mut event) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_set_emitter_error(
    mut emitter: *mut yaml_emitter_t,
    mut problem: *const libc::c_char,
) -> libc::c_int {
    (*emitter).error = YAML_EMITTER_ERROR;
    (*emitter).problem = problem;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_emit(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if if (*emitter).events.tail != (*emitter).events.end
        || yaml_queue_extend(
            &mut (*emitter).events.start as *mut *mut yaml_event_t as *mut *mut libc::c_void,
            &mut (*emitter).events.head as *mut *mut yaml_event_t as *mut *mut libc::c_void,
            &mut (*emitter).events.tail as *mut *mut yaml_event_t as *mut *mut libc::c_void,
            &mut (*emitter).events.end as *mut *mut yaml_event_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh12 = (*emitter).events.tail;
        (*emitter).events.tail = ((*emitter).events.tail).offset(1);
        *fresh12 = *event;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_event_delete(event);
        return 0 as libc::c_int;
    }
    while yaml_emitter_need_more_events(emitter) == 0 {
        if yaml_emitter_analyze_event(emitter, (*emitter).events.head) == 0 {
            return 0 as libc::c_int;
        }
        if yaml_emitter_state_machine(emitter, (*emitter).events.head) == 0 {
            return 0 as libc::c_int;
        }
        let fresh13 = (*emitter).events.head;
        (*emitter).events.head = ((*emitter).events.head).offset(1);
        yaml_event_delete(fresh13);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_need_more_events(
    mut emitter: *mut yaml_emitter_t,
) -> libc::c_int {
    let mut level: libc::c_int = 0 as libc::c_int;
    let mut accumulate: libc::c_int = 0 as libc::c_int;
    let mut event: *mut yaml_event_t = 0 as *mut yaml_event_t;
    if (*emitter).events.head == (*emitter).events.tail {
        return 1 as libc::c_int;
    }
    match (*(*emitter).events.head).type_0 as libc::c_uint {
        3 => {
            accumulate = 1 as libc::c_int;
        }
        7 => {
            accumulate = 2 as libc::c_int;
        }
        9 => {
            accumulate = 3 as libc::c_int;
        }
        _ => return 0 as libc::c_int,
    }
    if ((*emitter).events.tail).offset_from((*emitter).events.head) as libc::c_long
        > accumulate as libc::c_long
    {
        return 0 as libc::c_int;
    }
    event = (*emitter).events.head;
    while event != (*emitter).events.tail {
        match (*event).type_0 as libc::c_uint {
            1 | 3 | 7 | 9 => {
                level += 1 as libc::c_int;
            }
            2 | 4 | 8 | 10 => {
                level -= 1 as libc::c_int;
            }
            _ => {}
        }
        if level == 0 {
            return 0 as libc::c_int;
        }
        event = event.offset(1);
        event;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_append_tag_directive(
    mut emitter: *mut yaml_emitter_t,
    mut value: yaml_tag_directive_t,
    mut allow_duplicates: libc::c_int,
) -> libc::c_int {
    let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    let mut copy: yaml_tag_directive_t = {
        let mut init = yaml_tag_directive_s {
            handle: 0 as *mut yaml_char_t,
            prefix: 0 as *mut yaml_char_t,
        };
        init
    };
    tag_directive = (*emitter).tag_directives.start;
    while tag_directive != (*emitter).tag_directives.top {
        if strcmp(
            value.handle as *mut libc::c_char,
            (*tag_directive).handle as *mut libc::c_char,
        ) == 0 as libc::c_int
        {
            if allow_duplicates != 0 {
                return 1 as libc::c_int;
            }
            return yaml_emitter_set_emitter_error(
                emitter,
                b"duplicate %TAG directive\0" as *const u8 as *const libc::c_char,
            );
        }
        tag_directive = tag_directive.offset(1);
        tag_directive;
    }
    copy.handle = yaml_strdup(value.handle);
    copy.prefix = yaml_strdup(value.prefix);
    if (copy.handle).is_null() || (copy.prefix).is_null() {
        (*emitter).error = YAML_MEMORY_ERROR;
    } else if !(if (*emitter).tag_directives.top != (*emitter).tag_directives.end
        || yaml_stack_extend(
            &mut (*emitter).tag_directives.start as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
            &mut (*emitter).tag_directives.top as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
            &mut (*emitter).tag_directives.end as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh14 = (*emitter).tag_directives.top;
        (*emitter).tag_directives.top = ((*emitter).tag_directives.top).offset(1);
        *fresh14 = copy;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        return 1 as libc::c_int;
    }
    yaml_free(copy.handle as *mut libc::c_void);
    yaml_free(copy.prefix as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_increase_indent(
    mut emitter: *mut yaml_emitter_t,
    mut flow: libc::c_int,
    mut indentless: libc::c_int,
) -> libc::c_int {
    if if (*emitter).indents.top != (*emitter).indents.end
        || yaml_stack_extend(
            &mut (*emitter).indents.start as *mut *mut libc::c_int as *mut *mut libc::c_void,
            &mut (*emitter).indents.top as *mut *mut libc::c_int as *mut *mut libc::c_void,
            &mut (*emitter).indents.end as *mut *mut libc::c_int as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh15 = (*emitter).indents.top;
        (*emitter).indents.top = ((*emitter).indents.top).offset(1);
        *fresh15 = (*emitter).indent;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    if (*emitter).indent < 0 as libc::c_int {
        (*emitter).indent = if flow != 0 {
            (*emitter).best_indent
        } else {
            0 as libc::c_int
        };
    } else if indentless == 0 {
        (*emitter).indent += (*emitter).best_indent;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_state_machine(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    match (*emitter).state as libc::c_uint {
        0 => return yaml_emitter_emit_stream_start(emitter, event),
        1 => return yaml_emitter_emit_document_start(emitter, event, 1 as libc::c_int),
        2 => return yaml_emitter_emit_document_start(emitter, event, 0 as libc::c_int),
        3 => return yaml_emitter_emit_document_content(emitter, event),
        4 => return yaml_emitter_emit_document_end(emitter, event),
        5 => {
            return yaml_emitter_emit_flow_sequence_item(emitter, event, 1 as libc::c_int);
        }
        6 => {
            return yaml_emitter_emit_flow_sequence_item(emitter, event, 0 as libc::c_int);
        }
        7 => return yaml_emitter_emit_flow_mapping_key(emitter, event, 1 as libc::c_int),
        8 => return yaml_emitter_emit_flow_mapping_key(emitter, event, 0 as libc::c_int),
        9 => {
            return yaml_emitter_emit_flow_mapping_value(emitter, event, 1 as libc::c_int);
        }
        10 => {
            return yaml_emitter_emit_flow_mapping_value(emitter, event, 0 as libc::c_int);
        }
        11 => {
            return yaml_emitter_emit_block_sequence_item(emitter, event, 1 as libc::c_int);
        }
        12 => {
            return yaml_emitter_emit_block_sequence_item(emitter, event, 0 as libc::c_int);
        }
        13 => {
            return yaml_emitter_emit_block_mapping_key(emitter, event, 1 as libc::c_int);
        }
        14 => {
            return yaml_emitter_emit_block_mapping_key(emitter, event, 0 as libc::c_int);
        }
        15 => {
            return yaml_emitter_emit_block_mapping_value(emitter, event, 1 as libc::c_int);
        }
        16 => {
            return yaml_emitter_emit_block_mapping_value(emitter, event, 0 as libc::c_int);
        }
        17 => {
            return yaml_emitter_set_emitter_error(
                emitter,
                b"expected nothing after STREAM-END\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            'c_64876: {};
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_emit_stream_start(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    (*emitter).open_ended = 0 as libc::c_int;
    if (*event).type_0 as libc::c_uint == YAML_STREAM_START_EVENT as libc::c_int as libc::c_uint {
        if (*emitter).encoding as u64 == 0 {
            (*emitter).encoding = (*event).data.stream_start.encoding;
        }
        if (*emitter).encoding as u64 == 0 {
            (*emitter).encoding = YAML_UTF8_ENCODING;
        }
        if (*emitter).best_indent < 2 as libc::c_int || (*emitter).best_indent > 9 as libc::c_int {
            (*emitter).best_indent = 2 as libc::c_int;
        }
        if (*emitter).best_width >= 0 as libc::c_int
            && (*emitter).best_width <= (*emitter).best_indent * 2 as libc::c_int
        {
            (*emitter).best_width = 80 as libc::c_int;
        }
        if (*emitter).best_width < 0 as libc::c_int {
            (*emitter).best_width = 2147483647 as libc::c_int;
        }
        if (*emitter).line_break as u64 == 0 {
            (*emitter).line_break = YAML_LN_BREAK;
        }
        (*emitter).indent = -(1 as libc::c_int);
        (*emitter).line = 0 as libc::c_int;
        (*emitter).column = 0 as libc::c_int;
        (*emitter).whitespace = 1 as libc::c_int;
        (*emitter).indention = 1 as libc::c_int;
        if (*emitter).encoding as libc::c_uint != YAML_UTF8_ENCODING as libc::c_int as libc::c_uint
        {
            if yaml_emitter_write_bom(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        (*emitter).state = YAML_EMIT_FIRST_DOCUMENT_START_STATE;
        return 1 as libc::c_int;
    }
    return yaml_emitter_set_emitter_error(
        emitter,
        b"expected STREAM-START\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn yaml_emitter_emit_document_start(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    if (*event).type_0 as libc::c_uint == YAML_DOCUMENT_START_EVENT as libc::c_int as libc::c_uint {
        let mut default_tag_directives: [yaml_tag_directive_t; 3] = [
            {
                let mut init = yaml_tag_directive_s {
                    handle: b"!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
                    prefix: b"!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
                };
                init
            },
            {
                let mut init = yaml_tag_directive_s {
                    handle: b"!!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
                    prefix: b"tag:yaml.org,2002:\0" as *const u8 as *const libc::c_char
                        as *mut yaml_char_t,
                };
                init
            },
            {
                let mut init = yaml_tag_directive_s {
                    handle: 0 as *mut yaml_char_t,
                    prefix: 0 as *mut yaml_char_t,
                };
                init
            },
        ];
        let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
        let mut implicit: libc::c_int = 0;
        if !((*event).data.document_start.version_directive).is_null() {
            if yaml_emitter_analyze_version_directive(
                emitter,
                *(*event).data.document_start.version_directive,
            ) == 0
            {
                return 0 as libc::c_int;
            }
        }
        tag_directive = (*event).data.document_start.tag_directives.start;
        while tag_directive != (*event).data.document_start.tag_directives.end {
            if yaml_emitter_analyze_tag_directive(emitter, *tag_directive) == 0 {
                return 0 as libc::c_int;
            }
            if yaml_emitter_append_tag_directive(emitter, *tag_directive, 0 as libc::c_int) == 0 {
                return 0 as libc::c_int;
            }
            tag_directive = tag_directive.offset(1);
            tag_directive;
        }
        tag_directive = default_tag_directives.as_mut_ptr();
        while !((*tag_directive).handle).is_null() {
            if yaml_emitter_append_tag_directive(emitter, *tag_directive, 1 as libc::c_int) == 0 {
                return 0 as libc::c_int;
            }
            tag_directive = tag_directive.offset(1);
            tag_directive;
        }
        implicit = (*event).data.document_start.implicit;
        if first == 0 || (*emitter).canonical != 0 {
            implicit = 0 as libc::c_int;
        }
        if (!((*event).data.document_start.version_directive).is_null()
            || (*event).data.document_start.tag_directives.start
                != (*event).data.document_start.tag_directives.end)
            && (*emitter).open_ended != 0
        {
            if yaml_emitter_write_indicator(
                emitter,
                b"...\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        (*emitter).open_ended = 0 as libc::c_int;
        if !((*event).data.document_start.version_directive).is_null() {
            implicit = 0 as libc::c_int;
            if yaml_emitter_write_indicator(
                emitter,
                b"%YAML\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if (*(*event).data.document_start.version_directive).minor == 1 as libc::c_int {
                if yaml_emitter_write_indicator(
                    emitter,
                    b"1.1\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
            } else if yaml_emitter_write_indicator(
                emitter,
                b"1.2\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        if (*event).data.document_start.tag_directives.start
            != (*event).data.document_start.tag_directives.end
        {
            implicit = 0 as libc::c_int;
            tag_directive = (*event).data.document_start.tag_directives.start;
            while tag_directive != (*event).data.document_start.tag_directives.end {
                if yaml_emitter_write_indicator(
                    emitter,
                    b"%TAG\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
                if yaml_emitter_write_tag_handle(
                    emitter,
                    (*tag_directive).handle,
                    strlen((*tag_directive).handle as *mut libc::c_char),
                ) == 0
                {
                    return 0 as libc::c_int;
                }
                if yaml_emitter_write_tag_content(
                    emitter,
                    (*tag_directive).prefix,
                    strlen((*tag_directive).prefix as *mut libc::c_char),
                    1 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                tag_directive = tag_directive.offset(1);
                tag_directive;
            }
        }
        if yaml_emitter_check_empty_document(emitter) != 0 {
            implicit = 0 as libc::c_int;
        }
        if implicit == 0 {
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
            if yaml_emitter_write_indicator(
                emitter,
                b"---\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if (*emitter).canonical != 0 {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
            }
        }
        (*emitter).state = YAML_EMIT_DOCUMENT_CONTENT_STATE;
        (*emitter).open_ended = 0 as libc::c_int;
        return 1 as libc::c_int;
    } else if (*event).type_0 as libc::c_uint
        == YAML_STREAM_END_EVENT as libc::c_int as libc::c_uint
    {
        if (*emitter).open_ended == 2 as libc::c_int {
            if yaml_emitter_write_indicator(
                emitter,
                b"...\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            (*emitter).open_ended = 0 as libc::c_int;
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        if yaml_emitter_flush(emitter) == 0 {
            return 0 as libc::c_int;
        }
        (*emitter).state = YAML_EMIT_END_STATE;
        return 1 as libc::c_int;
    }
    return yaml_emitter_set_emitter_error(
        emitter,
        b"expected DOCUMENT-START or STREAM-END\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn yaml_emitter_emit_document_content(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if if (*emitter).states.top != (*emitter).states.end
        || yaml_stack_extend(
            &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                as *mut *mut libc::c_void,
            &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
            &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh16 = (*emitter).states.top;
        (*emitter).states.top = ((*emitter).states.top).offset(1);
        *fresh16 = YAML_EMIT_DOCUMENT_END_STATE;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_emit_node(
        emitter,
        event,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn yaml_emitter_emit_document_end(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if (*event).type_0 as libc::c_uint == YAML_DOCUMENT_END_EVENT as libc::c_int as libc::c_uint {
        if yaml_emitter_write_indent(emitter) == 0 {
            return 0 as libc::c_int;
        }
        if (*event).data.document_end.implicit == 0 {
            if yaml_emitter_write_indicator(
                emitter,
                b"...\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            (*emitter).open_ended = 0 as libc::c_int;
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        } else if (*emitter).open_ended == 0 {
            (*emitter).open_ended = 1 as libc::c_int;
        }
        if yaml_emitter_flush(emitter) == 0 {
            return 0 as libc::c_int;
        }
        (*emitter).state = YAML_EMIT_DOCUMENT_START_STATE;
        while !((*emitter).tag_directives.start == (*emitter).tag_directives.top) {
            (*emitter).tag_directives.top = ((*emitter).tag_directives.top).offset(-1);
            let mut tag_directive: yaml_tag_directive_t = *(*emitter).tag_directives.top;
            yaml_free(tag_directive.handle as *mut libc::c_void);
            yaml_free(tag_directive.prefix as *mut libc::c_void);
        }
        return 1 as libc::c_int;
    }
    return yaml_emitter_set_emitter_error(
        emitter,
        b"expected DOCUMENT-END\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn yaml_emitter_emit_flow_sequence_item(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    if first != 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b"[\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if yaml_emitter_increase_indent(emitter, 1 as libc::c_int, 0 as libc::c_int) == 0 {
            return 0 as libc::c_int;
        }
        (*emitter).flow_level += 1;
        (*emitter).flow_level;
    }
    if (*event).type_0 as libc::c_uint == YAML_SEQUENCE_END_EVENT as libc::c_int as libc::c_uint {
        (*emitter).flow_level -= 1;
        (*emitter).flow_level;
        (*emitter).indents.top = ((*emitter).indents.top).offset(-1);
        (*emitter).indent = *(*emitter).indents.top;
        if (*emitter).canonical != 0 && first == 0 {
            if yaml_emitter_write_indicator(
                emitter,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        if yaml_emitter_write_indicator(
            emitter,
            b"]\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        (*emitter).states.top = ((*emitter).states.top).offset(-1);
        (*emitter).state = *(*emitter).states.top;
        return 1 as libc::c_int;
    }
    if first == 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b",\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if (*emitter).canonical != 0 || (*emitter).column > (*emitter).best_width {
        if yaml_emitter_write_indent(emitter) == 0 {
            return 0 as libc::c_int;
        }
    }
    if if (*emitter).states.top != (*emitter).states.end
        || yaml_stack_extend(
            &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                as *mut *mut libc::c_void,
            &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
            &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh17 = (*emitter).states.top;
        (*emitter).states.top = ((*emitter).states.top).offset(1);
        *fresh17 = YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_emit_node(
        emitter,
        event,
        0 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn yaml_emitter_emit_flow_mapping_key(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    if first != 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b"{\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if yaml_emitter_increase_indent(emitter, 1 as libc::c_int, 0 as libc::c_int) == 0 {
            return 0 as libc::c_int;
        }
        (*emitter).flow_level += 1;
        (*emitter).flow_level;
    }
    if (*event).type_0 as libc::c_uint == YAML_MAPPING_END_EVENT as libc::c_int as libc::c_uint {
        (*emitter).flow_level -= 1;
        (*emitter).flow_level;
        (*emitter).indents.top = ((*emitter).indents.top).offset(-1);
        (*emitter).indent = *(*emitter).indents.top;
        if (*emitter).canonical != 0 && first == 0 {
            if yaml_emitter_write_indicator(
                emitter,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        if yaml_emitter_write_indicator(
            emitter,
            b"}\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        (*emitter).states.top = ((*emitter).states.top).offset(-1);
        (*emitter).state = *(*emitter).states.top;
        return 1 as libc::c_int;
    }
    if first == 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b",\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if (*emitter).canonical != 0 || (*emitter).column > (*emitter).best_width {
        if yaml_emitter_write_indent(emitter) == 0 {
            return 0 as libc::c_int;
        }
    }
    if (*emitter).canonical == 0 && yaml_emitter_check_simple_key(emitter) != 0 {
        if if (*emitter).states.top != (*emitter).states.end
            || yaml_stack_extend(
                &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh18 = (*emitter).states.top;
            (*emitter).states.top = ((*emitter).states.top).offset(1);
            *fresh18 = YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE;
            1 as libc::c_int
        } else {
            (*emitter).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        return yaml_emitter_emit_node(
            emitter,
            event,
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
        );
    } else {
        if yaml_emitter_write_indicator(
            emitter,
            b"?\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if if (*emitter).states.top != (*emitter).states.end
            || yaml_stack_extend(
                &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh19 = (*emitter).states.top;
            (*emitter).states.top = ((*emitter).states.top).offset(1);
            *fresh19 = YAML_EMIT_FLOW_MAPPING_VALUE_STATE;
            1 as libc::c_int
        } else {
            (*emitter).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        return yaml_emitter_emit_node(
            emitter,
            event,
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    };
}
unsafe extern "C" fn yaml_emitter_emit_flow_mapping_value(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut simple: libc::c_int,
) -> libc::c_int {
    if simple != 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b":\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    } else {
        if (*emitter).canonical != 0 || (*emitter).column > (*emitter).best_width {
            if yaml_emitter_write_indent(emitter) == 0 {
                return 0 as libc::c_int;
            }
        }
        if yaml_emitter_write_indicator(
            emitter,
            b":\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if if (*emitter).states.top != (*emitter).states.end
        || yaml_stack_extend(
            &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                as *mut *mut libc::c_void,
            &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
            &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh20 = (*emitter).states.top;
        (*emitter).states.top = ((*emitter).states.top).offset(1);
        *fresh20 = YAML_EMIT_FLOW_MAPPING_KEY_STATE;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_emit_node(
        emitter,
        event,
        0 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn yaml_emitter_emit_block_sequence_item(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    if first != 0 {
        if yaml_emitter_increase_indent(
            emitter,
            0 as libc::c_int,
            ((*emitter).mapping_context != 0 && (*emitter).indention == 0) as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if (*event).type_0 as libc::c_uint == YAML_SEQUENCE_END_EVENT as libc::c_int as libc::c_uint {
        (*emitter).indents.top = ((*emitter).indents.top).offset(-1);
        (*emitter).indent = *(*emitter).indents.top;
        (*emitter).states.top = ((*emitter).states.top).offset(-1);
        (*emitter).state = *(*emitter).states.top;
        return 1 as libc::c_int;
    }
    if yaml_emitter_write_indent(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_write_indicator(
        emitter,
        b"-\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    if if (*emitter).states.top != (*emitter).states.end
        || yaml_stack_extend(
            &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                as *mut *mut libc::c_void,
            &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
            &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh21 = (*emitter).states.top;
        (*emitter).states.top = ((*emitter).states.top).offset(1);
        *fresh21 = YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_emit_node(
        emitter,
        event,
        0 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn yaml_emitter_emit_block_mapping_key(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    if first != 0 {
        if yaml_emitter_increase_indent(emitter, 0 as libc::c_int, 0 as libc::c_int) == 0 {
            return 0 as libc::c_int;
        }
    }
    if (*event).type_0 as libc::c_uint == YAML_MAPPING_END_EVENT as libc::c_int as libc::c_uint {
        (*emitter).indents.top = ((*emitter).indents.top).offset(-1);
        (*emitter).indent = *(*emitter).indents.top;
        (*emitter).states.top = ((*emitter).states.top).offset(-1);
        (*emitter).state = *(*emitter).states.top;
        return 1 as libc::c_int;
    }
    if yaml_emitter_write_indent(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_check_simple_key(emitter) != 0 {
        if if (*emitter).states.top != (*emitter).states.end
            || yaml_stack_extend(
                &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh22 = (*emitter).states.top;
            (*emitter).states.top = ((*emitter).states.top).offset(1);
            *fresh22 = YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE;
            1 as libc::c_int
        } else {
            (*emitter).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        return yaml_emitter_emit_node(
            emitter,
            event,
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            1 as libc::c_int,
        );
    } else {
        if yaml_emitter_write_indicator(
            emitter,
            b"?\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if if (*emitter).states.top != (*emitter).states.end
            || yaml_stack_extend(
                &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
                &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh23 = (*emitter).states.top;
            (*emitter).states.top = ((*emitter).states.top).offset(1);
            *fresh23 = YAML_EMIT_BLOCK_MAPPING_VALUE_STATE;
            1 as libc::c_int
        } else {
            (*emitter).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        return yaml_emitter_emit_node(
            emitter,
            event,
            0 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    };
}
unsafe extern "C" fn yaml_emitter_emit_block_mapping_value(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut simple: libc::c_int,
) -> libc::c_int {
    if simple != 0 {
        if yaml_emitter_write_indicator(
            emitter,
            b":\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    } else {
        if yaml_emitter_write_indent(emitter) == 0 {
            return 0 as libc::c_int;
        }
        if yaml_emitter_write_indicator(
            emitter,
            b":\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as libc::c_int,
            1 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if if (*emitter).states.top != (*emitter).states.end
        || yaml_stack_extend(
            &mut (*emitter).states.start as *mut *mut yaml_emitter_state_t
                as *mut *mut libc::c_void,
            &mut (*emitter).states.top as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
            &mut (*emitter).states.end as *mut *mut yaml_emitter_state_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh24 = (*emitter).states.top;
        (*emitter).states.top = ((*emitter).states.top).offset(1);
        *fresh24 = YAML_EMIT_BLOCK_MAPPING_KEY_STATE;
        1 as libc::c_int
    } else {
        (*emitter).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_emit_node(
        emitter,
        event,
        0 as libc::c_int,
        0 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn yaml_emitter_emit_node(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
    mut root: libc::c_int,
    mut sequence: libc::c_int,
    mut mapping: libc::c_int,
    mut simple_key: libc::c_int,
) -> libc::c_int {
    (*emitter).root_context = root;
    (*emitter).sequence_context = sequence;
    (*emitter).mapping_context = mapping;
    (*emitter).simple_key_context = simple_key;
    match (*event).type_0 as libc::c_uint {
        5 => return yaml_emitter_emit_alias(emitter, event),
        6 => return yaml_emitter_emit_scalar(emitter, event),
        7 => return yaml_emitter_emit_sequence_start(emitter, event),
        9 => return yaml_emitter_emit_mapping_start(emitter, event),
        _ => {
            return yaml_emitter_set_emitter_error(
                emitter,
                b"expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS\0" as *const u8
                    as *const libc::c_char,
            );
        }
    };
}
unsafe extern "C" fn yaml_emitter_emit_alias(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if yaml_emitter_process_anchor(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if (*emitter).simple_key_context != 0 {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh25 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh25 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).states.top = ((*emitter).states.top).offset(-1);
    (*emitter).state = *(*emitter).states.top;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_emit_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if yaml_emitter_select_scalar_style(emitter, event) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_process_anchor(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_process_tag(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_increase_indent(emitter, 1 as libc::c_int, 0 as libc::c_int) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_process_scalar(emitter) == 0 {
        return 0 as libc::c_int;
    }
    (*emitter).indents.top = ((*emitter).indents.top).offset(-1);
    (*emitter).indent = *(*emitter).indents.top;
    (*emitter).states.top = ((*emitter).states.top).offset(-1);
    (*emitter).state = *(*emitter).states.top;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_emit_sequence_start(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if yaml_emitter_process_anchor(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_process_tag(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if (*emitter).flow_level != 0
        || (*emitter).canonical != 0
        || (*event).data.sequence_start.style as libc::c_uint
            == YAML_FLOW_SEQUENCE_STYLE as libc::c_int as libc::c_uint
        || yaml_emitter_check_empty_sequence(emitter) != 0
    {
        (*emitter).state = YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE;
    } else {
        (*emitter).state = YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_emit_mapping_start(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if yaml_emitter_process_anchor(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_emitter_process_tag(emitter) == 0 {
        return 0 as libc::c_int;
    }
    if (*emitter).flow_level != 0
        || (*emitter).canonical != 0
        || (*event).data.mapping_start.style as libc::c_uint
            == YAML_FLOW_MAPPING_STYLE as libc::c_int as libc::c_uint
        || yaml_emitter_check_empty_mapping(emitter) != 0
    {
        (*emitter).state = YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE;
    } else {
        (*emitter).state = YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_check_empty_document(
    mut emitter: *mut yaml_emitter_t,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_check_empty_sequence(
    mut emitter: *mut yaml_emitter_t,
) -> libc::c_int {
    if (((*emitter).events.tail).offset_from((*emitter).events.head) as libc::c_long)
        < 2 as libc::c_int as libc::c_long
    {
        return 0 as libc::c_int;
    }
    return ((*((*emitter).events.head).offset(0 as libc::c_int as isize)).type_0 as libc::c_uint
        == YAML_SEQUENCE_START_EVENT as libc::c_int as libc::c_uint
        && (*((*emitter).events.head).offset(1 as libc::c_int as isize)).type_0 as libc::c_uint
            == YAML_SEQUENCE_END_EVENT as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_check_empty_mapping(
    mut emitter: *mut yaml_emitter_t,
) -> libc::c_int {
    if (((*emitter).events.tail).offset_from((*emitter).events.head) as libc::c_long)
        < 2 as libc::c_int as libc::c_long
    {
        return 0 as libc::c_int;
    }
    return ((*((*emitter).events.head).offset(0 as libc::c_int as isize)).type_0 as libc::c_uint
        == YAML_MAPPING_START_EVENT as libc::c_int as libc::c_uint
        && (*((*emitter).events.head).offset(1 as libc::c_int as isize)).type_0 as libc::c_uint
            == YAML_MAPPING_END_EVENT as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_check_simple_key(
    mut emitter: *mut yaml_emitter_t,
) -> libc::c_int {
    let mut event: *mut yaml_event_t = (*emitter).events.head;
    let mut length: size_t = 0 as libc::c_int as size_t;
    match (*event).type_0 as libc::c_uint {
        5 => {
            length = (length as libc::c_ulong).wrapping_add((*emitter).anchor_data.anchor_length)
                as size_t as size_t;
        }
        6 => {
            if (*emitter).scalar_data.multiline != 0 {
                return 0 as libc::c_int;
            }
            length = (length as libc::c_ulong).wrapping_add(
                ((*emitter).anchor_data.anchor_length)
                    .wrapping_add((*emitter).tag_data.handle_length)
                    .wrapping_add((*emitter).tag_data.suffix_length)
                    .wrapping_add((*emitter).scalar_data.length),
            ) as size_t as size_t;
        }
        7 => {
            if yaml_emitter_check_empty_sequence(emitter) == 0 {
                return 0 as libc::c_int;
            }
            length = (length as libc::c_ulong).wrapping_add(
                ((*emitter).anchor_data.anchor_length)
                    .wrapping_add((*emitter).tag_data.handle_length)
                    .wrapping_add((*emitter).tag_data.suffix_length),
            ) as size_t as size_t;
        }
        9 => {
            if yaml_emitter_check_empty_mapping(emitter) == 0 {
                return 0 as libc::c_int;
            }
            length = (length as libc::c_ulong).wrapping_add(
                ((*emitter).anchor_data.anchor_length)
                    .wrapping_add((*emitter).tag_data.handle_length)
                    .wrapping_add((*emitter).tag_data.suffix_length),
            ) as size_t as size_t;
        }
        _ => return 0 as libc::c_int,
    }
    if length > 128 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_select_scalar_style(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut style: yaml_scalar_style_t = (*event).data.scalar.style;
    let mut no_tag: libc::c_int = (((*emitter).tag_data.handle).is_null()
        && ((*emitter).tag_data.suffix).is_null()) as libc::c_int;
    if no_tag != 0
        && (*event).data.scalar.plain_implicit == 0
        && (*event).data.scalar.quoted_implicit == 0
    {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"neither tag nor implicit flags are specified\0" as *const u8 as *const libc::c_char,
        );
    }
    if style as libc::c_uint == YAML_ANY_SCALAR_STYLE as libc::c_int as libc::c_uint {
        style = YAML_PLAIN_SCALAR_STYLE;
    }
    if (*emitter).canonical != 0 {
        style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
    }
    if (*emitter).simple_key_context != 0 && (*emitter).scalar_data.multiline != 0 {
        style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
    }
    if style as libc::c_uint == YAML_PLAIN_SCALAR_STYLE as libc::c_int as libc::c_uint {
        if (*emitter).flow_level != 0 && (*emitter).scalar_data.flow_plain_allowed == 0
            || (*emitter).flow_level == 0 && (*emitter).scalar_data.block_plain_allowed == 0
        {
            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
        }
        if (*emitter).scalar_data.length == 0
            && ((*emitter).flow_level != 0 || (*emitter).simple_key_context != 0)
        {
            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
        }
        if no_tag != 0 && (*event).data.scalar.plain_implicit == 0 {
            style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
        }
    }
    if style as libc::c_uint == YAML_SINGLE_QUOTED_SCALAR_STYLE as libc::c_int as libc::c_uint {
        if (*emitter).scalar_data.single_quoted_allowed == 0 {
            style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
        }
    }
    if style as libc::c_uint == YAML_LITERAL_SCALAR_STYLE as libc::c_int as libc::c_uint
        || style as libc::c_uint == YAML_FOLDED_SCALAR_STYLE as libc::c_int as libc::c_uint
    {
        if (*emitter).scalar_data.block_allowed == 0
            || (*emitter).flow_level != 0
            || (*emitter).simple_key_context != 0
        {
            style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
        }
    }
    if no_tag != 0
        && (*event).data.scalar.quoted_implicit == 0
        && style as libc::c_uint != YAML_PLAIN_SCALAR_STYLE as libc::c_int as libc::c_uint
    {
        (*emitter).tag_data.handle = b"!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t;
        (*emitter).tag_data.handle_length = 1 as libc::c_int as size_t;
    }
    (*emitter).scalar_data.style = style;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_process_anchor(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    if ((*emitter).anchor_data.anchor).is_null() {
        return 1 as libc::c_int;
    }
    if yaml_emitter_write_indicator(
        emitter,
        if (*emitter).anchor_data.alias != 0 {
            b"*\0" as *const u8 as *const libc::c_char
        } else {
            b"&\0" as *const u8 as *const libc::c_char
        },
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    return yaml_emitter_write_anchor(
        emitter,
        (*emitter).anchor_data.anchor,
        (*emitter).anchor_data.anchor_length,
    );
}
unsafe extern "C" fn yaml_emitter_process_tag(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    if ((*emitter).tag_data.handle).is_null() && ((*emitter).tag_data.suffix).is_null() {
        return 1 as libc::c_int;
    }
    if !((*emitter).tag_data.handle).is_null() {
        if yaml_emitter_write_tag_handle(
            emitter,
            (*emitter).tag_data.handle,
            (*emitter).tag_data.handle_length,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if !((*emitter).tag_data.suffix).is_null() {
            if yaml_emitter_write_tag_content(
                emitter,
                (*emitter).tag_data.suffix,
                (*emitter).tag_data.suffix_length,
                0 as libc::c_int,
            ) == 0
            {
                return 0 as libc::c_int;
            }
        }
    } else {
        if yaml_emitter_write_indicator(
            emitter,
            b"!<\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if yaml_emitter_write_tag_content(
            emitter,
            (*emitter).tag_data.suffix,
            (*emitter).tag_data.suffix_length,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if yaml_emitter_write_indicator(
            emitter,
            b">\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_process_scalar(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    match (*emitter).scalar_data.style as libc::c_uint {
        1 => {
            return yaml_emitter_write_plain_scalar(
                emitter,
                (*emitter).scalar_data.value,
                (*emitter).scalar_data.length,
                ((*emitter).simple_key_context == 0) as libc::c_int,
            );
        }
        2 => {
            return yaml_emitter_write_single_quoted_scalar(
                emitter,
                (*emitter).scalar_data.value,
                (*emitter).scalar_data.length,
                ((*emitter).simple_key_context == 0) as libc::c_int,
            );
        }
        3 => {
            return yaml_emitter_write_double_quoted_scalar(
                emitter,
                (*emitter).scalar_data.value,
                (*emitter).scalar_data.length,
                ((*emitter).simple_key_context == 0) as libc::c_int,
            );
        }
        4 => {
            return yaml_emitter_write_literal_scalar(
                emitter,
                (*emitter).scalar_data.value,
                (*emitter).scalar_data.length,
            );
        }
        5 => {
            return yaml_emitter_write_folded_scalar(
                emitter,
                (*emitter).scalar_data.value,
                (*emitter).scalar_data.length,
            );
        }
        _ => {
            'c_68394: {};
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_version_directive(
    mut emitter: *mut yaml_emitter_t,
    mut version_directive: yaml_version_directive_t,
) -> libc::c_int {
    if version_directive.major != 1 as libc::c_int
        || version_directive.minor != 1 as libc::c_int
            && version_directive.minor != 2 as libc::c_int
    {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"incompatible %YAML directive\0" as *const u8 as *const libc::c_char,
        );
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_tag_directive(
    mut emitter: *mut yaml_emitter_t,
    mut tag_directive: yaml_tag_directive_t,
) -> libc::c_int {
    let mut handle: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut prefix: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut handle_length: size_t = 0;
    let mut prefix_length: size_t = 0;
    handle_length = strlen(tag_directive.handle as *mut libc::c_char);
    prefix_length = strlen(tag_directive.prefix as *mut libc::c_char);
    handle.start = tag_directive.handle;
    handle.end = (tag_directive.handle).offset(handle_length as isize);
    handle.pointer = tag_directive.handle;
    prefix.start = tag_directive.prefix;
    prefix.end = (tag_directive.prefix).offset(prefix_length as isize);
    prefix.pointer = tag_directive.prefix;
    if handle.start == handle.end {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"tag handle must not be empty\0" as *const u8 as *const libc::c_char,
        );
    }
    if *(handle.start).offset(0 as libc::c_int as isize) as libc::c_int != '!' as i32 {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"tag handle must start with '!'\0" as *const u8 as *const libc::c_char,
        );
    }
    if *(handle.end).offset(-(1 as libc::c_int) as isize) as libc::c_int != '!' as i32 {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"tag handle must end with '!'\0" as *const u8 as *const libc::c_char,
        );
    }
    handle.pointer = (handle.pointer).offset(1);
    handle.pointer;
    while handle.pointer < (handle.end).offset(-(1 as libc::c_int as isize)) {
        if !(*(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            >= '0' as i32 as yaml_char_t as libc::c_int
            && *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                <= '9' as i32 as yaml_char_t as libc::c_int
            || *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'A' as i32 as yaml_char_t as libc::c_int
                && *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'Z' as i32 as yaml_char_t as libc::c_int
            || *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'a' as i32 as yaml_char_t as libc::c_int
                && *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'z' as i32 as yaml_char_t as libc::c_int
            || *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '_' as i32
            || *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32)
        {
            return yaml_emitter_set_emitter_error(
                emitter,
                b"tag handle must contain alphanumerical characters only\0" as *const u8
                    as *const libc::c_char,
            );
        }
        handle.pointer = (handle.pointer).offset(
            (if *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else if *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else if *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf0 as libc::c_int
                == 0xe0 as libc::c_int
            {
                3 as libc::c_int
            } else if *(handle.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf8 as libc::c_int
                == 0xf0 as libc::c_int
            {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        );
    }
    if prefix.start == prefix.end {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"tag prefix must not be empty\0" as *const u8 as *const libc::c_char,
        );
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_anchor(
    mut emitter: *mut yaml_emitter_t,
    mut anchor: *mut yaml_char_t,
    mut alias: libc::c_int,
) -> libc::c_int {
    let mut anchor_length: size_t = 0;
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    anchor_length = strlen(anchor as *mut libc::c_char);
    string.start = anchor;
    string.end = anchor.offset(anchor_length as isize);
    string.pointer = anchor;
    if string.start == string.end {
        return yaml_emitter_set_emitter_error(
            emitter,
            if alias != 0 {
                b"alias value must not be empty\0" as *const u8 as *const libc::c_char
            } else {
                b"anchor value must not be empty\0" as *const u8 as *const libc::c_char
            },
        );
    }
    while string.pointer != string.end {
        if !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            >= '0' as i32 as yaml_char_t as libc::c_int
            && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                <= '9' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'A' as i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'Z' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'a' as i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'z' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '_' as i32
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32)
        {
            return yaml_emitter_set_emitter_error(
                emitter,
                if alias != 0 {
                    b"alias value must contain alphanumerical characters only\0" as *const u8
                        as *const libc::c_char
                } else {
                    b"anchor value must contain alphanumerical characters only\0" as *const u8
                        as *const libc::c_char
                },
            );
        }
        string.pointer = (string.pointer).offset(
            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf0 as libc::c_int
                == 0xe0 as libc::c_int
            {
                3 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf8 as libc::c_int
                == 0xf0 as libc::c_int
            {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        );
    }
    (*emitter).anchor_data.anchor = string.start;
    (*emitter).anchor_data.anchor_length =
        (string.end).offset_from(string.start) as libc::c_long as size_t;
    (*emitter).anchor_data.alias = alias;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_tag(
    mut emitter: *mut yaml_emitter_t,
    mut tag: *mut yaml_char_t,
) -> libc::c_int {
    let mut tag_length: size_t = 0;
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    tag_length = strlen(tag as *mut libc::c_char);
    string.start = tag;
    string.end = tag.offset(tag_length as isize);
    string.pointer = tag;
    if string.start == string.end {
        return yaml_emitter_set_emitter_error(
            emitter,
            b"tag value must not be empty\0" as *const u8 as *const libc::c_char,
        );
    }
    tag_directive = (*emitter).tag_directives.start;
    while tag_directive != (*emitter).tag_directives.top {
        let mut prefix_length: size_t = strlen((*tag_directive).prefix as *mut libc::c_char);
        if prefix_length < (string.end).offset_from(string.start) as libc::c_long as size_t
            && strncmp(
                (*tag_directive).prefix as *mut libc::c_char,
                string.start as *mut libc::c_char,
                prefix_length,
            ) == 0 as libc::c_int
        {
            (*emitter).tag_data.handle = (*tag_directive).handle;
            (*emitter).tag_data.handle_length =
                strlen((*tag_directive).handle as *mut libc::c_char);
            (*emitter).tag_data.suffix = (string.start).offset(prefix_length as isize);
            (*emitter).tag_data.suffix_length = ((string.end).offset_from(string.start)
                as libc::c_long as libc::c_ulong)
                .wrapping_sub(prefix_length);
            return 1 as libc::c_int;
        }
        tag_directive = tag_directive.offset(1);
        tag_directive;
    }
    (*emitter).tag_data.suffix = string.start;
    (*emitter).tag_data.suffix_length =
        (string.end).offset_from(string.start) as libc::c_long as size_t;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut block_indicators: libc::c_int = 0 as libc::c_int;
    let mut flow_indicators: libc::c_int = 0 as libc::c_int;
    let mut line_breaks: libc::c_int = 0 as libc::c_int;
    let mut special_characters: libc::c_int = 0 as libc::c_int;
    let mut leading_space: libc::c_int = 0 as libc::c_int;
    let mut leading_break: libc::c_int = 0 as libc::c_int;
    let mut trailing_space: libc::c_int = 0 as libc::c_int;
    let mut trailing_break: libc::c_int = 0 as libc::c_int;
    let mut break_space: libc::c_int = 0 as libc::c_int;
    let mut space_break: libc::c_int = 0 as libc::c_int;
    let mut preceded_by_whitespace: libc::c_int = 0 as libc::c_int;
    let mut followed_by_whitespace: libc::c_int = 0 as libc::c_int;
    let mut previous_space: libc::c_int = 0 as libc::c_int;
    let mut previous_break: libc::c_int = 0 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    (*emitter).scalar_data.value = value;
    (*emitter).scalar_data.length = length;
    if string.start == string.end {
        (*emitter).scalar_data.multiline = 0 as libc::c_int;
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_plain_allowed = 1 as libc::c_int;
        (*emitter).scalar_data.single_quoted_allowed = 1 as libc::c_int;
        (*emitter).scalar_data.block_allowed = 0 as libc::c_int;
        return 1 as libc::c_int;
    }
    if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '-' as i32 as yaml_char_t as libc::c_int
        && *(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        && *(string.pointer).offset(2 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '.' as i32 as yaml_char_t as libc::c_int
            && *(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == '.' as i32 as yaml_char_t as libc::c_int
            && *(string.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                == '.' as i32 as yaml_char_t as libc::c_int
    {
        block_indicators = 1 as libc::c_int;
        flow_indicators = 1 as libc::c_int;
    }
    preceded_by_whitespace = 1 as libc::c_int;
    followed_by_whitespace = (*(string.pointer).offset(
        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    ) as libc::c_int
        == ' ' as i32 as yaml_char_t as libc::c_int
        || *(string.pointer).offset(
            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        ) as libc::c_int
            == '\t' as i32 as yaml_char_t as libc::c_int
        || (*(string.pointer).offset(
            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        ) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(
                    ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) + 1 as libc::c_int) as isize,
                ) as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(
                    ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) + 1 as libc::c_int) as isize,
                ) as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(
                    ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) + 2 as libc::c_int) as isize,
                ) as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(
                    ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) + 1 as libc::c_int) as isize,
                ) as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(
                    ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) + 2 as libc::c_int) as isize,
                ) as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == '\0' as i32 as yaml_char_t as libc::c_int))
        as libc::c_int;
    while string.pointer != string.end {
        if string.start == string.pointer {
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '#' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ',' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '[' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ']' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '{' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '}' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '&' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '*' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '!' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '|' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '>' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\'' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '"' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '%' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '@' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '`' as i32 as yaml_char_t as libc::c_int
            {
                flow_indicators = 1 as libc::c_int;
                block_indicators = 1 as libc::c_int;
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '?' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ':' as i32 as yaml_char_t as libc::c_int
            {
                flow_indicators = 1 as libc::c_int;
                if followed_by_whitespace != 0 {
                    block_indicators = 1 as libc::c_int;
                }
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '-' as i32 as yaml_char_t as libc::c_int
                && followed_by_whitespace != 0
            {
                flow_indicators = 1 as libc::c_int;
                block_indicators = 1 as libc::c_int;
            }
        } else {
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ',' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '?' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '[' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ']' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '{' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '}' as i32 as yaml_char_t as libc::c_int
            {
                flow_indicators = 1 as libc::c_int;
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ':' as i32 as yaml_char_t as libc::c_int
            {
                flow_indicators = 1 as libc::c_int;
                if followed_by_whitespace != 0 {
                    block_indicators = 1 as libc::c_int;
                }
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '#' as i32 as yaml_char_t as libc::c_int
                && preceded_by_whitespace != 0
            {
                flow_indicators = 1 as libc::c_int;
                block_indicators = 1 as libc::c_int;
            }
        }
        if !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == 0xa as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 0x20 as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 0x7e as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xc2 as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    >= 0xa0 as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                > 0xc2 as libc::c_int
                && (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int)
                    < 0xed as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xed as libc::c_int
                && (*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int)
                    < 0xa0 as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xee as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xef as libc::c_int
                && !(*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == 0xbb as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == 0xbf as libc::c_int)
                && !(*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == 0xbf as libc::c_int
                    && (*(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == 0xbe as libc::c_int
                        || *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == 0xbf as libc::c_int)))
            || !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                <= '\u{7f}' as i32 as yaml_char_t as libc::c_int)
                && (*emitter).unicode == 0
        {
            special_characters = 1 as libc::c_int;
        }
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            line_breaks = 1 as libc::c_int;
        }
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
        {
            if string.start == string.pointer {
                leading_space = 1 as libc::c_int;
            }
            if (string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) == string.end
            {
                trailing_space = 1 as libc::c_int;
            }
            if previous_break != 0 {
                break_space = 1 as libc::c_int;
            }
            previous_space = 1 as libc::c_int;
            previous_break = 0 as libc::c_int;
        } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            if string.start == string.pointer {
                leading_break = 1 as libc::c_int;
            }
            if (string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) == string.end
            {
                trailing_break = 1 as libc::c_int;
            }
            if previous_space != 0 {
                space_break = 1 as libc::c_int;
            }
            previous_space = 0 as libc::c_int;
            previous_break = 1 as libc::c_int;
        } else {
            previous_space = 0 as libc::c_int;
            previous_break = 0 as libc::c_int;
        }
        preceded_by_whitespace =
            (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
                || (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '\0' as i32 as yaml_char_t as libc::c_int)) as libc::c_int;
        string.pointer = (string.pointer).offset(
            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf0 as libc::c_int
                == 0xe0 as libc::c_int
            {
                3 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf8 as libc::c_int
                == 0xf0 as libc::c_int
            {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            }) as isize,
        );
        if string.pointer != string.end {
            followed_by_whitespace = (*(string.pointer).offset(
                (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            ) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                ) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
                || (*(string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                ) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    ) as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    ) as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset(
                            ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *(string.pointer).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) + 1 as libc::c_int) as isize,
                        ) as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    ) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset(
                            ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *(string.pointer).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) + 1 as libc::c_int) as isize,
                        ) as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset(
                            ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *(string.pointer).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) + 2 as libc::c_int) as isize,
                        ) as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    ) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset(
                            ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *(string.pointer).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) + 1 as libc::c_int) as isize,
                        ) as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset(
                            ((if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *(string.pointer).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) + 2 as libc::c_int) as isize,
                        ) as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(
                        (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *(string.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *(string.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    ) as libc::c_int
                        == '\0' as i32 as yaml_char_t as libc::c_int))
                as libc::c_int;
        }
    }
    (*emitter).scalar_data.multiline = line_breaks;
    (*emitter).scalar_data.flow_plain_allowed = 1 as libc::c_int;
    (*emitter).scalar_data.block_plain_allowed = 1 as libc::c_int;
    (*emitter).scalar_data.single_quoted_allowed = 1 as libc::c_int;
    (*emitter).scalar_data.block_allowed = 1 as libc::c_int;
    if leading_space != 0 || leading_break != 0 || trailing_space != 0 || trailing_break != 0 {
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_plain_allowed = 0 as libc::c_int;
    }
    if trailing_space != 0 {
        (*emitter).scalar_data.block_allowed = 0 as libc::c_int;
    }
    if break_space != 0 {
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.single_quoted_allowed = 0 as libc::c_int;
    }
    if space_break != 0 || special_characters != 0 {
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.single_quoted_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_allowed = 0 as libc::c_int;
    }
    if line_breaks != 0 {
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
        (*emitter).scalar_data.block_plain_allowed = 0 as libc::c_int;
    }
    if flow_indicators != 0 {
        (*emitter).scalar_data.flow_plain_allowed = 0 as libc::c_int;
    }
    if block_indicators != 0 {
        (*emitter).scalar_data.block_plain_allowed = 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_analyze_event(
    mut emitter: *mut yaml_emitter_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    (*emitter).anchor_data.anchor = 0 as *mut yaml_char_t;
    (*emitter).anchor_data.anchor_length = 0 as libc::c_int as size_t;
    (*emitter).tag_data.handle = 0 as *mut yaml_char_t;
    (*emitter).tag_data.handle_length = 0 as libc::c_int as size_t;
    (*emitter).tag_data.suffix = 0 as *mut yaml_char_t;
    (*emitter).tag_data.suffix_length = 0 as libc::c_int as size_t;
    (*emitter).scalar_data.value = 0 as *mut yaml_char_t;
    (*emitter).scalar_data.length = 0 as libc::c_int as size_t;
    match (*event).type_0 as libc::c_uint {
        5 => {
            if yaml_emitter_analyze_anchor(emitter, (*event).data.alias.anchor, 1 as libc::c_int)
                == 0
            {
                return 0 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
        6 => {
            if !((*event).data.scalar.anchor).is_null() {
                if yaml_emitter_analyze_anchor(
                    emitter,
                    (*event).data.scalar.anchor,
                    0 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
            }
            if !((*event).data.scalar.tag).is_null()
                && ((*emitter).canonical != 0
                    || (*event).data.scalar.plain_implicit == 0
                        && (*event).data.scalar.quoted_implicit == 0)
            {
                if yaml_emitter_analyze_tag(emitter, (*event).data.scalar.tag) == 0 {
                    return 0 as libc::c_int;
                }
            }
            if yaml_emitter_analyze_scalar(
                emitter,
                (*event).data.scalar.value,
                (*event).data.scalar.length,
            ) == 0
            {
                return 0 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
        7 => {
            if !((*event).data.sequence_start.anchor).is_null() {
                if yaml_emitter_analyze_anchor(
                    emitter,
                    (*event).data.sequence_start.anchor,
                    0 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
            }
            if !((*event).data.sequence_start.tag).is_null()
                && ((*emitter).canonical != 0 || (*event).data.sequence_start.implicit == 0)
            {
                if yaml_emitter_analyze_tag(emitter, (*event).data.sequence_start.tag) == 0 {
                    return 0 as libc::c_int;
                }
            }
            return 1 as libc::c_int;
        }
        9 => {
            if !((*event).data.mapping_start.anchor).is_null() {
                if yaml_emitter_analyze_anchor(
                    emitter,
                    (*event).data.mapping_start.anchor,
                    0 as libc::c_int,
                ) == 0
                {
                    return 0 as libc::c_int;
                }
            }
            if !((*event).data.mapping_start.tag).is_null()
                && ((*emitter).canonical != 0 || (*event).data.mapping_start.implicit == 0)
            {
                if yaml_emitter_analyze_tag(emitter, (*event).data.mapping_start.tag) == 0 {
                    return 0 as libc::c_int;
                }
            }
            return 1 as libc::c_int;
        }
        _ => return 1 as libc::c_int,
    };
}
unsafe extern "C" fn yaml_emitter_write_bom(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    if !(((*emitter).buffer.pointer).offset(5 as libc::c_int as isize) < (*emitter).buffer.end
        || yaml_emitter_flush(emitter) != 0)
    {
        return 0 as libc::c_int;
    }
    let fresh26 = (*emitter).buffer.pointer;
    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
    *fresh26 = -17i32 as yaml_char_t;
    let fresh27 = (*emitter).buffer.pointer;
    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
    *fresh27 = -69i32 as yaml_char_t;
    let fresh28 = (*emitter).buffer.pointer;
    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
    *fresh28 = -65i32 as yaml_char_t;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_indent(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    let mut indent: libc::c_int = if (*emitter).indent >= 0 as libc::c_int {
        (*emitter).indent
    } else {
        0 as libc::c_int
    };
    if (*emitter).indention == 0
        || (*emitter).column > indent
        || (*emitter).column == indent && (*emitter).whitespace == 0
    {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                if (*emitter).line_break as libc::c_uint
                    == YAML_CR_BREAK as libc::c_int as libc::c_uint
                {
                    let fresh29 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh29 = '\r' as i32 as yaml_char_t;
                } else {
                    if (*emitter).line_break as libc::c_uint
                        == YAML_LN_BREAK as libc::c_int as libc::c_uint
                    {
                        let fresh30 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh30 = '\n' as i32 as yaml_char_t;
                    } else {
                        if (*emitter).line_break as libc::c_uint
                            == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                        {
                            let fresh31 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh31 = '\r' as i32 as yaml_char_t;
                            let fresh32 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh32 = '\n' as i32 as yaml_char_t;
                        } else {
                        };
                    };
                };
                (*emitter).column = 0 as libc::c_int;
                (*emitter).line += 1;
                (*emitter).line;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    while (*emitter).column < indent {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh33 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh33 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).whitespace = 1 as libc::c_int;
    (*emitter).indention = 1 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_indicator(
    mut emitter: *mut yaml_emitter_t,
    mut indicator: *const libc::c_char,
    mut need_whitespace: libc::c_int,
    mut is_whitespace: libc::c_int,
    mut is_indention: libc::c_int,
) -> libc::c_int {
    let mut indicator_length: size_t = 0;
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    indicator_length = strlen(indicator);
    string.start = indicator as *mut yaml_char_t;
    string.end = (indicator as *mut yaml_char_t).offset(indicator_length as isize);
    string.pointer = indicator as *mut yaml_char_t;
    if need_whitespace != 0 && (*emitter).whitespace == 0 {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh34 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh34 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    while string.pointer != string.end {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                    let fresh35 = string.pointer;
                    string.pointer = (string.pointer).offset(1);
                    let fresh36 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh36 = *fresh35;
                } else {
                    if *string.pointer as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                        let fresh37 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh38 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh38 = *fresh37;
                        let fresh39 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh40 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh40 = *fresh39;
                    } else {
                        if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            let fresh41 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh42 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh42 = *fresh41;
                            let fresh43 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh44 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh44 = *fresh43;
                            let fresh45 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh46 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh46 = *fresh45;
                        } else {
                            if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                let fresh47 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh48 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh48 = *fresh47;
                                let fresh49 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh50 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh50 = *fresh49;
                                let fresh51 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh52 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh52 = *fresh51;
                                let fresh53 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh54 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh54 = *fresh53;
                            } else {
                            };
                        };
                    };
                };
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).whitespace = is_whitespace;
    (*emitter).indention = ((*emitter).indention != 0 && is_indention != 0) as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_anchor(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    while string.pointer != string.end {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                    let fresh55 = string.pointer;
                    string.pointer = (string.pointer).offset(1);
                    let fresh56 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh56 = *fresh55;
                } else {
                    if *string.pointer as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                        let fresh57 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh58 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh58 = *fresh57;
                        let fresh59 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh60 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh60 = *fresh59;
                    } else {
                        if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            let fresh61 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh62 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh62 = *fresh61;
                            let fresh63 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh64 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh64 = *fresh63;
                            let fresh65 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh66 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh66 = *fresh65;
                        } else {
                            if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                let fresh67 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh68 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh68 = *fresh67;
                                let fresh69 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh70 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh70 = *fresh69;
                                let fresh71 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh72 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh72 = *fresh71;
                                let fresh73 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh74 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh74 = *fresh73;
                            } else {
                            };
                        };
                    };
                };
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_tag_handle(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if (*emitter).whitespace == 0 {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh75 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh75 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    while string.pointer != string.end {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                    let fresh76 = string.pointer;
                    string.pointer = (string.pointer).offset(1);
                    let fresh77 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh77 = *fresh76;
                } else {
                    if *string.pointer as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                        let fresh78 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh79 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh79 = *fresh78;
                        let fresh80 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh81 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh81 = *fresh80;
                    } else {
                        if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            let fresh82 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh83 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh83 = *fresh82;
                            let fresh84 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh85 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh85 = *fresh84;
                            let fresh86 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh87 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh87 = *fresh86;
                        } else {
                            if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                let fresh88 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh89 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh89 = *fresh88;
                                let fresh90 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh91 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh91 = *fresh90;
                                let fresh92 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh93 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh93 = *fresh92;
                                let fresh94 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh95 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh95 = *fresh94;
                            } else {
                            };
                        };
                    };
                };
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_tag_content(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
    mut need_whitespace: libc::c_int,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if need_whitespace != 0 && (*emitter).whitespace == 0 {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh96 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh96 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    while string.pointer != string.end {
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            >= '0' as i32 as yaml_char_t as libc::c_int
            && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                <= '9' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'A' as i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'Z' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 'a' as i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 'z' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '_' as i32
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ';' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '/' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '?' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ':' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '@' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '&' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '=' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '+' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '$' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ',' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '_' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '.' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '~' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '*' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\'' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '(' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ')' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '[' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ']' as i32 as yaml_char_t as libc::c_int
        {
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh97 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh98 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh98 = *fresh97;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh99 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh100 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh100 = *fresh99;
                            let fresh101 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh102 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh102 = *fresh101;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh103 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh104 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh104 = *fresh103;
                                let fresh105 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh106 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh106 = *fresh105;
                                let fresh107 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh108 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh108 = *fresh107;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh109 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh110 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh110 = *fresh109;
                                    let fresh111 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh112 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh112 = *fresh111;
                                    let fresh113 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh114 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh114 = *fresh113;
                                    let fresh115 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh116 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh116 = *fresh115;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
        } else {
            let mut width: libc::c_int = if *(string.pointer).offset(0 as libc::c_int as isize)
                as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf0 as libc::c_int
                == 0xe0 as libc::c_int
            {
                3 as libc::c_int
            } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xf8 as libc::c_int
                == 0xf0 as libc::c_int
            {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            };
            let mut value_0: libc::c_uint = 0;
            loop {
                let fresh117 = width;
                width = width - 1;
                if !(fresh117 != 0) {
                    break;
                }
                let fresh118 = string.pointer;
                string.pointer = (string.pointer).offset(1);
                value_0 = *fresh118 as libc::c_uint;
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        let fresh119 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh119 = '%' as i32 as yaml_char_t;
                        (*emitter).column += 1;
                        (*emitter).column;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        let fresh120 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh120 = (value_0 >> 4 as libc::c_int).wrapping_add(
                            (if (value_0 >> 4 as libc::c_int) < 10 as libc::c_int as libc::c_uint {
                                '0' as i32
                            } else {
                                'A' as i32 - 10 as libc::c_int
                            }) as libc::c_uint,
                        ) as yaml_char_t;
                        (*emitter).column += 1;
                        (*emitter).column;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        let fresh121 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh121 = (value_0 & 0xf as libc::c_int as libc::c_uint).wrapping_add(
                            (if (value_0 & 0xf as libc::c_int as libc::c_uint)
                                < 10 as libc::c_int as libc::c_uint
                            {
                                '0' as i32
                            } else {
                                'A' as i32 - 10 as libc::c_int
                            }) as libc::c_uint,
                        ) as yaml_char_t;
                        (*emitter).column += 1;
                        (*emitter).column;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
            }
        }
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_plain_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
    mut allow_breaks: libc::c_int,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut spaces: libc::c_int = 0 as libc::c_int;
    let mut breaks: libc::c_int = 0 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if (*emitter).whitespace == 0 && (length != 0 || (*emitter).flow_level != 0) {
        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
            < (*emitter).buffer.end
            || yaml_emitter_flush(emitter) != 0)
            && {
                let fresh122 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh122 = ' ' as i32 as yaml_char_t;
                (*emitter).column += 1;
                (*emitter).column;
                1 as libc::c_int != 0
            })
        {
            return 0 as libc::c_int;
        }
    }
    while string.pointer != string.end {
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
        {
            if allow_breaks != 0
                && spaces == 0
                && (*emitter).column > (*emitter).best_width
                && !(*(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int)
            {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                string.pointer = (string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as isize,
                );
            } else if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh123 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh124 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh124 = *fresh123;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh125 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh126 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh126 = *fresh125;
                            let fresh127 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh128 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh128 = *fresh127;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh129 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh130 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh130 = *fresh129;
                                let fresh131 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh132 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh132 = *fresh131;
                                let fresh133 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh134 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh134 = *fresh133;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh135 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh136 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh136 = *fresh135;
                                    let fresh137 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh138 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh138 = *fresh137;
                                    let fresh139 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh140 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh140 = *fresh139;
                                    let fresh141 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh142 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh142 = *fresh141;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            spaces = 1 as libc::c_int;
        } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            if breaks == 0
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
            {
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        if (*emitter).line_break as libc::c_uint
                            == YAML_CR_BREAK as libc::c_int as libc::c_uint
                        {
                            let fresh143 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh143 = '\r' as i32 as yaml_char_t;
                        } else {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_LN_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh144 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh144 = '\n' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh145 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh145 = '\r' as i32 as yaml_char_t;
                                    let fresh146 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh146 = '\n' as i32 as yaml_char_t;
                                } else {
                                };
                            };
                        };
                        (*emitter).column = 0 as libc::c_int;
                        (*emitter).line += 1;
                        (*emitter).line;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                {
                    ((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_CR_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh147 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh147 = '\r' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh148 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh148 = '\n' as i32 as yaml_char_t;
                                } else {
                                    if (*emitter).line_break as libc::c_uint
                                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                    {
                                        let fresh149 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh149 = '\r' as i32 as yaml_char_t;
                                        let fresh150 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh150 = '\n' as i32 as yaml_char_t;
                                    } else {
                                    };
                                };
                            };
                            (*emitter).column = 0 as libc::c_int;
                            (*emitter).line += 1;
                            (*emitter).line;
                            1 as libc::c_int != 0
                        }) as libc::c_int;
                    string.pointer = (string.pointer).offset(1);
                    string.pointer;
                    1 as libc::c_int
                } else {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh151 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh152 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh152 = *fresh151;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh153 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh154 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh154 = *fresh153;
                            let fresh155 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh156 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh156 = *fresh155;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh157 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh158 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh158 = *fresh157;
                                let fresh159 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh160 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh160 = *fresh159;
                                let fresh161 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh162 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh162 = *fresh161;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh163 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh164 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh164 = *fresh163;
                                    let fresh165 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh166 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh166 = *fresh165;
                                    let fresh167 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh168 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh168 = *fresh167;
                                    let fresh169 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh170 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh170 = *fresh169;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column = 0 as libc::c_int;
                    (*emitter).line += 1;
                    (*emitter).line;
                    1 as libc::c_int
                }) != 0)
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 1 as libc::c_int;
            breaks = 1 as libc::c_int;
        } else {
            if breaks != 0 {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh171 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh172 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh172 = *fresh171;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh173 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh174 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh174 = *fresh173;
                            let fresh175 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh176 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh176 = *fresh175;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh177 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh178 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh178 = *fresh177;
                                let fresh179 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh180 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh180 = *fresh179;
                                let fresh181 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh182 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh182 = *fresh181;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh183 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh184 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh184 = *fresh183;
                                    let fresh185 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh186 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh186 = *fresh185;
                                    let fresh187 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh188 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh188 = *fresh187;
                                    let fresh189 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh190 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh190 = *fresh189;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 0 as libc::c_int;
            spaces = 0 as libc::c_int;
            breaks = 0 as libc::c_int;
        }
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_single_quoted_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
    mut allow_breaks: libc::c_int,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut spaces: libc::c_int = 0 as libc::c_int;
    let mut breaks: libc::c_int = 0 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if yaml_emitter_write_indicator(
        emitter,
        b"'\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    while string.pointer != string.end {
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
        {
            if allow_breaks != 0
                && spaces == 0
                && (*emitter).column > (*emitter).best_width
                && string.pointer != string.start
                && string.pointer != (string.end).offset(-(1 as libc::c_int as isize))
                && !(*(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int)
            {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                string.pointer = (string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as isize,
                );
            } else if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh191 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh192 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh192 = *fresh191;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh193 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh194 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh194 = *fresh193;
                            let fresh195 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh196 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh196 = *fresh195;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh197 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh198 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh198 = *fresh197;
                                let fresh199 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh200 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh200 = *fresh199;
                                let fresh201 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh202 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh202 = *fresh201;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh203 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh204 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh204 = *fresh203;
                                    let fresh205 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh206 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh206 = *fresh205;
                                    let fresh207 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh208 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh208 = *fresh207;
                                    let fresh209 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh210 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh210 = *fresh209;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            spaces = 1 as libc::c_int;
        } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            if breaks == 0
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
            {
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        if (*emitter).line_break as libc::c_uint
                            == YAML_CR_BREAK as libc::c_int as libc::c_uint
                        {
                            let fresh211 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh211 = '\r' as i32 as yaml_char_t;
                        } else {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_LN_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh212 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh212 = '\n' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh213 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh213 = '\r' as i32 as yaml_char_t;
                                    let fresh214 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh214 = '\n' as i32 as yaml_char_t;
                                } else {
                                };
                            };
                        };
                        (*emitter).column = 0 as libc::c_int;
                        (*emitter).line += 1;
                        (*emitter).line;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                {
                    ((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_CR_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh215 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh215 = '\r' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh216 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh216 = '\n' as i32 as yaml_char_t;
                                } else {
                                    if (*emitter).line_break as libc::c_uint
                                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                    {
                                        let fresh217 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh217 = '\r' as i32 as yaml_char_t;
                                        let fresh218 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh218 = '\n' as i32 as yaml_char_t;
                                    } else {
                                    };
                                };
                            };
                            (*emitter).column = 0 as libc::c_int;
                            (*emitter).line += 1;
                            (*emitter).line;
                            1 as libc::c_int != 0
                        }) as libc::c_int;
                    string.pointer = (string.pointer).offset(1);
                    string.pointer;
                    1 as libc::c_int
                } else {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh219 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh220 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh220 = *fresh219;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh221 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh222 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh222 = *fresh221;
                            let fresh223 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh224 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh224 = *fresh223;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh225 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh226 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh226 = *fresh225;
                                let fresh227 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh228 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh228 = *fresh227;
                                let fresh229 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh230 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh230 = *fresh229;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh231 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh232 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh232 = *fresh231;
                                    let fresh233 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh234 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh234 = *fresh233;
                                    let fresh235 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh236 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh236 = *fresh235;
                                    let fresh237 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh238 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh238 = *fresh237;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column = 0 as libc::c_int;
                    (*emitter).line += 1;
                    (*emitter).line;
                    1 as libc::c_int
                }) != 0)
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 1 as libc::c_int;
            breaks = 1 as libc::c_int;
        } else {
            if breaks != 0 {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\'' as i32 as yaml_char_t as libc::c_int
            {
                if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                    < (*emitter).buffer.end
                    || yaml_emitter_flush(emitter) != 0)
                    && {
                        let fresh239 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh239 = '\'' as i32 as yaml_char_t;
                        (*emitter).column += 1;
                        (*emitter).column;
                        1 as libc::c_int != 0
                    })
                {
                    return 0 as libc::c_int;
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh240 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh241 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh241 = *fresh240;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh242 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh243 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh243 = *fresh242;
                            let fresh244 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh245 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh245 = *fresh244;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh246 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh247 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh247 = *fresh246;
                                let fresh248 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh249 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh249 = *fresh248;
                                let fresh250 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh251 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh251 = *fresh250;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh252 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh253 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh253 = *fresh252;
                                    let fresh254 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh255 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh255 = *fresh254;
                                    let fresh256 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh257 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh257 = *fresh256;
                                    let fresh258 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh259 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh259 = *fresh258;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 0 as libc::c_int;
            spaces = 0 as libc::c_int;
            breaks = 0 as libc::c_int;
        }
    }
    if breaks != 0 {
        if yaml_emitter_write_indent(emitter) == 0 {
            return 0 as libc::c_int;
        }
    }
    if yaml_emitter_write_indicator(
        emitter,
        b"'\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_double_quoted_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
    mut allow_breaks: libc::c_int,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut spaces: libc::c_int = 0 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if yaml_emitter_write_indicator(
        emitter,
        b"\"\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    while string.pointer != string.end {
        if !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == 0xa as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                >= 0x20 as libc::c_int
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= 0x7e as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xc2 as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    >= 0xa0 as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                > 0xc2 as libc::c_int
                && (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int)
                    < 0xed as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xed as libc::c_int
                && (*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int)
                    < 0xa0 as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xee as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == 0xef as libc::c_int
                && !(*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == 0xbb as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == 0xbf as libc::c_int)
                && !(*(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == 0xbf as libc::c_int
                    && (*(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == 0xbe as libc::c_int
                        || *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == 0xbf as libc::c_int)))
            || (*emitter).unicode == 0
                && !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    <= '\u{7f}' as i32 as yaml_char_t as libc::c_int)
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -17i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -69i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -65i32 as yaml_char_t as libc::c_int
            || (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int)
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '"' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\\' as i32 as yaml_char_t as libc::c_int
        {
            let mut octet: libc::c_uchar = 0;
            let mut width: libc::c_uint = 0;
            let mut value_0: libc::c_uint = 0;
            let mut k: libc::c_int = 0;
            octet = *(string.pointer).offset(0 as libc::c_int as isize);
            width = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                2 as libc::c_int
            } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
                3 as libc::c_int
            } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uint;
            value_0 = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                octet as libc::c_int & 0x7f as libc::c_int
            } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                octet as libc::c_int & 0x1f as libc::c_int
            } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
                octet as libc::c_int & 0xf as libc::c_int
            } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
                octet as libc::c_int & 0x7 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uint;
            k = 1 as libc::c_int;
            while k < width as libc::c_int {
                octet = *(string.pointer).offset(k as isize);
                value_0 = (value_0 << 6 as libc::c_int)
                    .wrapping_add((octet as libc::c_int & 0x3f as libc::c_int) as libc::c_uint);
                k += 1;
                k;
            }
            string.pointer = (string.pointer).offset(width as isize);
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    let fresh260 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh260 = '\\' as i32 as yaml_char_t;
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            match value_0 {
                0 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh261 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh261 = '0' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                7 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh262 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh262 = 'a' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                8 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh263 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh263 = 'b' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                9 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh264 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh264 = 't' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                10 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh265 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh265 = 'n' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                11 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh266 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh266 = 'v' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                12 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh267 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh267 = 'f' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                13 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh268 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh268 = 'r' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                27 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh269 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh269 = 'e' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                34 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh270 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh270 = '"' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                92 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh271 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh271 = '\\' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                133 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh272 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh272 = 'N' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                160 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh273 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh273 = '_' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                8232 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh274 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh274 = 'L' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                8233 => {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh275 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh275 = 'P' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                _ => {
                    if value_0 <= 0xff as libc::c_int as libc::c_uint {
                        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                            < (*emitter).buffer.end
                            || yaml_emitter_flush(emitter) != 0)
                            && {
                                let fresh276 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh276 = 'x' as i32 as yaml_char_t;
                                (*emitter).column += 1;
                                (*emitter).column;
                                1 as libc::c_int != 0
                            })
                        {
                            return 0 as libc::c_int;
                        }
                        width = 2 as libc::c_int as libc::c_uint;
                    } else if value_0 <= 0xffff as libc::c_int as libc::c_uint {
                        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                            < (*emitter).buffer.end
                            || yaml_emitter_flush(emitter) != 0)
                            && {
                                let fresh277 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh277 = 'u' as i32 as yaml_char_t;
                                (*emitter).column += 1;
                                (*emitter).column;
                                1 as libc::c_int != 0
                            })
                        {
                            return 0 as libc::c_int;
                        }
                        width = 4 as libc::c_int as libc::c_uint;
                    } else {
                        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                            < (*emitter).buffer.end
                            || yaml_emitter_flush(emitter) != 0)
                            && {
                                let fresh278 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh278 = 'U' as i32 as yaml_char_t;
                                (*emitter).column += 1;
                                (*emitter).column;
                                1 as libc::c_int != 0
                            })
                        {
                            return 0 as libc::c_int;
                        }
                        width = 8 as libc::c_int as libc::c_uint;
                    }
                    k = width
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        .wrapping_mul(4 as libc::c_int as libc::c_uint)
                        as libc::c_int;
                    while k >= 0 as libc::c_int {
                        let mut digit: libc::c_int =
                            (value_0 >> k & 0xf as libc::c_int as libc::c_uint) as libc::c_int;
                        if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                            < (*emitter).buffer.end
                            || yaml_emitter_flush(emitter) != 0)
                            && {
                                let fresh279 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh279 = (digit
                                    + (if digit < 10 as libc::c_int {
                                        '0' as i32
                                    } else {
                                        'A' as i32 - 10 as libc::c_int
                                    })) as yaml_char_t;
                                (*emitter).column += 1;
                                (*emitter).column;
                                1 as libc::c_int != 0
                            })
                        {
                            return 0 as libc::c_int;
                        }
                        k -= 4 as libc::c_int;
                    }
                }
            }
            spaces = 0 as libc::c_int;
        } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
        {
            if allow_breaks != 0
                && spaces == 0
                && (*emitter).column > (*emitter).best_width
                && string.pointer != string.start
                && string.pointer != (string.end).offset(-(1 as libc::c_int as isize))
            {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                if *(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int
                {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            let fresh280 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh280 = '\\' as i32 as yaml_char_t;
                            (*emitter).column += 1;
                            (*emitter).column;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
                string.pointer = (string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as isize,
                );
            } else if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh281 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh282 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh282 = *fresh281;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh283 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh284 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh284 = *fresh283;
                            let fresh285 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh286 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh286 = *fresh285;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh287 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh288 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh288 = *fresh287;
                                let fresh289 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh290 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh290 = *fresh289;
                                let fresh291 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh292 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh292 = *fresh291;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh293 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh294 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh294 = *fresh293;
                                    let fresh295 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh296 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh296 = *fresh295;
                                    let fresh297 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh298 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh298 = *fresh297;
                                    let fresh299 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh300 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh300 = *fresh299;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            spaces = 1 as libc::c_int;
        } else {
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh301 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh302 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh302 = *fresh301;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh303 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh304 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh304 = *fresh303;
                            let fresh305 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh306 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh306 = *fresh305;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh307 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh308 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh308 = *fresh307;
                                let fresh309 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh310 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh310 = *fresh309;
                                let fresh311 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh312 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh312 = *fresh311;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh313 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh314 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh314 = *fresh313;
                                    let fresh315 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh316 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh316 = *fresh315;
                                    let fresh317 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh318 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh318 = *fresh317;
                                    let fresh319 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh320 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh320 = *fresh319;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            spaces = 0 as libc::c_int;
        }
    }
    if yaml_emitter_write_indicator(
        emitter,
        b"\"\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    (*emitter).whitespace = 0 as libc::c_int;
    (*emitter).indention = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_block_scalar_hints(
    mut emitter: *mut yaml_emitter_t,
    mut string: yaml_string_t,
) -> libc::c_int {
    let mut indent_hint: [libc::c_char; 2] = [0; 2];
    let mut chomp_hint: *const libc::c_char = 0 as *const libc::c_char;
    if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ' ' as i32 as yaml_char_t as libc::c_int
        || (*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int)
    {
        indent_hint[0 as libc::c_int as usize] =
            ('0' as i32 + (*emitter).best_indent as libc::c_char as libc::c_int) as libc::c_char;
        indent_hint[1 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
        if yaml_emitter_write_indicator(
            emitter,
            indent_hint.as_mut_ptr(),
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    (*emitter).open_ended = 0 as libc::c_int;
    string.pointer = string.end;
    if string.start == string.pointer {
        chomp_hint = b"-\0" as *const u8 as *const libc::c_char;
    } else {
        loop {
            string.pointer = (string.pointer).offset(-1);
            string.pointer;
            if !(*string.pointer as libc::c_int & 0xc0 as libc::c_int == 0x80 as libc::c_int) {
                break;
            }
        }
        if !(*(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int)
        {
            chomp_hint = b"-\0" as *const u8 as *const libc::c_char;
        } else if string.start == string.pointer {
            chomp_hint = b"+\0" as *const u8 as *const libc::c_char;
            (*emitter).open_ended = 2 as libc::c_int;
        } else {
            loop {
                string.pointer = (string.pointer).offset(-1);
                string.pointer;
                if !(*string.pointer as libc::c_int & 0xc0 as libc::c_int == 0x80 as libc::c_int) {
                    break;
                }
            }
            if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
            {
                chomp_hint = b"+\0" as *const u8 as *const libc::c_char;
                (*emitter).open_ended = 2 as libc::c_int;
            }
        }
    }
    if !chomp_hint.is_null() {
        if yaml_emitter_write_indicator(
            emitter,
            chomp_hint,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_literal_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut breaks: libc::c_int = 1 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if yaml_emitter_write_indicator(
        emitter,
        b"|\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    if yaml_emitter_write_block_scalar_hints(emitter, string) == 0 {
        return 0 as libc::c_int;
    }
    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize) < (*emitter).buffer.end
        || yaml_emitter_flush(emitter) != 0)
        && {
            if (*emitter).line_break as libc::c_uint == YAML_CR_BREAK as libc::c_int as libc::c_uint
            {
                let fresh321 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh321 = '\r' as i32 as yaml_char_t;
            } else {
                if (*emitter).line_break as libc::c_uint
                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                {
                    let fresh322 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh322 = '\n' as i32 as yaml_char_t;
                } else {
                    if (*emitter).line_break as libc::c_uint
                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                    {
                        let fresh323 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh323 = '\r' as i32 as yaml_char_t;
                        let fresh324 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh324 = '\n' as i32 as yaml_char_t;
                    } else {
                    };
                };
            };
            (*emitter).column = 0 as libc::c_int;
            (*emitter).line += 1;
            (*emitter).line;
            1 as libc::c_int != 0
        })
    {
        return 0 as libc::c_int;
    }
    (*emitter).indention = 1 as libc::c_int;
    (*emitter).whitespace = 1 as libc::c_int;
    while string.pointer != string.end {
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                {
                    ((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_CR_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh325 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh325 = '\r' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh326 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh326 = '\n' as i32 as yaml_char_t;
                                } else {
                                    if (*emitter).line_break as libc::c_uint
                                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                    {
                                        let fresh327 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh327 = '\r' as i32 as yaml_char_t;
                                        let fresh328 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh328 = '\n' as i32 as yaml_char_t;
                                    } else {
                                    };
                                };
                            };
                            (*emitter).column = 0 as libc::c_int;
                            (*emitter).line += 1;
                            (*emitter).line;
                            1 as libc::c_int != 0
                        }) as libc::c_int;
                    string.pointer = (string.pointer).offset(1);
                    string.pointer;
                    1 as libc::c_int
                } else {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh329 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh330 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh330 = *fresh329;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh331 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh332 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh332 = *fresh331;
                            let fresh333 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh334 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh334 = *fresh333;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh335 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh336 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh336 = *fresh335;
                                let fresh337 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh338 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh338 = *fresh337;
                                let fresh339 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh340 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh340 = *fresh339;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh341 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh342 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh342 = *fresh341;
                                    let fresh343 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh344 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh344 = *fresh343;
                                    let fresh345 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh346 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh346 = *fresh345;
                                    let fresh347 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh348 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh348 = *fresh347;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column = 0 as libc::c_int;
                    (*emitter).line += 1;
                    (*emitter).line;
                    1 as libc::c_int
                }) != 0)
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 1 as libc::c_int;
            breaks = 1 as libc::c_int;
        } else {
            if breaks != 0 {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh349 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh350 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh350 = *fresh349;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh351 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh352 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh352 = *fresh351;
                            let fresh353 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh354 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh354 = *fresh353;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh355 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh356 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh356 = *fresh355;
                                let fresh357 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh358 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh358 = *fresh357;
                                let fresh359 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh360 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh360 = *fresh359;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh361 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh362 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh362 = *fresh361;
                                    let fresh363 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh364 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh364 = *fresh363;
                                    let fresh365 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh366 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh366 = *fresh365;
                                    let fresh367 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh368 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh368 = *fresh367;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 0 as libc::c_int;
            breaks = 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_write_folded_scalar(
    mut emitter: *mut yaml_emitter_t,
    mut value: *mut yaml_char_t,
    mut length: size_t,
) -> libc::c_int {
    let mut string: yaml_string_t = yaml_string_t {
        start: 0 as *mut yaml_char_t,
        end: 0 as *mut yaml_char_t,
        pointer: 0 as *mut yaml_char_t,
    };
    let mut breaks: libc::c_int = 1 as libc::c_int;
    let mut leading_spaces: libc::c_int = 1 as libc::c_int;
    string.start = value;
    string.end = value.offset(length as isize);
    string.pointer = value;
    if yaml_emitter_write_indicator(
        emitter,
        b">\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    ) == 0
    {
        return 0 as libc::c_int;
    }
    if yaml_emitter_write_block_scalar_hints(emitter, string) == 0 {
        return 0 as libc::c_int;
    }
    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize) < (*emitter).buffer.end
        || yaml_emitter_flush(emitter) != 0)
        && {
            if (*emitter).line_break as libc::c_uint == YAML_CR_BREAK as libc::c_int as libc::c_uint
            {
                let fresh369 = (*emitter).buffer.pointer;
                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                *fresh369 = '\r' as i32 as yaml_char_t;
            } else {
                if (*emitter).line_break as libc::c_uint
                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                {
                    let fresh370 = (*emitter).buffer.pointer;
                    (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                    *fresh370 = '\n' as i32 as yaml_char_t;
                } else {
                    if (*emitter).line_break as libc::c_uint
                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                    {
                        let fresh371 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh371 = '\r' as i32 as yaml_char_t;
                        let fresh372 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh372 = '\n' as i32 as yaml_char_t;
                    } else {
                    };
                };
            };
            (*emitter).column = 0 as libc::c_int;
            (*emitter).line += 1;
            (*emitter).line;
            1 as libc::c_int != 0
        })
    {
        return 0 as libc::c_int;
    }
    (*emitter).indention = 1 as libc::c_int;
    (*emitter).whitespace = 1 as libc::c_int;
    while string.pointer != string.end {
        if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *(string.pointer).offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
        {
            if breaks == 0
                && leading_spaces == 0
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
            {
                let mut k: libc::c_int = 0 as libc::c_int;
                while *(string.pointer).offset(k as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(k as isize) as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(k as isize) as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((k + 1 as libc::c_int) as isize) as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(k as isize) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((k + 1 as libc::c_int) as isize) as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((k + 2 as libc::c_int) as isize) as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(k as isize) as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((k + 1 as libc::c_int) as isize) as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *(string.pointer).offset((k + 2 as libc::c_int) as isize) as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                {
                    k += if *(string.pointer).offset(k as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else if *(string.pointer).offset(k as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else if *(string.pointer).offset(k as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else if *(string.pointer).offset(k as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    };
                }
                if !(*(string.pointer).offset(k as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(k as isize) as libc::c_int
                        == '\t' as i32 as yaml_char_t as libc::c_int
                    || (*(string.pointer).offset(k as isize) as libc::c_int
                        == '\r' as i32 as yaml_char_t as libc::c_int
                        || *(string.pointer).offset(k as isize) as libc::c_int
                            == '\n' as i32 as yaml_char_t as libc::c_int
                        || *(string.pointer).offset(k as isize) as libc::c_int
                            == -62i32 as yaml_char_t as libc::c_int
                            && *(string.pointer).offset((k + 1 as libc::c_int) as isize)
                                as libc::c_int
                                == -123i32 as yaml_char_t as libc::c_int
                        || *(string.pointer).offset(k as isize) as libc::c_int
                            == -30i32 as yaml_char_t as libc::c_int
                            && *(string.pointer).offset((k + 1 as libc::c_int) as isize)
                                as libc::c_int
                                == -128i32 as yaml_char_t as libc::c_int
                            && *(string.pointer).offset((k + 2 as libc::c_int) as isize)
                                as libc::c_int
                                == -88i32 as yaml_char_t as libc::c_int
                        || *(string.pointer).offset(k as isize) as libc::c_int
                            == -30i32 as yaml_char_t as libc::c_int
                            && *(string.pointer).offset((k + 1 as libc::c_int) as isize)
                                as libc::c_int
                                == -128i32 as yaml_char_t as libc::c_int
                            && *(string.pointer).offset((k + 2 as libc::c_int) as isize)
                                as libc::c_int
                                == -87i32 as yaml_char_t as libc::c_int
                        || *(string.pointer).offset(k as isize) as libc::c_int
                            == '\0' as i32 as yaml_char_t as libc::c_int))
                {
                    if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_CR_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh373 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh373 = '\r' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh374 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh374 = '\n' as i32 as yaml_char_t;
                                } else {
                                    if (*emitter).line_break as libc::c_uint
                                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                    {
                                        let fresh375 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh375 = '\r' as i32 as yaml_char_t;
                                        let fresh376 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh376 = '\n' as i32 as yaml_char_t;
                                    } else {
                                    };
                                };
                            };
                            (*emitter).column = 0 as libc::c_int;
                            (*emitter).line += 1;
                            (*emitter).line;
                            1 as libc::c_int != 0
                        })
                    {
                        return 0 as libc::c_int;
                    }
                }
            }
            if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                {
                    ((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                        < (*emitter).buffer.end
                        || yaml_emitter_flush(emitter) != 0)
                        && {
                            if (*emitter).line_break as libc::c_uint
                                == YAML_CR_BREAK as libc::c_int as libc::c_uint
                            {
                                let fresh377 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh377 = '\r' as i32 as yaml_char_t;
                            } else {
                                if (*emitter).line_break as libc::c_uint
                                    == YAML_LN_BREAK as libc::c_int as libc::c_uint
                                {
                                    let fresh378 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh378 = '\n' as i32 as yaml_char_t;
                                } else {
                                    if (*emitter).line_break as libc::c_uint
                                        == YAML_CRLN_BREAK as libc::c_int as libc::c_uint
                                    {
                                        let fresh379 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh379 = '\r' as i32 as yaml_char_t;
                                        let fresh380 = (*emitter).buffer.pointer;
                                        (*emitter).buffer.pointer =
                                            ((*emitter).buffer.pointer).offset(1);
                                        *fresh380 = '\n' as i32 as yaml_char_t;
                                    } else {
                                    };
                                };
                            };
                            (*emitter).column = 0 as libc::c_int;
                            (*emitter).line += 1;
                            (*emitter).line;
                            1 as libc::c_int != 0
                        }) as libc::c_int;
                    string.pointer = (string.pointer).offset(1);
                    string.pointer;
                    1 as libc::c_int
                } else {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh381 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh382 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh382 = *fresh381;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh383 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh384 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh384 = *fresh383;
                            let fresh385 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh386 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh386 = *fresh385;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh387 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh388 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh388 = *fresh387;
                                let fresh389 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh390 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh390 = *fresh389;
                                let fresh391 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh392 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh392 = *fresh391;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh393 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh394 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh394 = *fresh393;
                                    let fresh395 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh396 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh396 = *fresh395;
                                    let fresh397 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh398 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh398 = *fresh397;
                                    let fresh399 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh400 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh400 = *fresh399;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column = 0 as libc::c_int;
                    (*emitter).line += 1;
                    (*emitter).line;
                    1 as libc::c_int
                }) != 0)
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 1 as libc::c_int;
            breaks = 1 as libc::c_int;
        } else {
            if breaks != 0 {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                leading_spaces = (*(string.pointer).offset(0 as libc::c_int as isize)
                    as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int
                    || *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '\t' as i32 as yaml_char_t as libc::c_int)
                    as libc::c_int;
            }
            if breaks == 0
                && *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int
                && !(*(string.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int)
                && (*emitter).column > (*emitter).best_width
            {
                if yaml_emitter_write_indent(emitter) == 0 {
                    return 0 as libc::c_int;
                }
                string.pointer = (string.pointer).offset(
                    (if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else if *(string.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as isize,
                );
            } else if !((((*emitter).buffer.pointer).offset(5 as libc::c_int as isize)
                < (*emitter).buffer.end
                || yaml_emitter_flush(emitter) != 0)
                && {
                    if *string.pointer as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        let fresh401 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        let fresh402 = (*emitter).buffer.pointer;
                        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                        *fresh402 = *fresh401;
                    } else {
                        if *string.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh403 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh404 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh404 = *fresh403;
                            let fresh405 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            let fresh406 = (*emitter).buffer.pointer;
                            (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                            *fresh406 = *fresh405;
                        } else {
                            if *string.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh407 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh408 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh408 = *fresh407;
                                let fresh409 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh410 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh410 = *fresh409;
                                let fresh411 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                let fresh412 = (*emitter).buffer.pointer;
                                (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(1);
                                *fresh412 = *fresh411;
                            } else {
                                if *string.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh413 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh414 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh414 = *fresh413;
                                    let fresh415 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh416 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh416 = *fresh415;
                                    let fresh417 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh418 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh418 = *fresh417;
                                    let fresh419 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    let fresh420 = (*emitter).buffer.pointer;
                                    (*emitter).buffer.pointer =
                                        ((*emitter).buffer.pointer).offset(1);
                                    *fresh420 = *fresh419;
                                } else {
                                };
                            };
                        };
                    };
                    (*emitter).column += 1;
                    (*emitter).column;
                    1 as libc::c_int != 0
                })
            {
                return 0 as libc::c_int;
            }
            (*emitter).indention = 0 as libc::c_int;
            breaks = 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_load(
    mut parser: *mut yaml_parser_t,
    mut document: *mut yaml_document_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            91 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_62687: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                91 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                    b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !document.is_null() {
    } else {
        __assert_fail(
            b"document\0" as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            92 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_62655: {
        if !document.is_null() {
        } else {
            __assert_fail(
                b"document\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                92 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                    b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        document as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_document_t>() as libc::c_ulong,
    );
    (*document).nodes.start = yaml_malloc(
        (16 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<yaml_node_t>() as libc::c_ulong),
    ) as *mut yaml_node_t;
    if !(if !((*document).nodes.start).is_null() {
        (*document).nodes.top = (*document).nodes.start;
        (*document).nodes.end = ((*document).nodes.start).offset(16 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if (*parser).stream_start_produced == 0 {
            if yaml_parser_parse(parser, &mut event) == 0 {
                current_block = 18009904609730434368;
            } else {
                if event.type_0 as libc::c_uint
                    == YAML_STREAM_START_EVENT as libc::c_int as libc::c_uint
                {
                } else {
                    __assert_fail(
                        b"event.type == YAML_STREAM_START_EVENT\0" as *const u8
                            as *const libc::c_char,
                        b"./loader.c\0" as *const u8 as *const libc::c_char,
                        100 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                            b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
                        ))
                        .as_ptr(),
                    );
                }
                'c_62524: {
                    if event.type_0 as libc::c_uint
                        == YAML_STREAM_START_EVENT as libc::c_int as libc::c_uint
                    {
                    } else {
                        __assert_fail(
                            b"event.type == YAML_STREAM_START_EVENT\0" as *const u8
                                as *const libc::c_char,
                            b"./loader.c\0" as *const u8 as *const libc::c_char,
                            100 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<&[u8; 57], &[libc::c_char; 57]>(
                                b"int yaml_parser_load(yaml_parser_t *, yaml_document_t *)\0",
                            ))
                            .as_ptr(),
                        );
                    }
                };
                current_block = 11875828834189669668;
            }
        } else {
            current_block = 11875828834189669668;
        }
        match current_block {
            18009904609730434368 => {}
            _ => {
                if (*parser).stream_end_produced != 0 {
                    return 1 as libc::c_int;
                }
                if !(yaml_parser_parse(parser, &mut event) == 0) {
                    if event.type_0 as libc::c_uint
                        == YAML_STREAM_END_EVENT as libc::c_int as libc::c_uint
                    {
                        return 1 as libc::c_int;
                    }
                    (*parser).aliases.start =
                        yaml_malloc((16 as libc::c_int as libc::c_ulong).wrapping_mul(
                            ::core::mem::size_of::<yaml_alias_data_t>() as libc::c_ulong,
                        )) as *mut yaml_alias_data_t;
                    if !(if !((*parser).aliases.start).is_null() {
                        (*parser).aliases.top = (*parser).aliases.start;
                        (*parser).aliases.end =
                            ((*parser).aliases.start).offset(16 as libc::c_int as isize);
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        (*parser).document = document;
                        if !(yaml_parser_load_document(parser, &mut event) == 0) {
                            yaml_parser_delete_aliases(parser);
                            (*parser).document = 0 as *mut yaml_document_t;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_parser_delete_aliases(parser);
    yaml_document_delete(document);
    (*parser).document = 0 as *mut yaml_document_t;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_set_composer_error(
    mut parser: *mut yaml_parser_t,
    mut problem: *const libc::c_char,
    mut problem_mark: yaml_mark_t,
) -> libc::c_int {
    (*parser).error = YAML_COMPOSER_ERROR;
    (*parser).problem = problem;
    (*parser).problem_mark = problem_mark;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_set_composer_error_context(
    mut parser: *mut yaml_parser_t,
    mut context: *const libc::c_char,
    mut context_mark: yaml_mark_t,
    mut problem: *const libc::c_char,
    mut problem_mark: yaml_mark_t,
) -> libc::c_int {
    (*parser).error = YAML_COMPOSER_ERROR;
    (*parser).context = context;
    (*parser).context_mark = context_mark;
    (*parser).problem = problem;
    (*parser).problem_mark = problem_mark;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_delete_aliases(mut parser: *mut yaml_parser_t) {
    while !((*parser).aliases.start == (*parser).aliases.top) {
        (*parser).aliases.top = ((*parser).aliases.top).offset(-1);
        yaml_free((*(*parser).aliases.top).anchor as *mut libc::c_void);
    }
    yaml_free((*parser).aliases.start as *mut libc::c_void);
    (*parser).aliases.end = 0 as *mut yaml_alias_data_t;
    (*parser).aliases.top = (*parser).aliases.end;
    (*parser).aliases.start = (*parser).aliases.top;
}
unsafe extern "C" fn yaml_parser_load_document(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut ctx: loader_ctx = {
        let mut init = loader_ctx {
            start: 0 as *mut libc::c_int,
            end: 0 as *mut libc::c_int,
            top: 0 as *mut libc::c_int,
        };
        init
    };
    if (*event).type_0 as libc::c_uint == YAML_DOCUMENT_START_EVENT as libc::c_int as libc::c_uint {
    } else {
        __assert_fail(
            b"event->type == YAML_DOCUMENT_START_EVENT\0" as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            189 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 63], &[libc::c_char; 63]>(
                b"int yaml_parser_load_document(yaml_parser_t *, yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_62377: {
        if (*event).type_0 as libc::c_uint
            == YAML_DOCUMENT_START_EVENT as libc::c_int as libc::c_uint
        {
        } else {
            __assert_fail(
                b"event->type == YAML_DOCUMENT_START_EVENT\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                189 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 63], &[libc::c_char; 63]>(
                    b"int yaml_parser_load_document(yaml_parser_t *, yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*(*parser).document).version_directive = (*event).data.document_start.version_directive;
    (*(*parser).document).tag_directives.start = (*event).data.document_start.tag_directives.start;
    (*(*parser).document).tag_directives.end = (*event).data.document_start.tag_directives.end;
    (*(*parser).document).start_implicit = (*event).data.document_start.implicit;
    (*(*parser).document).start_mark = (*event).start_mark;
    ctx.start = yaml_malloc(
        (16 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    if if !(ctx.start).is_null() {
        ctx.top = ctx.start;
        ctx.end = (ctx.start).offset(16 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    if yaml_parser_load_nodes(parser, &mut ctx) == 0 {
        yaml_free(ctx.start as *mut libc::c_void);
        ctx.end = 0 as *mut libc::c_int;
        ctx.top = ctx.end;
        ctx.start = ctx.top;
        return 0 as libc::c_int;
    }
    yaml_free(ctx.start as *mut libc::c_void);
    ctx.end = 0 as *mut libc::c_int;
    ctx.top = ctx.end;
    ctx.start = ctx.top;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_nodes(
    mut parser: *mut yaml_parser_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut event: yaml_event_t = yaml_event_t {
        type_0: YAML_NO_EVENT,
        data: C2RustUnnamed_7 {
            stream_start: C2RustUnnamed_15 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    loop {
        if yaml_parser_parse(parser, &mut event) == 0 {
            return 0 as libc::c_int;
        }
        match event.type_0 as libc::c_uint {
            5 => {
                if yaml_parser_load_alias(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            6 => {
                if yaml_parser_load_scalar(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            7 => {
                if yaml_parser_load_sequence(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            8 => {
                if yaml_parser_load_sequence_end(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            9 => {
                if yaml_parser_load_mapping(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            10 => {
                if yaml_parser_load_mapping_end(parser, &mut event, ctx) == 0 {
                    return 0 as libc::c_int;
                }
            }
            4 => {}
            _ => {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"./loader.c\0" as *const u8 as *const libc::c_char,
                    246 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<&[u8; 65], &[libc::c_char; 65]>(
                        b"int yaml_parser_load_nodes(yaml_parser_t *, struct loader_ctx *)\0",
                    ))
                    .as_ptr(),
                );
                'c_59552: {
                    __assert_fail(
                        b"0\0" as *const u8 as *const libc::c_char,
                        b"./loader.c\0" as *const u8 as *const libc::c_char,
                        246 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<&[u8; 65], &[libc::c_char; 65]>(
                            b"int yaml_parser_load_nodes(yaml_parser_t *, struct loader_ctx *)\0",
                        ))
                        .as_ptr(),
                    );
                };
                return 0 as libc::c_int;
            }
        }
        if !(event.type_0 as libc::c_uint != YAML_DOCUMENT_END_EVENT as libc::c_int as libc::c_uint)
        {
            break;
        }
    }
    (*(*parser).document).end_implicit = event.data.document_end.implicit;
    (*(*parser).document).end_mark = event.end_mark;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_register_anchor(
    mut parser: *mut yaml_parser_t,
    mut index: libc::c_int,
    mut anchor: *mut yaml_char_t,
) -> libc::c_int {
    let mut data: yaml_alias_data_t = yaml_alias_data_t {
        anchor: 0 as *mut yaml_char_t,
        index: 0,
        mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut alias_data: *mut yaml_alias_data_t = 0 as *mut yaml_alias_data_t;
    if anchor.is_null() {
        return 1 as libc::c_int;
    }
    data.anchor = anchor;
    data.index = index;
    data.mark = (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize))
        .start_mark;
    alias_data = (*parser).aliases.start;
    while alias_data != (*parser).aliases.top {
        if strcmp(
            (*alias_data).anchor as *mut libc::c_char,
            anchor as *mut libc::c_char,
        ) == 0 as libc::c_int
        {
            yaml_free(anchor as *mut libc::c_void);
            return yaml_parser_set_composer_error_context(
                parser,
                b"found duplicate anchor; first occurrence\0" as *const u8 as *const libc::c_char,
                (*alias_data).mark,
                b"second occurrence\0" as *const u8 as *const libc::c_char,
                data.mark,
            );
        }
        alias_data = alias_data.offset(1);
        alias_data;
    }
    if if (*parser).aliases.top != (*parser).aliases.end
        || yaml_stack_extend(
            &mut (*parser).aliases.start as *mut *mut yaml_alias_data_t as *mut *mut libc::c_void,
            &mut (*parser).aliases.top as *mut *mut yaml_alias_data_t as *mut *mut libc::c_void,
            &mut (*parser).aliases.end as *mut *mut yaml_alias_data_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh421 = (*parser).aliases.top;
        (*parser).aliases.top = ((*parser).aliases.top).offset(1);
        *fresh421 = data;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_free(anchor as *mut libc::c_void);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_node_add(
    mut parser: *mut yaml_parser_t,
    mut ctx: *mut loader_ctx,
    mut index: libc::c_int,
) -> libc::c_int {
    let mut parent: *mut yaml_node_s = 0 as *mut yaml_node_s;
    let mut parent_index: libc::c_int = 0;
    if (*ctx).start == (*ctx).top {
        return 1 as libc::c_int;
    }
    parent_index = *((*ctx).top).offset(-(1 as libc::c_int as isize));
    parent = &mut *((*(*parser).document).nodes.start)
        .offset((parent_index - 1 as libc::c_int) as isize) as *mut yaml_node_t;
    let mut current_block_17: u64;
    match (*parent).type_0 as libc::c_uint {
        2 => {
            if if (((*parent).data.sequence.items.top)
                .offset_from((*parent).data.sequence.items.start)
                as libc::c_long)
                < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
            {
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            if if (*parent).data.sequence.items.top != (*parent).data.sequence.items.end
                || yaml_stack_extend(
                    &mut (*parent).data.sequence.items.start as *mut *mut yaml_node_item_t
                        as *mut *mut libc::c_void,
                    &mut (*parent).data.sequence.items.top as *mut *mut yaml_node_item_t
                        as *mut *mut libc::c_void,
                    &mut (*parent).data.sequence.items.end as *mut *mut yaml_node_item_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh422 = (*parent).data.sequence.items.top;
                (*parent).data.sequence.items.top = ((*parent).data.sequence.items.top).offset(1);
                *fresh422 = index;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
        }
        3 => {
            let mut pair: yaml_node_pair_t = yaml_node_pair_t { key: 0, value: 0 };
            if !((*parent).data.mapping.pairs.start == (*parent).data.mapping.pairs.top) {
                let mut p: *mut yaml_node_pair_t =
                    ((*parent).data.mapping.pairs.top).offset(-(1 as libc::c_int as isize));
                if (*p).key != 0 as libc::c_int && (*p).value == 0 as libc::c_int {
                    (*p).value = index;
                    current_block_17 = 2370887241019905314;
                } else {
                    current_block_17 = 1841672684692190573;
                }
            } else {
                current_block_17 = 1841672684692190573;
            }
            match current_block_17 {
                2370887241019905314 => {}
                _ => {
                    pair.key = index;
                    pair.value = 0 as libc::c_int;
                    if if (((*parent).data.mapping.pairs.top)
                        .offset_from((*parent).data.mapping.pairs.start)
                        as libc::c_long)
                        < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
                    {
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0
                    {
                        return 0 as libc::c_int;
                    }
                    if if (*parent).data.mapping.pairs.top != (*parent).data.mapping.pairs.end
                        || yaml_stack_extend(
                            &mut (*parent).data.mapping.pairs.start as *mut *mut yaml_node_pair_t
                                as *mut *mut libc::c_void,
                            &mut (*parent).data.mapping.pairs.top as *mut *mut yaml_node_pair_t
                                as *mut *mut libc::c_void,
                            &mut (*parent).data.mapping.pairs.end as *mut *mut yaml_node_pair_t
                                as *mut *mut libc::c_void,
                        ) != 0
                    {
                        let fresh423 = (*parent).data.mapping.pairs.top;
                        (*parent).data.mapping.pairs.top =
                            ((*parent).data.mapping.pairs.top).offset(1);
                        *fresh423 = pair;
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0
                    {
                        return 0 as libc::c_int;
                    }
                }
            }
        }
        _ => {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                340 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 73], &[libc::c_char; 73]>(
                    b"int yaml_parser_load_node_add(yaml_parser_t *, struct loader_ctx *, int)\0",
                ))
                .as_ptr(),
            );
            'c_59988: {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"./loader.c\0" as *const u8 as *const libc::c_char,
                    340 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 73],
                        &[libc::c_char; 73],
                    >(
                        b"int yaml_parser_load_node_add(yaml_parser_t *, struct loader_ctx *, int)\0",
                    ))
                        .as_ptr(),
                );
            };
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_alias(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut anchor: *mut yaml_char_t = (*event).data.alias.anchor;
    let mut alias_data: *mut yaml_alias_data_t = 0 as *mut yaml_alias_data_t;
    alias_data = (*parser).aliases.start;
    while alias_data != (*parser).aliases.top {
        if strcmp(
            (*alias_data).anchor as *mut libc::c_char,
            anchor as *mut libc::c_char,
        ) == 0 as libc::c_int
        {
            yaml_free(anchor as *mut libc::c_void);
            return yaml_parser_load_node_add(parser, ctx, (*alias_data).index);
        }
        alias_data = alias_data.offset(1);
        alias_data;
    }
    yaml_free(anchor as *mut libc::c_void);
    return yaml_parser_set_composer_error(
        parser,
        b"found undefined alias\0" as *const u8 as *const libc::c_char,
        (*event).start_mark,
    );
}
unsafe extern "C" fn yaml_parser_load_scalar(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut current_block: u64;
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut index: libc::c_int = 0;
    let mut tag: *mut yaml_char_t = (*event).data.scalar.tag;
    if !(if (((*(*parser).document).nodes.top).offset_from((*(*parser).document).nodes.start)
        as libc::c_long)
        < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
    {
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if tag.is_null()
            || strcmp(
                tag as *mut libc::c_char,
                b"!\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            yaml_free(tag as *mut libc::c_void);
            tag = yaml_strdup(
                b"tag:yaml.org,2002:str\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
            );
            if tag.is_null() {
                current_block = 15456992660920835775;
            } else {
                current_block = 15427931788582360902;
            }
        } else {
            current_block = 15427931788582360902;
        }
        match current_block {
            15456992660920835775 => {}
            _ => {
                memset(
                    &mut node as *mut yaml_node_t as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                );
                node.type_0 = YAML_SCALAR_NODE;
                node.tag = tag;
                node.start_mark = (*event).start_mark;
                node.end_mark = (*event).end_mark;
                node.data.scalar.value = (*event).data.scalar.value;
                node.data.scalar.length = (*event).data.scalar.length;
                node.data.scalar.style = (*event).data.scalar.style;
                if !(if (*(*parser).document).nodes.top != (*(*parser).document).nodes.end
                    || yaml_stack_extend(
                        &mut (*(*parser).document).nodes.start as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*(*parser).document).nodes.top as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                        &mut (*(*parser).document).nodes.end as *mut *mut yaml_node_t
                            as *mut *mut libc::c_void,
                    ) != 0
                {
                    let fresh424 = (*(*parser).document).nodes.top;
                    (*(*parser).document).nodes.top = ((*(*parser).document).nodes.top).offset(1);
                    *fresh424 = node;
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    index = ((*(*parser).document).nodes.top)
                        .offset_from((*(*parser).document).nodes.start)
                        as libc::c_long as libc::c_int;
                    if yaml_parser_register_anchor(parser, index, (*event).data.scalar.anchor) == 0
                    {
                        return 0 as libc::c_int;
                    }
                    return yaml_parser_load_node_add(parser, ctx, index);
                }
            }
        }
    }
    yaml_free(tag as *mut libc::c_void);
    yaml_free((*event).data.scalar.anchor as *mut libc::c_void);
    yaml_free((*event).data.scalar.value as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_sequence(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut current_block: u64;
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut items: C2RustUnnamed_50 = {
        let mut init = C2RustUnnamed_50 {
            start: 0 as *mut yaml_node_item_t,
            end: 0 as *mut yaml_node_item_t,
            top: 0 as *mut yaml_node_item_t,
        };
        init
    };
    let mut index: libc::c_int = 0;
    let mut tag: *mut yaml_char_t = (*event).data.sequence_start.tag;
    if !(if (((*(*parser).document).nodes.top).offset_from((*(*parser).document).nodes.start)
        as libc::c_long)
        < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
    {
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if tag.is_null()
            || strcmp(
                tag as *mut libc::c_char,
                b"!\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            yaml_free(tag as *mut libc::c_void);
            tag = yaml_strdup(
                b"tag:yaml.org,2002:seq\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
            );
            if tag.is_null() {
                current_block = 11847778772291631574;
            } else {
                current_block = 11875828834189669668;
            }
        } else {
            current_block = 11875828834189669668;
        }
        match current_block {
            11847778772291631574 => {}
            _ => {
                items.start = yaml_malloc(
                    (16 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<yaml_node_item_t>() as libc::c_ulong),
                ) as *mut yaml_node_item_t;
                if !(if !(items.start).is_null() {
                    items.top = items.start;
                    items.end = (items.start).offset(16 as libc::c_int as isize);
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    memset(
                        &mut node as *mut yaml_node_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                    );
                    node.type_0 = YAML_SEQUENCE_NODE;
                    node.tag = tag;
                    node.start_mark = (*event).start_mark;
                    node.end_mark = (*event).end_mark;
                    node.data.sequence.items.start = items.start;
                    node.data.sequence.items.end = items.end;
                    node.data.sequence.items.top = items.start;
                    node.data.sequence.style = (*event).data.sequence_start.style;
                    if !(if (*(*parser).document).nodes.top != (*(*parser).document).nodes.end
                        || yaml_stack_extend(
                            &mut (*(*parser).document).nodes.start as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*(*parser).document).nodes.top as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*(*parser).document).nodes.end as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                        ) != 0
                    {
                        let fresh425 = (*(*parser).document).nodes.top;
                        (*(*parser).document).nodes.top =
                            ((*(*parser).document).nodes.top).offset(1);
                        *fresh425 = node;
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        index = ((*(*parser).document).nodes.top)
                            .offset_from((*(*parser).document).nodes.start)
                            as libc::c_long as libc::c_int;
                        if yaml_parser_register_anchor(
                            parser,
                            index,
                            (*event).data.sequence_start.anchor,
                        ) == 0
                        {
                            return 0 as libc::c_int;
                        }
                        if yaml_parser_load_node_add(parser, ctx, index) == 0 {
                            return 0 as libc::c_int;
                        }
                        if if (((*ctx).top).offset_from((*ctx).start) as libc::c_long)
                            < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
                        {
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            return 0 as libc::c_int;
                        }
                        if if (*ctx).top != (*ctx).end
                            || yaml_stack_extend(
                                &mut (*ctx).start as *mut *mut libc::c_int
                                    as *mut *mut libc::c_void,
                                &mut (*ctx).top as *mut *mut libc::c_int as *mut *mut libc::c_void,
                                &mut (*ctx).end as *mut *mut libc::c_int as *mut *mut libc::c_void,
                            ) != 0
                        {
                            let fresh426 = (*ctx).top;
                            (*ctx).top = ((*ctx).top).offset(1);
                            *fresh426 = index;
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            return 0 as libc::c_int;
                        }
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(tag as *mut libc::c_void);
    yaml_free((*event).data.sequence_start.anchor as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_sequence_end(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut index: libc::c_int = 0;
    if ((*ctx).top).offset_from((*ctx).start) as libc::c_long > 0 as libc::c_int as libc::c_long {
    } else {
        __assert_fail(
            b"((*ctx).top - (*ctx).start) > 0\0" as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            467 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 88],
                &[libc::c_char; 88],
            >(
                b"int yaml_parser_load_sequence_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_61129: {
        if ((*ctx).top).offset_from((*ctx).start) as libc::c_long > 0 as libc::c_int as libc::c_long
        {
        } else {
            __assert_fail(
                b"((*ctx).top - (*ctx).start) > 0\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                467 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 88],
                    &[libc::c_char; 88],
                >(
                    b"int yaml_parser_load_sequence_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    index = *((*ctx).top).offset(-(1 as libc::c_int as isize));
    if (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).type_0
        as libc::c_uint
        == YAML_SEQUENCE_NODE as libc::c_int as libc::c_uint
    {
    } else {
        __assert_fail(
            b"parser->document->nodes.start[index-1].type == YAML_SEQUENCE_NODE\0"
                as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            470 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 88],
                &[libc::c_char; 88],
            >(
                b"int yaml_parser_load_sequence_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_61051: {
        if (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).type_0
            as libc::c_uint
            == YAML_SEQUENCE_NODE as libc::c_int as libc::c_uint
        {
        } else {
            __assert_fail(
                b"parser->document->nodes.start[index-1].type == YAML_SEQUENCE_NODE\0"
                    as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                470 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 88],
                    &[libc::c_char; 88],
                >(
                    b"int yaml_parser_load_sequence_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).end_mark =
        (*event).end_mark;
    (*ctx).top = ((*ctx).top).offset(-1);
    *(*ctx).top;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_mapping(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut current_block: u64;
    let mut node: yaml_node_t = yaml_node_t {
        type_0: YAML_NO_NODE,
        tag: 0 as *mut yaml_char_t,
        data: C2RustUnnamed_18 {
            scalar: C2RustUnnamed_23 {
                value: 0 as *mut yaml_char_t,
                length: 0,
                style: YAML_ANY_SCALAR_STYLE,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut pairs: C2RustUnnamed_49 = {
        let mut init = C2RustUnnamed_49 {
            start: 0 as *mut yaml_node_pair_t,
            end: 0 as *mut yaml_node_pair_t,
            top: 0 as *mut yaml_node_pair_t,
        };
        init
    };
    let mut index: libc::c_int = 0;
    let mut tag: *mut yaml_char_t = (*event).data.mapping_start.tag;
    if !(if (((*(*parser).document).nodes.top).offset_from((*(*parser).document).nodes.start)
        as libc::c_long)
        < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
    {
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if tag.is_null()
            || strcmp(
                tag as *mut libc::c_char,
                b"!\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            yaml_free(tag as *mut libc::c_void);
            tag = yaml_strdup(
                b"tag:yaml.org,2002:map\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
            );
            if tag.is_null() {
                current_block = 6450168102218502955;
            } else {
                current_block = 11875828834189669668;
            }
        } else {
            current_block = 11875828834189669668;
        }
        match current_block {
            6450168102218502955 => {}
            _ => {
                pairs.start = yaml_malloc(
                    (16 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(::core::mem::size_of::<yaml_node_pair_t>() as libc::c_ulong),
                ) as *mut yaml_node_pair_t;
                if !(if !(pairs.start).is_null() {
                    pairs.top = pairs.start;
                    pairs.end = (pairs.start).offset(16 as libc::c_int as isize);
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    memset(
                        &mut node as *mut yaml_node_t as *mut libc::c_void,
                        0 as libc::c_int,
                        ::core::mem::size_of::<yaml_node_t>() as libc::c_ulong,
                    );
                    node.type_0 = YAML_MAPPING_NODE;
                    node.tag = tag;
                    node.start_mark = (*event).start_mark;
                    node.end_mark = (*event).end_mark;
                    node.data.mapping.pairs.start = pairs.start;
                    node.data.mapping.pairs.end = pairs.end;
                    node.data.mapping.pairs.top = pairs.start;
                    node.data.mapping.style = (*event).data.mapping_start.style;
                    if !(if (*(*parser).document).nodes.top != (*(*parser).document).nodes.end
                        || yaml_stack_extend(
                            &mut (*(*parser).document).nodes.start as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*(*parser).document).nodes.top as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                            &mut (*(*parser).document).nodes.end as *mut *mut yaml_node_t
                                as *mut *mut libc::c_void,
                        ) != 0
                    {
                        let fresh427 = (*(*parser).document).nodes.top;
                        (*(*parser).document).nodes.top =
                            ((*(*parser).document).nodes.top).offset(1);
                        *fresh427 = node;
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0)
                    {
                        index = ((*(*parser).document).nodes.top)
                            .offset_from((*(*parser).document).nodes.start)
                            as libc::c_long as libc::c_int;
                        if yaml_parser_register_anchor(
                            parser,
                            index,
                            (*event).data.mapping_start.anchor,
                        ) == 0
                        {
                            return 0 as libc::c_int;
                        }
                        if yaml_parser_load_node_add(parser, ctx, index) == 0 {
                            return 0 as libc::c_int;
                        }
                        if if (((*ctx).top).offset_from((*ctx).start) as libc::c_long)
                            < (2147483647 as libc::c_int - 1 as libc::c_int) as libc::c_long
                        {
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            return 0 as libc::c_int;
                        }
                        if if (*ctx).top != (*ctx).end
                            || yaml_stack_extend(
                                &mut (*ctx).start as *mut *mut libc::c_int
                                    as *mut *mut libc::c_void,
                                &mut (*ctx).top as *mut *mut libc::c_int as *mut *mut libc::c_void,
                                &mut (*ctx).end as *mut *mut libc::c_int as *mut *mut libc::c_void,
                            ) != 0
                        {
                            let fresh428 = (*ctx).top;
                            (*ctx).top = ((*ctx).top).offset(1);
                            *fresh428 = index;
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            return 0 as libc::c_int;
                        }
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(tag as *mut libc::c_void);
    yaml_free((*event).data.mapping_start.anchor as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_load_mapping_end(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut ctx: *mut loader_ctx,
) -> libc::c_int {
    let mut index: libc::c_int = 0;
    if ((*ctx).top).offset_from((*ctx).start) as libc::c_long > 0 as libc::c_int as libc::c_long {
    } else {
        __assert_fail(
            b"((*ctx).top - (*ctx).start) > 0\0" as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            535 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 87],
                &[libc::c_char; 87],
            >(
                b"int yaml_parser_load_mapping_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_59720: {
        if ((*ctx).top).offset_from((*ctx).start) as libc::c_long > 0 as libc::c_int as libc::c_long
        {
        } else {
            __assert_fail(
                b"((*ctx).top - (*ctx).start) > 0\0" as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                535 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 87],
                    &[libc::c_char; 87],
                >(
                    b"int yaml_parser_load_mapping_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    index = *((*ctx).top).offset(-(1 as libc::c_int as isize));
    if (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).type_0
        as libc::c_uint
        == YAML_MAPPING_NODE as libc::c_int as libc::c_uint
    {
    } else {
        __assert_fail(
            b"parser->document->nodes.start[index-1].type == YAML_MAPPING_NODE\0"
                as *const u8 as *const libc::c_char,
            b"./loader.c\0" as *const u8 as *const libc::c_char,
            538 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 87],
                &[libc::c_char; 87],
            >(
                b"int yaml_parser_load_mapping_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
            ))
                .as_ptr(),
        );
    }
    'c_59642: {
        if (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).type_0
            as libc::c_uint
            == YAML_MAPPING_NODE as libc::c_int as libc::c_uint
        {
        } else {
            __assert_fail(
                b"parser->document->nodes.start[index-1].type == YAML_MAPPING_NODE\0"
                    as *const u8 as *const libc::c_char,
                b"./loader.c\0" as *const u8 as *const libc::c_char,
                538 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 87],
                    &[libc::c_char; 87],
                >(
                    b"int yaml_parser_load_mapping_end(yaml_parser_t *, yaml_event_t *, struct loader_ctx *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    (*((*(*parser).document).nodes.start).offset((index - 1 as libc::c_int) as isize)).end_mark =
        (*event).end_mark;
    (*ctx).top = ((*ctx).top).offset(-1);
    *(*ctx).top;
    return 1 as libc::c_int;
}
#[no_mangle]
pub static mut MAX_NESTING_LEVEL: libc::c_int = 1000 as libc::c_int;
#[no_mangle]
pub unsafe extern "C" fn yaml_set_max_nest_level(mut max: libc::c_int) {
    MAX_NESTING_LEVEL = max;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_parse(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./parser.c\0" as *const u8 as *const libc::c_char,
            184 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                b"int yaml_parser_parse(yaml_parser_t *, yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_59217: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./parser.c\0" as *const u8 as *const libc::c_char,
                184 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                    b"int yaml_parser_parse(yaml_parser_t *, yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !event.is_null() {
    } else {
        __assert_fail(
            b"event\0" as *const u8 as *const libc::c_char,
            b"./parser.c\0" as *const u8 as *const libc::c_char,
            185 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                b"int yaml_parser_parse(yaml_parser_t *, yaml_event_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_59185: {
        if !event.is_null() {
        } else {
            __assert_fail(
                b"event\0" as *const u8 as *const libc::c_char,
                b"./parser.c\0" as *const u8 as *const libc::c_char,
                185 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                    b"int yaml_parser_parse(yaml_parser_t *, yaml_event_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    if (*parser).stream_end_produced != 0
        || (*parser).error as libc::c_uint != 0
        || (*parser).state as libc::c_uint == YAML_PARSE_END_STATE as libc::c_int as libc::c_uint
    {
        return 1 as libc::c_int;
    }
    return yaml_parser_state_machine(parser, event);
}
unsafe extern "C" fn yaml_parser_set_parser_error(
    mut parser: *mut yaml_parser_t,
    mut problem: *const libc::c_char,
    mut problem_mark: yaml_mark_t,
) -> libc::c_int {
    (*parser).error = YAML_PARSER_ERROR;
    (*parser).problem = problem;
    (*parser).problem_mark = problem_mark;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_set_parser_error_context(
    mut parser: *mut yaml_parser_t,
    mut context: *const libc::c_char,
    mut context_mark: yaml_mark_t,
    mut problem: *const libc::c_char,
    mut problem_mark: yaml_mark_t,
) -> libc::c_int {
    (*parser).error = YAML_PARSER_ERROR;
    (*parser).context = context;
    (*parser).context_mark = context_mark;
    (*parser).problem = problem;
    (*parser).problem_mark = problem_mark;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_maximum_level_reached(
    mut parser: *mut yaml_parser_t,
    mut context_mark: yaml_mark_t,
    mut problem_mark: yaml_mark_t,
) -> libc::c_int {
    yaml_parser_set_parser_error_context(
        parser,
        b"while parsing\0" as *const u8 as *const libc::c_char,
        context_mark,
        b"Maximum nesting level reached, set with yaml_set_max_nest_level())\0" as *const u8
            as *const libc::c_char,
        problem_mark,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_state_machine(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    match (*parser).state as libc::c_uint {
        0 => return yaml_parser_parse_stream_start(parser, event),
        1 => return yaml_parser_parse_document_start(parser, event, 1 as libc::c_int),
        2 => return yaml_parser_parse_document_start(parser, event, 0 as libc::c_int),
        3 => return yaml_parser_parse_document_content(parser, event),
        4 => return yaml_parser_parse_document_end(parser, event),
        5 => {
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 0 as libc::c_int);
        }
        6 => {
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 1 as libc::c_int);
        }
        7 => {
            return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
        }
        8 => {
            return yaml_parser_parse_block_sequence_entry(parser, event, 1 as libc::c_int);
        }
        9 => {
            return yaml_parser_parse_block_sequence_entry(parser, event, 0 as libc::c_int);
        }
        10 => return yaml_parser_parse_indentless_sequence_entry(parser, event),
        11 => return yaml_parser_parse_block_mapping_key(parser, event, 1 as libc::c_int),
        12 => return yaml_parser_parse_block_mapping_key(parser, event, 0 as libc::c_int),
        13 => return yaml_parser_parse_block_mapping_value(parser, event),
        14 => {
            return yaml_parser_parse_flow_sequence_entry(parser, event, 1 as libc::c_int);
        }
        15 => {
            return yaml_parser_parse_flow_sequence_entry(parser, event, 0 as libc::c_int);
        }
        16 => return yaml_parser_parse_flow_sequence_entry_mapping_key(parser, event),
        17 => return yaml_parser_parse_flow_sequence_entry_mapping_value(parser, event),
        18 => return yaml_parser_parse_flow_sequence_entry_mapping_end(parser, event),
        19 => return yaml_parser_parse_flow_mapping_key(parser, event, 1 as libc::c_int),
        20 => return yaml_parser_parse_flow_mapping_key(parser, event, 0 as libc::c_int),
        21 => {
            return yaml_parser_parse_flow_mapping_value(parser, event, 0 as libc::c_int);
        }
        22 => {
            return yaml_parser_parse_flow_mapping_value(parser, event, 1 as libc::c_int);
        }
        _ => {
            'c_50280: {};
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_stream_start(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint != YAML_STREAM_START_TOKEN as libc::c_int as libc::c_uint {
        return yaml_parser_set_parser_error(
            parser,
            b"did not find expected <stream-start>\0" as *const u8 as *const libc::c_char,
            (*token).start_mark,
        );
    }
    (*parser).state = YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_STREAM_START_EVENT;
    (*event).start_mark = (*token).start_mark;
    (*event).end_mark = (*token).start_mark;
    (*event).data.stream_start.encoding = (*token).data.stream_start.encoding;
    (*parser).token_available = 0 as libc::c_int;
    (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
    (*parser).tokens_parsed;
    (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
        == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
        as libc::c_int;
    (*parser).tokens.head = ((*parser).tokens.head).offset(1);
    (*parser).tokens.head;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_document_start(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut implicit: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    let mut version_directive: *mut yaml_version_directive_t = 0 as *mut yaml_version_directive_t;
    let mut tag_directives: C2RustUnnamed_47 = {
        let mut init = C2RustUnnamed_47 {
            start: 0 as *mut yaml_tag_directive_t,
            end: 0 as *mut yaml_tag_directive_t,
        };
        init
    };
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if implicit == 0 {
        while (*token).type_0 as libc::c_uint
            == YAML_DOCUMENT_END_TOKEN as libc::c_int as libc::c_uint
        {
            (*parser).token_available = 0 as libc::c_int;
            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
            (*parser).tokens_parsed;
            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                as libc::c_int;
            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
            (*parser).tokens.head;
            token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0
            {
                (*parser).tokens.head
            } else {
                0 as *mut yaml_token_t
            };
            if token.is_null() {
                return 0 as libc::c_int;
            }
        }
    }
    if implicit != 0
        && (*token).type_0 as libc::c_uint
            != YAML_VERSION_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
        && (*token).type_0 as libc::c_uint
            != YAML_TAG_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
        && (*token).type_0 as libc::c_uint
            != YAML_DOCUMENT_START_TOKEN as libc::c_int as libc::c_uint
        && (*token).type_0 as libc::c_uint != YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint
    {
        if yaml_parser_process_directives(
            parser,
            0 as *mut *mut yaml_version_directive_t,
            0 as *mut *mut yaml_tag_directive_t,
            0 as *mut *mut yaml_tag_directive_t,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        if if (*parser).states.top != (*parser).states.end
            || yaml_stack_extend(
                &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
                &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
                &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh429 = (*parser).states.top;
            (*parser).states.top = ((*parser).states.top).offset(1);
            *fresh429 = YAML_PARSE_DOCUMENT_END_STATE;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).state = YAML_PARSE_BLOCK_NODE_STATE;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_DOCUMENT_START_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).start_mark;
        (*event).data.document_start.version_directive = 0 as *mut yaml_version_directive_t;
        (*event).data.document_start.tag_directives.start = 0 as *mut yaml_tag_directive_t;
        (*event).data.document_start.tag_directives.end = 0 as *mut yaml_tag_directive_t;
        (*event).data.document_start.implicit = 1 as libc::c_int;
        return 1 as libc::c_int;
    } else if (*token).type_0 as libc::c_uint
        != YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint
    {
        let mut start_mark: yaml_mark_t = yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        };
        let mut end_mark: yaml_mark_t = yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        };
        start_mark = (*token).start_mark;
        if yaml_parser_process_directives(
            parser,
            &mut version_directive,
            &mut tag_directives.start,
            &mut tag_directives.end,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if !token.is_null() {
            if (*token).type_0 as libc::c_uint
                != YAML_DOCUMENT_START_TOKEN as libc::c_int as libc::c_uint
            {
                yaml_parser_set_parser_error(
                    parser,
                    b"did not find expected <document start>\0" as *const u8 as *const libc::c_char,
                    (*token).start_mark,
                );
            } else if !(if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh430 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh430 = YAML_PARSE_DOCUMENT_END_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                (*parser).state = YAML_PARSE_DOCUMENT_CONTENT_STATE;
                end_mark = (*token).end_mark;
                memset(
                    event as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                );
                (*event).type_0 = YAML_DOCUMENT_START_EVENT;
                (*event).start_mark = start_mark;
                (*event).end_mark = end_mark;
                (*event).data.document_start.version_directive = version_directive;
                (*event).data.document_start.tag_directives.start = tag_directives.start;
                (*event).data.document_start.tag_directives.end = tag_directives.end;
                (*event).data.document_start.implicit = 0 as libc::c_int;
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                version_directive = 0 as *mut yaml_version_directive_t;
                tag_directives.end = 0 as *mut yaml_tag_directive_t;
                tag_directives.start = tag_directives.end;
                return 1 as libc::c_int;
            }
        }
        yaml_free(version_directive as *mut libc::c_void);
        while tag_directives.start != tag_directives.end {
            yaml_free(
                (*(tag_directives.end).offset(-(1 as libc::c_int) as isize)).handle
                    as *mut libc::c_void,
            );
            yaml_free(
                (*(tag_directives.end).offset(-(1 as libc::c_int) as isize)).prefix
                    as *mut libc::c_void,
            );
            tag_directives.end = (tag_directives.end).offset(-1);
            tag_directives.end;
        }
        yaml_free(tag_directives.start as *mut libc::c_void);
        return 0 as libc::c_int;
    } else {
        (*parser).state = YAML_PARSE_END_STATE;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_STREAM_END_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        return 1 as libc::c_int;
    };
}
unsafe extern "C" fn yaml_parser_parse_document_content(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint
        == YAML_VERSION_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
        || (*token).type_0 as libc::c_uint
            == YAML_TAG_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
        || (*token).type_0 as libc::c_uint
            == YAML_DOCUMENT_START_TOKEN as libc::c_int as libc::c_uint
        || (*token).type_0 as libc::c_uint == YAML_DOCUMENT_END_TOKEN as libc::c_int as libc::c_uint
        || (*token).type_0 as libc::c_uint == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint
    {
        (*parser).states.top = ((*parser).states.top).offset(-1);
        (*parser).state = *(*parser).states.top;
        return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
    } else {
        return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 0 as libc::c_int);
    };
}
unsafe extern "C" fn yaml_parser_parse_document_end(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut implicit: libc::c_int = 1 as libc::c_int;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    end_mark = (*token).start_mark;
    start_mark = end_mark;
    if (*token).type_0 as libc::c_uint == YAML_DOCUMENT_END_TOKEN as libc::c_int as libc::c_uint {
        end_mark = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        implicit = 0 as libc::c_int;
    }
    while !((*parser).tag_directives.start == (*parser).tag_directives.top) {
        (*parser).tag_directives.top = ((*parser).tag_directives.top).offset(-1);
        let mut tag_directive: yaml_tag_directive_t = *(*parser).tag_directives.top;
        yaml_free(tag_directive.handle as *mut libc::c_void);
        yaml_free(tag_directive.prefix as *mut libc::c_void);
    }
    (*parser).state = YAML_PARSE_DOCUMENT_START_STATE;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_DOCUMENT_END_EVENT;
    (*event).start_mark = start_mark;
    (*event).end_mark = end_mark;
    (*event).data.document_end.implicit = implicit;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_node(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut block: libc::c_int,
    mut indentless_sequence: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    let mut anchor: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag_handle: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag_suffix: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut tag: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut tag_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut implicit: libc::c_int = 0;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_ALIAS_TOKEN as libc::c_int as libc::c_uint {
        (*parser).states.top = ((*parser).states.top).offset(-1);
        (*parser).state = *(*parser).states.top;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_ALIAS_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).end_mark;
        (*event).data.alias.anchor = (*token).data.alias.value;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        return 1 as libc::c_int;
    } else {
        end_mark = (*token).start_mark;
        start_mark = end_mark;
        if (*token).type_0 as libc::c_uint == YAML_ANCHOR_TOKEN as libc::c_int as libc::c_uint {
            anchor = (*token).data.anchor.value;
            start_mark = (*token).start_mark;
            end_mark = (*token).end_mark;
            (*parser).token_available = 0 as libc::c_int;
            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
            (*parser).tokens_parsed;
            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                as libc::c_int;
            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
            (*parser).tokens.head;
            token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0
            {
                (*parser).tokens.head
            } else {
                0 as *mut yaml_token_t
            };
            if token.is_null() {
                current_block = 12092521835838682495;
            } else if (*token).type_0 as libc::c_uint
                == YAML_TAG_TOKEN as libc::c_int as libc::c_uint
            {
                tag_handle = (*token).data.tag.handle;
                tag_suffix = (*token).data.tag.suffix;
                tag_mark = (*token).start_mark;
                end_mark = (*token).end_mark;
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                token = if (*parser).token_available != 0
                    || yaml_parser_fetch_more_tokens(parser) != 0
                {
                    (*parser).tokens.head
                } else {
                    0 as *mut yaml_token_t
                };
                if token.is_null() {
                    current_block = 12092521835838682495;
                } else {
                    current_block = 2569451025026770673;
                }
            } else {
                current_block = 2569451025026770673;
            }
        } else if (*token).type_0 as libc::c_uint == YAML_TAG_TOKEN as libc::c_int as libc::c_uint {
            tag_handle = (*token).data.tag.handle;
            tag_suffix = (*token).data.tag.suffix;
            tag_mark = (*token).start_mark;
            start_mark = tag_mark;
            end_mark = (*token).end_mark;
            (*parser).token_available = 0 as libc::c_int;
            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
            (*parser).tokens_parsed;
            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                as libc::c_int;
            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
            (*parser).tokens.head;
            token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0
            {
                (*parser).tokens.head
            } else {
                0 as *mut yaml_token_t
            };
            if token.is_null() {
                current_block = 12092521835838682495;
            } else if (*token).type_0 as libc::c_uint
                == YAML_ANCHOR_TOKEN as libc::c_int as libc::c_uint
            {
                anchor = (*token).data.anchor.value;
                end_mark = (*token).end_mark;
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                token = if (*parser).token_available != 0
                    || yaml_parser_fetch_more_tokens(parser) != 0
                {
                    (*parser).tokens.head
                } else {
                    0 as *mut yaml_token_t
                };
                if token.is_null() {
                    current_block = 12092521835838682495;
                } else {
                    current_block = 2569451025026770673;
                }
            } else {
                current_block = 2569451025026770673;
            }
        } else {
            current_block = 2569451025026770673;
        }
        match current_block {
            2569451025026770673 => {
                if !tag_handle.is_null() {
                    if *tag_handle == 0 {
                        tag = tag_suffix;
                        yaml_free(tag_handle as *mut libc::c_void);
                        tag_suffix = 0 as *mut yaml_char_t;
                        tag_handle = tag_suffix;
                        current_block = 1423531122933789233;
                    } else {
                        let mut tag_directive: *mut yaml_tag_directive_t =
                            0 as *mut yaml_tag_directive_t;
                        tag_directive = (*parser).tag_directives.start;
                        loop {
                            if !(tag_directive != (*parser).tag_directives.top) {
                                current_block = 1345366029464561491;
                                break;
                            }
                            if strcmp(
                                (*tag_directive).handle as *mut libc::c_char,
                                tag_handle as *mut libc::c_char,
                            ) == 0 as libc::c_int
                            {
                                let mut prefix_len: size_t =
                                    strlen((*tag_directive).prefix as *mut libc::c_char);
                                let mut suffix_len: size_t =
                                    strlen(tag_suffix as *mut libc::c_char);
                                tag = yaml_malloc(
                                    prefix_len
                                        .wrapping_add(suffix_len)
                                        .wrapping_add(1 as libc::c_int as libc::c_ulong),
                                ) as *mut yaml_char_t;
                                if tag.is_null() {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    current_block = 12092521835838682495;
                                    break;
                                } else {
                                    memcpy(
                                        tag as *mut libc::c_void,
                                        (*tag_directive).prefix as *const libc::c_void,
                                        prefix_len,
                                    );
                                    memcpy(
                                        tag.offset(prefix_len as isize) as *mut libc::c_void,
                                        tag_suffix as *const libc::c_void,
                                        suffix_len,
                                    );
                                    *tag.offset(prefix_len.wrapping_add(suffix_len) as isize) =
                                        '\0' as i32 as yaml_char_t;
                                    yaml_free(tag_handle as *mut libc::c_void);
                                    yaml_free(tag_suffix as *mut libc::c_void);
                                    tag_suffix = 0 as *mut yaml_char_t;
                                    tag_handle = tag_suffix;
                                    current_block = 1345366029464561491;
                                    break;
                                }
                            } else {
                                tag_directive = tag_directive.offset(1);
                                tag_directive;
                            }
                        }
                        match current_block {
                            12092521835838682495 => {}
                            _ => {
                                if tag.is_null() {
                                    yaml_parser_set_parser_error_context(
                                        parser,
                                        b"while parsing a node\0" as *const u8
                                            as *const libc::c_char,
                                        start_mark,
                                        b"found undefined tag handle\0" as *const u8
                                            as *const libc::c_char,
                                        tag_mark,
                                    );
                                    current_block = 12092521835838682495;
                                } else {
                                    current_block = 1423531122933789233;
                                }
                            }
                        }
                    }
                } else {
                    current_block = 1423531122933789233;
                }
                match current_block {
                    12092521835838682495 => {}
                    _ => {
                        implicit = (tag.is_null() || *tag == 0) as libc::c_int;
                        if indentless_sequence != 0
                            && (*token).type_0 as libc::c_uint
                                == YAML_BLOCK_ENTRY_TOKEN as libc::c_int as libc::c_uint
                        {
                            end_mark = (*token).end_mark;
                            (*parser).state = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
                            memset(
                                event as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                            );
                            (*event).type_0 = YAML_SEQUENCE_START_EVENT;
                            (*event).start_mark = start_mark;
                            (*event).end_mark = end_mark;
                            (*event).data.sequence_start.anchor = anchor;
                            (*event).data.sequence_start.tag = tag;
                            (*event).data.sequence_start.implicit = implicit;
                            (*event).data.sequence_start.style = YAML_BLOCK_SEQUENCE_STYLE;
                            return 1 as libc::c_int;
                        } else if (*token).type_0 as libc::c_uint
                            == YAML_SCALAR_TOKEN as libc::c_int as libc::c_uint
                        {
                            let mut plain_implicit: libc::c_int = 0 as libc::c_int;
                            let mut quoted_implicit: libc::c_int = 0 as libc::c_int;
                            end_mark = (*token).end_mark;
                            if (*token).data.scalar.style as libc::c_uint
                                == YAML_PLAIN_SCALAR_STYLE as libc::c_int as libc::c_uint
                                && tag.is_null()
                                || !tag.is_null()
                                    && strcmp(
                                        tag as *mut libc::c_char,
                                        b"!\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int
                            {
                                plain_implicit = 1 as libc::c_int;
                            } else if tag.is_null() {
                                quoted_implicit = 1 as libc::c_int;
                            }
                            (*parser).states.top = ((*parser).states.top).offset(-1);
                            (*parser).state = *(*parser).states.top;
                            memset(
                                event as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                            );
                            (*event).type_0 = YAML_SCALAR_EVENT;
                            (*event).start_mark = start_mark;
                            (*event).end_mark = end_mark;
                            (*event).data.scalar.anchor = anchor;
                            (*event).data.scalar.tag = tag;
                            (*event).data.scalar.value = (*token).data.scalar.value;
                            (*event).data.scalar.length = (*token).data.scalar.length;
                            (*event).data.scalar.plain_implicit = plain_implicit;
                            (*event).data.scalar.quoted_implicit = quoted_implicit;
                            (*event).data.scalar.style = (*token).data.scalar.style;
                            (*parser).token_available = 0 as libc::c_int;
                            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                            (*parser).tokens_parsed;
                            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0
                                as libc::c_uint
                                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                                as libc::c_int;
                            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                            (*parser).tokens.head;
                            return 1 as libc::c_int;
                        } else if (*token).type_0 as libc::c_uint
                            == YAML_FLOW_SEQUENCE_START_TOKEN as libc::c_int as libc::c_uint
                        {
                            if if (((*parser).indents.top).offset_from((*parser).indents.start)
                                as libc::c_long)
                                < (MAX_NESTING_LEVEL - (*parser).flow_level) as libc::c_long
                            {
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                yaml_maximum_level_reached(parser, start_mark, (*token).start_mark);
                            } else {
                                end_mark = (*token).end_mark;
                                (*parser).state = YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE;
                                memset(
                                    event as *mut libc::c_void,
                                    0 as libc::c_int,
                                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                                );
                                (*event).type_0 = YAML_SEQUENCE_START_EVENT;
                                (*event).start_mark = start_mark;
                                (*event).end_mark = end_mark;
                                (*event).data.sequence_start.anchor = anchor;
                                (*event).data.sequence_start.tag = tag;
                                (*event).data.sequence_start.implicit = implicit;
                                (*event).data.sequence_start.style = YAML_FLOW_SEQUENCE_STYLE;
                                return 1 as libc::c_int;
                            }
                        } else if (*token).type_0 as libc::c_uint
                            == YAML_FLOW_MAPPING_START_TOKEN as libc::c_int as libc::c_uint
                        {
                            if if (((*parser).indents.top).offset_from((*parser).indents.start)
                                as libc::c_long)
                                < (MAX_NESTING_LEVEL - (*parser).flow_level) as libc::c_long
                            {
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                yaml_maximum_level_reached(parser, start_mark, (*token).start_mark);
                            } else {
                                end_mark = (*token).end_mark;
                                (*parser).state = YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE;
                                memset(
                                    event as *mut libc::c_void,
                                    0 as libc::c_int,
                                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                                );
                                (*event).type_0 = YAML_MAPPING_START_EVENT;
                                (*event).start_mark = start_mark;
                                (*event).end_mark = end_mark;
                                (*event).data.mapping_start.anchor = anchor;
                                (*event).data.mapping_start.tag = tag;
                                (*event).data.mapping_start.implicit = implicit;
                                (*event).data.mapping_start.style = YAML_FLOW_MAPPING_STYLE;
                                return 1 as libc::c_int;
                            }
                        } else if block != 0
                            && (*token).type_0 as libc::c_uint
                                == YAML_BLOCK_SEQUENCE_START_TOKEN as libc::c_int as libc::c_uint
                        {
                            if if (((*parser).indents.top).offset_from((*parser).indents.start)
                                as libc::c_long)
                                < (MAX_NESTING_LEVEL - (*parser).flow_level) as libc::c_long
                            {
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                yaml_maximum_level_reached(parser, start_mark, (*token).start_mark);
                            } else {
                                end_mark = (*token).end_mark;
                                (*parser).state = YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE;
                                memset(
                                    event as *mut libc::c_void,
                                    0 as libc::c_int,
                                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                                );
                                (*event).type_0 = YAML_SEQUENCE_START_EVENT;
                                (*event).start_mark = start_mark;
                                (*event).end_mark = end_mark;
                                (*event).data.sequence_start.anchor = anchor;
                                (*event).data.sequence_start.tag = tag;
                                (*event).data.sequence_start.implicit = implicit;
                                (*event).data.sequence_start.style = YAML_BLOCK_SEQUENCE_STYLE;
                                return 1 as libc::c_int;
                            }
                        } else if block != 0
                            && (*token).type_0 as libc::c_uint
                                == YAML_BLOCK_MAPPING_START_TOKEN as libc::c_int as libc::c_uint
                        {
                            if if (((*parser).indents.top).offset_from((*parser).indents.start)
                                as libc::c_long)
                                < (MAX_NESTING_LEVEL - (*parser).flow_level) as libc::c_long
                            {
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                yaml_maximum_level_reached(parser, start_mark, (*token).start_mark);
                            } else {
                                end_mark = (*token).end_mark;
                                (*parser).state = YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE;
                                memset(
                                    event as *mut libc::c_void,
                                    0 as libc::c_int,
                                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                                );
                                (*event).type_0 = YAML_MAPPING_START_EVENT;
                                (*event).start_mark = start_mark;
                                (*event).end_mark = end_mark;
                                (*event).data.mapping_start.anchor = anchor;
                                (*event).data.mapping_start.tag = tag;
                                (*event).data.mapping_start.implicit = implicit;
                                (*event).data.mapping_start.style = YAML_BLOCK_MAPPING_STYLE;
                                return 1 as libc::c_int;
                            }
                        } else if !anchor.is_null() || !tag.is_null() {
                            let mut value: *mut yaml_char_t =
                                yaml_malloc(1 as libc::c_int as size_t) as *mut yaml_char_t;
                            if value.is_null() {
                                (*parser).error = YAML_MEMORY_ERROR;
                            } else {
                                *value.offset(0 as libc::c_int as isize) =
                                    '\0' as i32 as yaml_char_t;
                                (*parser).states.top = ((*parser).states.top).offset(-1);
                                (*parser).state = *(*parser).states.top;
                                memset(
                                    event as *mut libc::c_void,
                                    0 as libc::c_int,
                                    ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
                                );
                                (*event).type_0 = YAML_SCALAR_EVENT;
                                (*event).start_mark = start_mark;
                                (*event).end_mark = end_mark;
                                (*event).data.scalar.anchor = anchor;
                                (*event).data.scalar.tag = tag;
                                (*event).data.scalar.value = value;
                                (*event).data.scalar.length = 0 as libc::c_int as size_t;
                                (*event).data.scalar.plain_implicit = implicit;
                                (*event).data.scalar.quoted_implicit = 0 as libc::c_int;
                                (*event).data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
                                return 1 as libc::c_int;
                            }
                        } else {
                            yaml_parser_set_parser_error_context(
                                parser,
                                if block != 0 {
                                    b"while parsing a block node\0" as *const u8
                                        as *const libc::c_char
                                } else {
                                    b"while parsing a flow node\0" as *const u8
                                        as *const libc::c_char
                                },
                                start_mark,
                                b"did not find expected node content\0" as *const u8
                                    as *const libc::c_char,
                                (*token).start_mark,
                            );
                        }
                    }
                }
            }
            _ => {}
        }
        yaml_free(anchor as *mut libc::c_void);
        yaml_free(tag_handle as *mut libc::c_void);
        yaml_free(tag_suffix as *mut libc::c_void);
        yaml_free(tag as *mut libc::c_void);
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn yaml_parser_parse_block_sequence_entry(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    if first != 0 {
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if if (*parser).marks.top != (*parser).marks.end
            || yaml_stack_extend(
                &mut (*parser).marks.start as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.top as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.end as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh431 = (*parser).marks.top;
            (*parser).marks.top = ((*parser).marks.top).offset(1);
            *fresh431 = (*token).start_mark;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
    }
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_BLOCK_ENTRY_TOKEN as libc::c_int as libc::c_uint {
        let mut mark: yaml_mark_t = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_BLOCK_ENTRY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh432 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh432 = YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 0 as libc::c_int);
        } else {
            (*parser).state = YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE;
            return yaml_parser_process_empty_scalar(parser, event, mark);
        }
    } else if (*token).type_0 as libc::c_uint == YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
    {
        (*parser).states.top = ((*parser).states.top).offset(-1);
        (*parser).state = *(*parser).states.top;
        (*parser).marks.top = ((*parser).marks.top).offset(-1);
        *(*parser).marks.top;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_SEQUENCE_END_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        return 1 as libc::c_int;
    } else {
        (*parser).marks.top = ((*parser).marks.top).offset(-1);
        return yaml_parser_set_parser_error_context(
            parser,
            b"while parsing a block collection\0" as *const u8 as *const libc::c_char,
            *(*parser).marks.top,
            b"did not find expected '-' indicator\0" as *const u8 as *const libc::c_char,
            (*token).start_mark,
        );
    };
}
unsafe extern "C" fn yaml_parser_parse_indentless_sequence_entry(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_BLOCK_ENTRY_TOKEN as libc::c_int as libc::c_uint {
        let mut mark: yaml_mark_t = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_BLOCK_ENTRY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint != YAML_KEY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint != YAML_VALUE_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh433 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh433 = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 0 as libc::c_int);
        } else {
            (*parser).state = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
            return yaml_parser_process_empty_scalar(parser, event, mark);
        }
    } else {
        (*parser).states.top = ((*parser).states.top).offset(-1);
        (*parser).state = *(*parser).states.top;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_SEQUENCE_END_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).start_mark;
        return 1 as libc::c_int;
    };
}
unsafe extern "C" fn yaml_parser_parse_block_mapping_key(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    if first != 0 {
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if if (*parser).marks.top != (*parser).marks.end
            || yaml_stack_extend(
                &mut (*parser).marks.start as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.top as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.end as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh434 = (*parser).marks.top;
            (*parser).marks.top = ((*parser).marks.top).offset(1);
            *fresh434 = (*token).start_mark;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
    }
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_KEY_TOKEN as libc::c_int as libc::c_uint {
        let mut mark: yaml_mark_t = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_KEY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint != YAML_VALUE_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh435 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh435 = YAML_PARSE_BLOCK_MAPPING_VALUE_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 1 as libc::c_int);
        } else {
            (*parser).state = YAML_PARSE_BLOCK_MAPPING_VALUE_STATE;
            return yaml_parser_process_empty_scalar(parser, event, mark);
        }
    } else if (*token).type_0 as libc::c_uint == YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
    {
        (*parser).states.top = ((*parser).states.top).offset(-1);
        (*parser).state = *(*parser).states.top;
        (*parser).marks.top = ((*parser).marks.top).offset(-1);
        *(*parser).marks.top;
        memset(
            event as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
        );
        (*event).type_0 = YAML_MAPPING_END_EVENT;
        (*event).start_mark = (*token).start_mark;
        (*event).end_mark = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        return 1 as libc::c_int;
    } else {
        (*parser).marks.top = ((*parser).marks.top).offset(-1);
        return yaml_parser_set_parser_error_context(
            parser,
            b"while parsing a block mapping\0" as *const u8 as *const libc::c_char,
            *(*parser).marks.top,
            b"did not find expected key\0" as *const u8 as *const libc::c_char,
            (*token).start_mark,
        );
    };
}
unsafe extern "C" fn yaml_parser_parse_block_mapping_value(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_VALUE_TOKEN as libc::c_int as libc::c_uint {
        let mut mark: yaml_mark_t = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_KEY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint != YAML_VALUE_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_BLOCK_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh436 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh436 = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 1 as libc::c_int, 1 as libc::c_int);
        } else {
            (*parser).state = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
            return yaml_parser_process_empty_scalar(parser, event, mark);
        }
    } else {
        (*parser).state = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
        return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
    };
}
unsafe extern "C" fn yaml_parser_parse_flow_sequence_entry(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    if first != 0 {
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if if (*parser).marks.top != (*parser).marks.end
            || yaml_stack_extend(
                &mut (*parser).marks.start as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.top as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.end as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh437 = (*parser).marks.top;
            (*parser).marks.top = ((*parser).marks.top).offset(1);
            *fresh437 = (*token).start_mark;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
    }
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint
        != YAML_FLOW_SEQUENCE_END_TOKEN as libc::c_int as libc::c_uint
    {
        if first == 0 {
            if (*token).type_0 as libc::c_uint
                == YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
            {
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                token = if (*parser).token_available != 0
                    || yaml_parser_fetch_more_tokens(parser) != 0
                {
                    (*parser).tokens.head
                } else {
                    0 as *mut yaml_token_t
                };
                if token.is_null() {
                    return 0 as libc::c_int;
                }
            } else {
                (*parser).marks.top = ((*parser).marks.top).offset(-1);
                return yaml_parser_set_parser_error_context(
                    parser,
                    b"while parsing a flow sequence\0" as *const u8 as *const libc::c_char,
                    *(*parser).marks.top,
                    b"did not find expected ',' or ']'\0" as *const u8 as *const libc::c_char,
                    (*token).start_mark,
                );
            }
        }
        if (*token).type_0 as libc::c_uint == YAML_KEY_TOKEN as libc::c_int as libc::c_uint {
            (*parser).state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE;
            memset(
                event as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
            );
            (*event).type_0 = YAML_MAPPING_START_EVENT;
            (*event).start_mark = (*token).start_mark;
            (*event).end_mark = (*token).end_mark;
            (*event).data.mapping_start.anchor = 0 as *mut yaml_char_t;
            (*event).data.mapping_start.tag = 0 as *mut yaml_char_t;
            (*event).data.mapping_start.implicit = 1 as libc::c_int;
            (*event).data.mapping_start.style = YAML_FLOW_MAPPING_STYLE;
            (*parser).token_available = 0 as libc::c_int;
            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
            (*parser).tokens_parsed;
            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                as libc::c_int;
            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
            (*parser).tokens.head;
            return 1 as libc::c_int;
        } else if (*token).type_0 as libc::c_uint
            != YAML_FLOW_SEQUENCE_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh438 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh438 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
        }
    }
    (*parser).states.top = ((*parser).states.top).offset(-1);
    (*parser).state = *(*parser).states.top;
    (*parser).marks.top = ((*parser).marks.top).offset(-1);
    *(*parser).marks.top;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_SEQUENCE_END_EVENT;
    (*event).start_mark = (*token).start_mark;
    (*event).end_mark = (*token).end_mark;
    (*parser).token_available = 0 as libc::c_int;
    (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
    (*parser).tokens_parsed;
    (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
        == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
        as libc::c_int;
    (*parser).tokens.head = ((*parser).tokens.head).offset(1);
    (*parser).tokens.head;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_flow_sequence_entry_mapping_key(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint != YAML_VALUE_TOKEN as libc::c_int as libc::c_uint
        && (*token).type_0 as libc::c_uint != YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
        && (*token).type_0 as libc::c_uint
            != YAML_FLOW_SEQUENCE_END_TOKEN as libc::c_int as libc::c_uint
    {
        if if (*parser).states.top != (*parser).states.end
            || yaml_stack_extend(
                &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
                &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
                &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                    as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh439 = (*parser).states.top;
            (*parser).states.top = ((*parser).states.top).offset(1);
            *fresh439 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
    } else if (*token).type_0 as libc::c_uint
        == YAML_FLOW_SEQUENCE_END_TOKEN as libc::c_int as libc::c_uint
    {
        let mut mark: yaml_mark_t = (*token).start_mark;
        (*parser).state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
        return yaml_parser_process_empty_scalar(parser, event, mark);
    } else {
        let mut mark_0: yaml_mark_t = (*token).end_mark;
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        (*parser).state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
        return yaml_parser_process_empty_scalar(parser, event, mark_0);
    };
}
unsafe extern "C" fn yaml_parser_parse_flow_sequence_entry_mapping_value(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint == YAML_VALUE_TOKEN as libc::c_int as libc::c_uint {
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_FLOW_SEQUENCE_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh440 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh440 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
        }
    }
    (*parser).state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE;
    return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
}
unsafe extern "C" fn yaml_parser_parse_flow_sequence_entry_mapping_end(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    (*parser).state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_MAPPING_END_EVENT;
    (*event).start_mark = (*token).start_mark;
    (*event).end_mark = (*token).start_mark;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_flow_mapping_key(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut first: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    if first != 0 {
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if if (*parser).marks.top != (*parser).marks.end
            || yaml_stack_extend(
                &mut (*parser).marks.start as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.top as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
                &mut (*parser).marks.end as *mut *mut yaml_mark_t as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh441 = (*parser).marks.top;
            (*parser).marks.top = ((*parser).marks.top).offset(1);
            *fresh441 = (*token).start_mark;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
    }
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if (*token).type_0 as libc::c_uint != YAML_FLOW_MAPPING_END_TOKEN as libc::c_int as libc::c_uint
    {
        if first == 0 {
            if (*token).type_0 as libc::c_uint
                == YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
            {
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                token = if (*parser).token_available != 0
                    || yaml_parser_fetch_more_tokens(parser) != 0
                {
                    (*parser).tokens.head
                } else {
                    0 as *mut yaml_token_t
                };
                if token.is_null() {
                    return 0 as libc::c_int;
                }
            } else {
                (*parser).marks.top = ((*parser).marks.top).offset(-1);
                return yaml_parser_set_parser_error_context(
                    parser,
                    b"while parsing a flow mapping\0" as *const u8 as *const libc::c_char,
                    *(*parser).marks.top,
                    b"did not find expected ',' or '}'\0" as *const u8 as *const libc::c_char,
                    (*token).start_mark,
                );
            }
        }
        if (*token).type_0 as libc::c_uint == YAML_KEY_TOKEN as libc::c_int as libc::c_uint {
            (*parser).token_available = 0 as libc::c_int;
            (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
            (*parser).tokens_parsed;
            (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                as libc::c_int;
            (*parser).tokens.head = ((*parser).tokens.head).offset(1);
            (*parser).tokens.head;
            token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0
            {
                (*parser).tokens.head
            } else {
                0 as *mut yaml_token_t
            };
            if token.is_null() {
                return 0 as libc::c_int;
            }
            if (*token).type_0 as libc::c_uint != YAML_VALUE_TOKEN as libc::c_int as libc::c_uint
                && (*token).type_0 as libc::c_uint
                    != YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
                && (*token).type_0 as libc::c_uint
                    != YAML_FLOW_MAPPING_END_TOKEN as libc::c_int as libc::c_uint
            {
                if if (*parser).states.top != (*parser).states.end
                    || yaml_stack_extend(
                        &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                            as *mut *mut libc::c_void,
                        &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                            as *mut *mut libc::c_void,
                        &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                            as *mut *mut libc::c_void,
                    ) != 0
                {
                    let fresh442 = (*parser).states.top;
                    (*parser).states.top = ((*parser).states.top).offset(1);
                    *fresh442 = YAML_PARSE_FLOW_MAPPING_VALUE_STATE;
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0
                {
                    return 0 as libc::c_int;
                }
                return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
            } else {
                (*parser).state = YAML_PARSE_FLOW_MAPPING_VALUE_STATE;
                return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
            }
        } else if (*token).type_0 as libc::c_uint
            != YAML_FLOW_MAPPING_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh443 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh443 = YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
        }
    }
    (*parser).states.top = ((*parser).states.top).offset(-1);
    (*parser).state = *(*parser).states.top;
    (*parser).marks.top = ((*parser).marks.top).offset(-1);
    *(*parser).marks.top;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_MAPPING_END_EVENT;
    (*event).start_mark = (*token).start_mark;
    (*event).end_mark = (*token).end_mark;
    (*parser).token_available = 0 as libc::c_int;
    (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
    (*parser).tokens_parsed;
    (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
        == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
        as libc::c_int;
    (*parser).tokens.head = ((*parser).tokens.head).offset(1);
    (*parser).tokens.head;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_parse_flow_mapping_value(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut empty: libc::c_int,
) -> libc::c_int {
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
        (*parser).tokens.head
    } else {
        0 as *mut yaml_token_t
    };
    if token.is_null() {
        return 0 as libc::c_int;
    }
    if empty != 0 {
        (*parser).state = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
        return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
    }
    if (*token).type_0 as libc::c_uint == YAML_VALUE_TOKEN as libc::c_int as libc::c_uint {
        (*parser).token_available = 0 as libc::c_int;
        (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
        (*parser).tokens_parsed;
        (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
            == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
            as libc::c_int;
        (*parser).tokens.head = ((*parser).tokens.head).offset(1);
        (*parser).tokens.head;
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if token.is_null() {
            return 0 as libc::c_int;
        }
        if (*token).type_0 as libc::c_uint != YAML_FLOW_ENTRY_TOKEN as libc::c_int as libc::c_uint
            && (*token).type_0 as libc::c_uint
                != YAML_FLOW_MAPPING_END_TOKEN as libc::c_int as libc::c_uint
        {
            if if (*parser).states.top != (*parser).states.end
                || yaml_stack_extend(
                    &mut (*parser).states.start as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.top as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                    &mut (*parser).states.end as *mut *mut yaml_parser_state_t
                        as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh444 = (*parser).states.top;
                (*parser).states.top = ((*parser).states.top).offset(1);
                *fresh444 = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
            return yaml_parser_parse_node(parser, event, 0 as libc::c_int, 0 as libc::c_int);
        }
    }
    (*parser).state = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
    return yaml_parser_process_empty_scalar(parser, event, (*token).start_mark);
}
unsafe extern "C" fn yaml_parser_process_empty_scalar(
    mut parser: *mut yaml_parser_t,
    mut event: *mut yaml_event_t,
    mut mark: yaml_mark_t,
) -> libc::c_int {
    let mut value: *mut yaml_char_t = 0 as *mut yaml_char_t;
    value = yaml_malloc(1 as libc::c_int as size_t) as *mut yaml_char_t;
    if value.is_null() {
        (*parser).error = YAML_MEMORY_ERROR;
        return 0 as libc::c_int;
    }
    *value.offset(0 as libc::c_int as isize) = '\0' as i32 as yaml_char_t;
    memset(
        event as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_event_t>() as libc::c_ulong,
    );
    (*event).type_0 = YAML_SCALAR_EVENT;
    (*event).start_mark = mark;
    (*event).end_mark = mark;
    (*event).data.scalar.anchor = 0 as *mut yaml_char_t;
    (*event).data.scalar.tag = 0 as *mut yaml_char_t;
    (*event).data.scalar.value = value;
    (*event).data.scalar.length = 0 as libc::c_int as size_t;
    (*event).data.scalar.plain_implicit = 1 as libc::c_int;
    (*event).data.scalar.quoted_implicit = 0 as libc::c_int;
    (*event).data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_process_directives(
    mut parser: *mut yaml_parser_t,
    mut version_directive_ref: *mut *mut yaml_version_directive_t,
    mut tag_directives_start_ref: *mut *mut yaml_tag_directive_t,
    mut tag_directives_end_ref: *mut *mut yaml_tag_directive_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut default_tag_directives: [yaml_tag_directive_t; 3] = [
        {
            let mut init = yaml_tag_directive_s {
                handle: b"!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
                prefix: b"!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
            };
            init
        },
        {
            let mut init = yaml_tag_directive_s {
                handle: b"!!\0" as *const u8 as *const libc::c_char as *mut yaml_char_t,
                prefix: b"tag:yaml.org,2002:\0" as *const u8 as *const libc::c_char
                    as *mut yaml_char_t,
            };
            init
        },
        {
            let mut init = yaml_tag_directive_s {
                handle: 0 as *mut yaml_char_t,
                prefix: 0 as *mut yaml_char_t,
            };
            init
        },
    ];
    let mut default_tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    let mut version_directive: *mut yaml_version_directive_t = 0 as *mut yaml_version_directive_t;
    let mut tag_directives: C2RustUnnamed_48 = {
        let mut init = C2RustUnnamed_48 {
            start: 0 as *mut yaml_tag_directive_t,
            end: 0 as *mut yaml_tag_directive_t,
            top: 0 as *mut yaml_tag_directive_t,
        };
        init
    };
    let mut token: *mut yaml_token_t = 0 as *mut yaml_token_t;
    tag_directives.start = yaml_malloc(
        (16 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<yaml_tag_directive_t>() as libc::c_ulong),
    ) as *mut yaml_tag_directive_t;
    if !(if !(tag_directives.start).is_null() {
        tag_directives.top = tag_directives.start;
        tag_directives.end = (tag_directives.start).offset(16 as libc::c_int as isize);
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        token = if (*parser).token_available != 0 || yaml_parser_fetch_more_tokens(parser) != 0 {
            (*parser).tokens.head
        } else {
            0 as *mut yaml_token_t
        };
        if !token.is_null() {
            loop {
                if !((*token).type_0 as libc::c_uint
                    == YAML_VERSION_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
                    || (*token).type_0 as libc::c_uint
                        == YAML_TAG_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint)
                {
                    current_block = 1109700713171191020;
                    break;
                }
                if (*token).type_0 as libc::c_uint
                    == YAML_VERSION_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
                {
                    if !version_directive.is_null() {
                        yaml_parser_set_parser_error(
                            parser,
                            b"found duplicate %YAML directive\0" as *const u8
                                as *const libc::c_char,
                            (*token).start_mark,
                        );
                        current_block = 13548419307881813118;
                        break;
                    } else if (*token).data.version_directive.major != 1 as libc::c_int
                        || (*token).data.version_directive.minor != 1 as libc::c_int
                            && (*token).data.version_directive.minor != 2 as libc::c_int
                    {
                        yaml_parser_set_parser_error(
                            parser,
                            b"found incompatible YAML document\0" as *const u8
                                as *const libc::c_char,
                            (*token).start_mark,
                        );
                        current_block = 13548419307881813118;
                        break;
                    } else {
                        version_directive =
                            yaml_malloc(
                                ::core::mem::size_of::<yaml_version_directive_t>() as libc::c_ulong
                            ) as *mut yaml_version_directive_t;
                        if version_directive.is_null() {
                            (*parser).error = YAML_MEMORY_ERROR;
                            current_block = 13548419307881813118;
                            break;
                        } else {
                            (*version_directive).major = (*token).data.version_directive.major;
                            (*version_directive).minor = (*token).data.version_directive.minor;
                        }
                    }
                } else if (*token).type_0 as libc::c_uint
                    == YAML_TAG_DIRECTIVE_TOKEN as libc::c_int as libc::c_uint
                {
                    let mut value: yaml_tag_directive_t = yaml_tag_directive_t {
                        handle: 0 as *mut yaml_char_t,
                        prefix: 0 as *mut yaml_char_t,
                    };
                    value.handle = (*token).data.tag_directive.handle;
                    value.prefix = (*token).data.tag_directive.prefix;
                    if yaml_parser_append_tag_directive(
                        parser,
                        value,
                        0 as libc::c_int,
                        (*token).start_mark,
                    ) == 0
                    {
                        current_block = 13548419307881813118;
                        break;
                    }
                    if if tag_directives.top != tag_directives.end
                        || yaml_stack_extend(
                            &mut tag_directives.start as *mut *mut yaml_tag_directive_t
                                as *mut *mut libc::c_void,
                            &mut tag_directives.top as *mut *mut yaml_tag_directive_t
                                as *mut *mut libc::c_void,
                            &mut tag_directives.end as *mut *mut yaml_tag_directive_t
                                as *mut *mut libc::c_void,
                        ) != 0
                    {
                        let fresh445 = tag_directives.top;
                        tag_directives.top = (tag_directives.top).offset(1);
                        *fresh445 = value;
                        1 as libc::c_int
                    } else {
                        (*parser).error = YAML_MEMORY_ERROR;
                        0 as libc::c_int
                    } == 0
                    {
                        current_block = 13548419307881813118;
                        break;
                    }
                }
                (*parser).token_available = 0 as libc::c_int;
                (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
                (*parser).tokens_parsed;
                (*parser).stream_end_produced = ((*(*parser).tokens.head).type_0 as libc::c_uint
                    == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint)
                    as libc::c_int;
                (*parser).tokens.head = ((*parser).tokens.head).offset(1);
                (*parser).tokens.head;
                token = if (*parser).token_available != 0
                    || yaml_parser_fetch_more_tokens(parser) != 0
                {
                    (*parser).tokens.head
                } else {
                    0 as *mut yaml_token_t
                };
                if token.is_null() {
                    current_block = 13548419307881813118;
                    break;
                }
            }
            match current_block {
                13548419307881813118 => {}
                _ => {
                    default_tag_directive = default_tag_directives.as_mut_ptr();
                    loop {
                        if ((*default_tag_directive).handle).is_null() {
                            current_block = 2232869372362427478;
                            break;
                        }
                        if yaml_parser_append_tag_directive(
                            parser,
                            *default_tag_directive,
                            1 as libc::c_int,
                            (*token).start_mark,
                        ) == 0
                        {
                            current_block = 13548419307881813118;
                            break;
                        }
                        default_tag_directive = default_tag_directive.offset(1);
                        default_tag_directive;
                    }
                    match current_block {
                        13548419307881813118 => {}
                        _ => {
                            if !version_directive_ref.is_null() {
                                *version_directive_ref = version_directive;
                            }
                            if !tag_directives_start_ref.is_null() {
                                if tag_directives.start == tag_directives.top {
                                    *tag_directives_end_ref = 0 as *mut yaml_tag_directive_t;
                                    *tag_directives_start_ref = *tag_directives_end_ref;
                                    yaml_free(tag_directives.start as *mut libc::c_void);
                                    tag_directives.end = 0 as *mut yaml_tag_directive_t;
                                    tag_directives.top = tag_directives.end;
                                    tag_directives.start = tag_directives.top;
                                } else {
                                    *tag_directives_start_ref = tag_directives.start;
                                    *tag_directives_end_ref = tag_directives.top;
                                }
                            } else {
                                yaml_free(tag_directives.start as *mut libc::c_void);
                                tag_directives.end = 0 as *mut yaml_tag_directive_t;
                                tag_directives.top = tag_directives.end;
                                tag_directives.start = tag_directives.top;
                            }
                            if version_directive_ref.is_null() {
                                yaml_free(version_directive as *mut libc::c_void);
                            }
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_free(version_directive as *mut libc::c_void);
    while !(tag_directives.start == tag_directives.top) {
        tag_directives.top = (tag_directives.top).offset(-1);
        let mut tag_directive: yaml_tag_directive_t = *tag_directives.top;
        yaml_free(tag_directive.handle as *mut libc::c_void);
        yaml_free(tag_directive.prefix as *mut libc::c_void);
    }
    yaml_free(tag_directives.start as *mut libc::c_void);
    tag_directives.end = 0 as *mut yaml_tag_directive_t;
    tag_directives.top = tag_directives.end;
    tag_directives.start = tag_directives.top;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_append_tag_directive(
    mut parser: *mut yaml_parser_t,
    mut value: yaml_tag_directive_t,
    mut allow_duplicates: libc::c_int,
    mut mark: yaml_mark_t,
) -> libc::c_int {
    let mut tag_directive: *mut yaml_tag_directive_t = 0 as *mut yaml_tag_directive_t;
    let mut copy: yaml_tag_directive_t = {
        let mut init = yaml_tag_directive_s {
            handle: 0 as *mut yaml_char_t,
            prefix: 0 as *mut yaml_char_t,
        };
        init
    };
    tag_directive = (*parser).tag_directives.start;
    while tag_directive != (*parser).tag_directives.top {
        if strcmp(
            value.handle as *mut libc::c_char,
            (*tag_directive).handle as *mut libc::c_char,
        ) == 0 as libc::c_int
        {
            if allow_duplicates != 0 {
                return 1 as libc::c_int;
            }
            return yaml_parser_set_parser_error(
                parser,
                b"found duplicate %TAG directive\0" as *const u8 as *const libc::c_char,
                mark,
            );
        }
        tag_directive = tag_directive.offset(1);
        tag_directive;
    }
    copy.handle = yaml_strdup(value.handle);
    copy.prefix = yaml_strdup(value.prefix);
    if (copy.handle).is_null() || (copy.prefix).is_null() {
        (*parser).error = YAML_MEMORY_ERROR;
    } else if !(if (*parser).tag_directives.top != (*parser).tag_directives.end
        || yaml_stack_extend(
            &mut (*parser).tag_directives.start as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
            &mut (*parser).tag_directives.top as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
            &mut (*parser).tag_directives.end as *mut *mut yaml_tag_directive_t
                as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh446 = (*parser).tag_directives.top;
        (*parser).tag_directives.top = ((*parser).tag_directives.top).offset(1);
        *fresh446 = copy;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        return 1 as libc::c_int;
    }
    yaml_free(copy.handle as *mut libc::c_void);
    yaml_free(copy.prefix as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_set_reader_error(
    mut parser: *mut yaml_parser_t,
    mut problem: *const libc::c_char,
    mut offset: size_t,
    mut value: libc::c_int,
) -> libc::c_int {
    (*parser).error = YAML_READER_ERROR;
    (*parser).problem = problem;
    (*parser).problem_offset = offset;
    (*parser).problem_value = value;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_determine_encoding(mut parser: *mut yaml_parser_t) -> libc::c_int {
    while (*parser).eof == 0
        && (((*parser).raw_buffer.last).offset_from((*parser).raw_buffer.pointer) as libc::c_long)
            < 3 as libc::c_int as libc::c_long
    {
        if yaml_parser_update_raw_buffer(parser) == 0 {
            return 0 as libc::c_int;
        }
    }
    if ((*parser).raw_buffer.last).offset_from((*parser).raw_buffer.pointer) as libc::c_long
        >= 2 as libc::c_int as libc::c_long
        && memcmp(
            (*parser).raw_buffer.pointer as *const libc::c_void,
            b"\xFF\xFE\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            2 as libc::c_int as libc::c_ulong,
        ) == 0
    {
        (*parser).encoding = YAML_UTF16LE_ENCODING;
        (*parser).raw_buffer.pointer =
            ((*parser).raw_buffer.pointer).offset(2 as libc::c_int as isize);
        (*parser).offset = ((*parser).offset as libc::c_ulong)
            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    } else if ((*parser).raw_buffer.last).offset_from((*parser).raw_buffer.pointer) as libc::c_long
        >= 2 as libc::c_int as libc::c_long
        && memcmp(
            (*parser).raw_buffer.pointer as *const libc::c_void,
            b"\xFE\xFF\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            2 as libc::c_int as libc::c_ulong,
        ) == 0
    {
        (*parser).encoding = YAML_UTF16BE_ENCODING;
        (*parser).raw_buffer.pointer =
            ((*parser).raw_buffer.pointer).offset(2 as libc::c_int as isize);
        (*parser).offset = ((*parser).offset as libc::c_ulong)
            .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    } else if ((*parser).raw_buffer.last).offset_from((*parser).raw_buffer.pointer) as libc::c_long
        >= 3 as libc::c_int as libc::c_long
        && memcmp(
            (*parser).raw_buffer.pointer as *const libc::c_void,
            b"\xEF\xBB\xBF\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        ) == 0
    {
        (*parser).encoding = YAML_UTF8_ENCODING;
        (*parser).raw_buffer.pointer =
            ((*parser).raw_buffer.pointer).offset(3 as libc::c_int as isize);
        (*parser).offset = ((*parser).offset as libc::c_ulong)
            .wrapping_add(3 as libc::c_int as libc::c_ulong) as size_t
            as size_t;
    } else {
        (*parser).encoding = YAML_UTF8_ENCODING;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_update_raw_buffer(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut size_read: size_t = 0 as libc::c_int as size_t;
    if (*parser).raw_buffer.start == (*parser).raw_buffer.pointer
        && (*parser).raw_buffer.last == (*parser).raw_buffer.end
    {
        return 1 as libc::c_int;
    }
    if (*parser).eof != 0 {
        return 1 as libc::c_int;
    }
    if (*parser).raw_buffer.start < (*parser).raw_buffer.pointer
        && (*parser).raw_buffer.pointer < (*parser).raw_buffer.last
    {
        memmove(
            (*parser).raw_buffer.start as *mut libc::c_void,
            (*parser).raw_buffer.pointer as *const libc::c_void,
            ((*parser).raw_buffer.last).offset_from((*parser).raw_buffer.pointer) as libc::c_long
                as libc::c_ulong,
        );
    }
    (*parser).raw_buffer.last = ((*parser).raw_buffer.last).offset(
        -(((*parser).raw_buffer.pointer).offset_from((*parser).raw_buffer.start) as libc::c_long
            as isize),
    );
    (*parser).raw_buffer.pointer = (*parser).raw_buffer.start;
    if ((*parser).read_handler).expect("non-null function pointer")(
        (*parser).read_handler_data,
        (*parser).raw_buffer.last,
        ((*parser).raw_buffer.end).offset_from((*parser).raw_buffer.last) as libc::c_long as size_t,
        &mut size_read,
    ) == 0
    {
        return yaml_parser_set_reader_error(
            parser,
            b"input error\0" as *const u8 as *const libc::c_char,
            (*parser).offset,
            -(1 as libc::c_int),
        );
    }
    (*parser).raw_buffer.last = ((*parser).raw_buffer.last).offset(size_read as isize);
    if size_read == 0 {
        (*parser).eof = 1 as libc::c_int;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_update_buffer(
    mut parser: *mut yaml_parser_t,
    mut length: size_t,
) -> libc::c_int {
    let mut first: libc::c_int = 1 as libc::c_int;
    if ((*parser).read_handler).is_some() {
    } else {
        __assert_fail(
            b"parser->read_handler\0" as *const u8 as *const libc::c_char,
            b"./reader.c\0" as *const u8 as *const libc::c_char,
            146 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                b"int yaml_parser_update_buffer(yaml_parser_t *, size_t)\0",
            ))
            .as_ptr(),
        );
    }
    'c_13775: {
        if ((*parser).read_handler).is_some() {
        } else {
            __assert_fail(
                b"parser->read_handler\0" as *const u8 as *const libc::c_char,
                b"./reader.c\0" as *const u8 as *const libc::c_char,
                146 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 55], &[libc::c_char; 55]>(
                    b"int yaml_parser_update_buffer(yaml_parser_t *, size_t)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*parser).eof != 0 && (*parser).raw_buffer.pointer == (*parser).raw_buffer.last {
        return 1 as libc::c_int;
    }
    if (*parser).unread >= length {
        return 1 as libc::c_int;
    }
    if (*parser).encoding as u64 == 0 {
        if yaml_parser_determine_encoding(parser) == 0 {
            return 0 as libc::c_int;
        }
    }
    if (*parser).buffer.start < (*parser).buffer.pointer
        && (*parser).buffer.pointer < (*parser).buffer.last
    {
        let mut size: size_t =
            ((*parser).buffer.last).offset_from((*parser).buffer.pointer) as libc::c_long as size_t;
        memmove(
            (*parser).buffer.start as *mut libc::c_void,
            (*parser).buffer.pointer as *const libc::c_void,
            size,
        );
        (*parser).buffer.pointer = (*parser).buffer.start;
        (*parser).buffer.last = ((*parser).buffer.start).offset(size as isize);
    } else if (*parser).buffer.pointer == (*parser).buffer.last {
        (*parser).buffer.pointer = (*parser).buffer.start;
        (*parser).buffer.last = (*parser).buffer.start;
    }
    while (*parser).unread < length {
        if first == 0 || (*parser).raw_buffer.pointer == (*parser).raw_buffer.last {
            if yaml_parser_update_raw_buffer(parser) == 0 {
                return 0 as libc::c_int;
            }
        }
        first = 0 as libc::c_int;
        while (*parser).raw_buffer.pointer != (*parser).raw_buffer.last {
            let mut value: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut value2: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut incomplete: libc::c_int = 0 as libc::c_int;
            let mut octet: libc::c_uchar = 0;
            let mut width: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            let mut low: libc::c_int = 0;
            let mut high: libc::c_int = 0;
            let mut k: size_t = 0;
            let mut raw_unread: size_t = ((*parser).raw_buffer.last)
                .offset_from((*parser).raw_buffer.pointer)
                as libc::c_long as size_t;
            match (*parser).encoding as libc::c_uint {
                1 => {
                    octet = *((*parser).raw_buffer.pointer).offset(0 as libc::c_int as isize);
                    width = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                        1 as libc::c_int
                    } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                        2 as libc::c_int
                    } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
                        3 as libc::c_int
                    } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uint;
                    if width == 0 {
                        return yaml_parser_set_reader_error(
                            parser,
                            b"invalid leading UTF-8 octet\0" as *const u8 as *const libc::c_char,
                            (*parser).offset,
                            octet as libc::c_int,
                        );
                    }
                    if width as libc::c_ulong > raw_unread {
                        if (*parser).eof != 0 {
                            return yaml_parser_set_reader_error(
                                parser,
                                b"incomplete UTF-8 octet sequence\0" as *const u8
                                    as *const libc::c_char,
                                (*parser).offset,
                                -(1 as libc::c_int),
                            );
                        }
                        incomplete = 1 as libc::c_int;
                    } else {
                        value = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                            octet as libc::c_int & 0x7f as libc::c_int
                        } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int
                        {
                            octet as libc::c_int & 0x1f as libc::c_int
                        } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int
                        {
                            octet as libc::c_int & 0xf as libc::c_int
                        } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int
                        {
                            octet as libc::c_int & 0x7 as libc::c_int
                        } else {
                            0 as libc::c_int
                        }) as libc::c_uint;
                        k = 1 as libc::c_int as size_t;
                        while k < width as libc::c_ulong {
                            octet = *((*parser).raw_buffer.pointer).offset(k as isize);
                            if octet as libc::c_int & 0xc0 as libc::c_int != 0x80 as libc::c_int {
                                return yaml_parser_set_reader_error(
                                    parser,
                                    b"invalid trailing UTF-8 octet\0" as *const u8
                                        as *const libc::c_char,
                                    ((*parser).offset).wrapping_add(k),
                                    octet as libc::c_int,
                                );
                            }
                            value = (value << 6 as libc::c_int).wrapping_add(
                                (octet as libc::c_int & 0x3f as libc::c_int) as libc::c_uint,
                            );
                            k = k.wrapping_add(1);
                            k;
                        }
                        if !(width == 1 as libc::c_int as libc::c_uint
                            || width == 2 as libc::c_int as libc::c_uint
                                && value >= 0x80 as libc::c_int as libc::c_uint
                            || width == 3 as libc::c_int as libc::c_uint
                                && value >= 0x800 as libc::c_int as libc::c_uint
                            || width == 4 as libc::c_int as libc::c_uint
                                && value >= 0x10000 as libc::c_int as libc::c_uint)
                        {
                            return yaml_parser_set_reader_error(
                                parser,
                                b"invalid length of a UTF-8 sequence\0" as *const u8
                                    as *const libc::c_char,
                                (*parser).offset,
                                -(1 as libc::c_int),
                            );
                        }
                        if value >= 0xd800 as libc::c_int as libc::c_uint
                            && value <= 0xdfff as libc::c_int as libc::c_uint
                            || value > 0x10ffff as libc::c_int as libc::c_uint
                        {
                            return yaml_parser_set_reader_error(
                                parser,
                                b"invalid Unicode character\0" as *const u8 as *const libc::c_char,
                                (*parser).offset,
                                value as libc::c_int,
                            );
                        }
                    }
                }
                2 | 3 => {
                    low = if (*parser).encoding as libc::c_uint
                        == YAML_UTF16LE_ENCODING as libc::c_int as libc::c_uint
                    {
                        0 as libc::c_int
                    } else {
                        1 as libc::c_int
                    };
                    high = if (*parser).encoding as libc::c_uint
                        == YAML_UTF16LE_ENCODING as libc::c_int as libc::c_uint
                    {
                        1 as libc::c_int
                    } else {
                        0 as libc::c_int
                    };
                    if raw_unread < 2 as libc::c_int as libc::c_ulong {
                        if (*parser).eof != 0 {
                            return yaml_parser_set_reader_error(
                                parser,
                                b"incomplete UTF-16 character\0" as *const u8
                                    as *const libc::c_char,
                                (*parser).offset,
                                -(1 as libc::c_int),
                            );
                        }
                        incomplete = 1 as libc::c_int;
                    } else {
                        value = (*((*parser).raw_buffer.pointer).offset(low as isize)
                            as libc::c_int
                            + ((*((*parser).raw_buffer.pointer).offset(high as isize)
                                as libc::c_int)
                                << 8 as libc::c_int))
                            as libc::c_uint;
                        if value & 0xfc00 as libc::c_int as libc::c_uint
                            == 0xdc00 as libc::c_int as libc::c_uint
                        {
                            return yaml_parser_set_reader_error(
                                parser,
                                b"unexpected low surrogate area\0" as *const u8
                                    as *const libc::c_char,
                                (*parser).offset,
                                value as libc::c_int,
                            );
                        }
                        if value & 0xfc00 as libc::c_int as libc::c_uint
                            == 0xd800 as libc::c_int as libc::c_uint
                        {
                            width = 4 as libc::c_int as libc::c_uint;
                            if raw_unread < 4 as libc::c_int as libc::c_ulong {
                                if (*parser).eof != 0 {
                                    return yaml_parser_set_reader_error(
                                        parser,
                                        b"incomplete UTF-16 surrogate pair\0" as *const u8
                                            as *const libc::c_char,
                                        (*parser).offset,
                                        -(1 as libc::c_int),
                                    );
                                }
                                incomplete = 1 as libc::c_int;
                            } else {
                                value2 = (*((*parser).raw_buffer.pointer)
                                    .offset((low + 2 as libc::c_int) as isize)
                                    as libc::c_int
                                    + ((*((*parser).raw_buffer.pointer)
                                        .offset((high + 2 as libc::c_int) as isize)
                                        as libc::c_int)
                                        << 8 as libc::c_int))
                                    as libc::c_uint;
                                if value2 & 0xfc00 as libc::c_int as libc::c_uint
                                    != 0xdc00 as libc::c_int as libc::c_uint
                                {
                                    return yaml_parser_set_reader_error(
                                        parser,
                                        b"expected low surrogate area\0" as *const u8
                                            as *const libc::c_char,
                                        ((*parser).offset)
                                            .wrapping_add(2 as libc::c_int as libc::c_ulong),
                                        value2 as libc::c_int,
                                    );
                                }
                                value = (0x10000 as libc::c_int as libc::c_uint)
                                    .wrapping_add(
                                        (value & 0x3ff as libc::c_int as libc::c_uint)
                                            << 10 as libc::c_int,
                                    )
                                    .wrapping_add(value2 & 0x3ff as libc::c_int as libc::c_uint);
                            }
                        } else {
                            width = 2 as libc::c_int as libc::c_uint;
                        }
                    }
                }
                _ => {
                    'c_12528: {};
                }
            }
            if incomplete != 0 {
                break;
            }
            if !(value == 0x9 as libc::c_int as libc::c_uint
                || value == 0xa as libc::c_int as libc::c_uint
                || value == 0xd as libc::c_int as libc::c_uint
                || value >= 0x20 as libc::c_int as libc::c_uint
                    && value <= 0x7e as libc::c_int as libc::c_uint
                || value == 0x85 as libc::c_int as libc::c_uint
                || value >= 0xa0 as libc::c_int as libc::c_uint
                    && value <= 0xd7ff as libc::c_int as libc::c_uint
                || value >= 0xe000 as libc::c_int as libc::c_uint
                    && value <= 0xfffd as libc::c_int as libc::c_uint
                || value >= 0x10000 as libc::c_int as libc::c_uint
                    && value <= 0x10ffff as libc::c_int as libc::c_uint)
            {
                return yaml_parser_set_reader_error(
                    parser,
                    b"control characters are not allowed\0" as *const u8 as *const libc::c_char,
                    (*parser).offset,
                    value as libc::c_int,
                );
            }
            (*parser).raw_buffer.pointer = ((*parser).raw_buffer.pointer).offset(width as isize);
            (*parser).offset = ((*parser).offset as libc::c_ulong)
                .wrapping_add(width as libc::c_ulong) as size_t
                as size_t;
            if value <= 0x7f as libc::c_int as libc::c_uint {
                let fresh447 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh447 = value as yaml_char_t;
            } else if value <= 0x7ff as libc::c_int as libc::c_uint {
                let fresh448 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh448 = (0xc0 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 6 as libc::c_int)
                    as yaml_char_t;
                let fresh449 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh449 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
            } else if value <= 0xffff as libc::c_int as libc::c_uint {
                let fresh450 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh450 = (0xe0 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 12 as libc::c_int)
                    as yaml_char_t;
                let fresh451 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh451 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
                let fresh452 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh452 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
            } else {
                let fresh453 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh453 = (0xf0 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 18 as libc::c_int)
                    as yaml_char_t;
                let fresh454 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh454 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 12 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
                let fresh455 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh455 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
                let fresh456 = (*parser).buffer.last;
                (*parser).buffer.last = ((*parser).buffer.last).offset(1);
                *fresh456 = (0x80 as libc::c_int as libc::c_uint)
                    .wrapping_add(value & 0x3f as libc::c_int as libc::c_uint)
                    as yaml_char_t;
            }
            (*parser).unread = ((*parser).unread).wrapping_add(1);
            (*parser).unread;
        }
        if (*parser).eof != 0 {
            let fresh457 = (*parser).buffer.last;
            (*parser).buffer.last = ((*parser).buffer.last).offset(1);
            *fresh457 = '\0' as i32 as yaml_char_t;
            (*parser).unread = ((*parser).unread).wrapping_add(1);
            (*parser).unread;
            return 1 as libc::c_int;
        }
    }
    if (*parser).offset
        >= (!(0 as libc::c_int as size_t)).wrapping_div(2 as libc::c_int as libc::c_ulong)
    {
        return yaml_parser_set_reader_error(
            parser,
            b"input is too long\0" as *const u8 as *const libc::c_char,
            (*parser).offset,
            -(1 as libc::c_int),
        );
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_scan(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
) -> libc::c_int {
    if !parser.is_null() {
    } else {
        __assert_fail(
            b"parser\0" as *const u8 as *const libc::c_char,
            b"./scanner.c\0" as *const u8 as *const libc::c_char,
            745 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                b"int yaml_parser_scan(yaml_parser_t *, yaml_token_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_50196: {
        if !parser.is_null() {
        } else {
            __assert_fail(
                b"parser\0" as *const u8 as *const libc::c_char,
                b"./scanner.c\0" as *const u8 as *const libc::c_char,
                745 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                    b"int yaml_parser_scan(yaml_parser_t *, yaml_token_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if !token.is_null() {
    } else {
        __assert_fail(
            b"token\0" as *const u8 as *const libc::c_char,
            b"./scanner.c\0" as *const u8 as *const libc::c_char,
            746 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                b"int yaml_parser_scan(yaml_parser_t *, yaml_token_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_50164: {
        if !token.is_null() {
        } else {
            __assert_fail(
                b"token\0" as *const u8 as *const libc::c_char,
                b"./scanner.c\0" as *const u8 as *const libc::c_char,
                746 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 54], &[libc::c_char; 54]>(
                    b"int yaml_parser_scan(yaml_parser_t *, yaml_token_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    memset(
        token as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    if (*parser).stream_end_produced != 0 || (*parser).error as libc::c_uint != 0 {
        return 1 as libc::c_int;
    }
    if (*parser).token_available == 0 {
        if yaml_parser_fetch_more_tokens(parser) == 0 {
            return 0 as libc::c_int;
        }
    }
    let fresh458 = (*parser).tokens.head;
    (*parser).tokens.head = ((*parser).tokens.head).offset(1);
    *token = *fresh458;
    (*parser).token_available = 0 as libc::c_int;
    (*parser).tokens_parsed = ((*parser).tokens_parsed).wrapping_add(1);
    (*parser).tokens_parsed;
    if (*token).type_0 as libc::c_uint == YAML_STREAM_END_TOKEN as libc::c_int as libc::c_uint {
        (*parser).stream_end_produced = 1 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_set_scanner_error(
    mut parser: *mut yaml_parser_t,
    mut context: *const libc::c_char,
    mut context_mark: yaml_mark_t,
    mut problem: *const libc::c_char,
) -> libc::c_int {
    (*parser).error = YAML_SCANNER_ERROR;
    (*parser).context = context;
    (*parser).context_mark = context_mark;
    (*parser).problem = problem;
    (*parser).problem_mark = (*parser).mark;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_parser_fetch_more_tokens(
    mut parser: *mut yaml_parser_t,
) -> libc::c_int {
    let mut need_more_tokens: libc::c_int = 0;
    loop {
        need_more_tokens = 0 as libc::c_int;
        if (*parser).tokens.head == (*parser).tokens.tail {
            need_more_tokens = 1 as libc::c_int;
        } else {
            let mut simple_key: *mut yaml_simple_key_t = 0 as *mut yaml_simple_key_t;
            if yaml_parser_stale_simple_keys(parser) == 0 {
                return 0 as libc::c_int;
            }
            simple_key = (*parser).simple_keys.start;
            while simple_key != (*parser).simple_keys.top {
                if (*simple_key).possible != 0
                    && (*simple_key).token_number == (*parser).tokens_parsed
                {
                    need_more_tokens = 1 as libc::c_int;
                    break;
                } else {
                    simple_key = simple_key.offset(1);
                    simple_key;
                }
            }
        }
        if need_more_tokens == 0 {
            break;
        }
        if yaml_parser_fetch_next_token(parser) == 0 {
            return 0 as libc::c_int;
        }
    }
    (*parser).token_available = 1 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_next_token(mut parser: *mut yaml_parser_t) -> libc::c_int {
    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
    } == 0
    {
        return 0 as libc::c_int;
    }
    if (*parser).stream_start_produced == 0 {
        return yaml_parser_fetch_stream_start(parser);
    }
    if yaml_parser_scan_to_next_token(parser) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_stale_simple_keys(parser) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_unroll_indent(parser, (*parser).mark.column as ptrdiff_t) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).unread >= 4 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 4 as libc::c_int as size_t)
    } == 0
    {
        return 0 as libc::c_int;
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '\0' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_stream_end(parser);
    }
    if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '%' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_directive(parser);
    }
    if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        && (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                == '\t' as i32 as yaml_char_t as libc::c_int
            || (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == '\0' as i32 as yaml_char_t as libc::c_int))
    {
        return yaml_parser_fetch_document_indicator(parser, YAML_DOCUMENT_START_TOKEN);
    }
    if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '.' as i32 as yaml_char_t as libc::c_int
        && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            == '.' as i32 as yaml_char_t as libc::c_int
        && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
            == '.' as i32 as yaml_char_t as libc::c_int
        && (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                == '\t' as i32 as yaml_char_t as libc::c_int
            || (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize) as libc::c_int
                    == '\0' as i32 as yaml_char_t as libc::c_int))
    {
        return yaml_parser_fetch_document_indicator(parser, YAML_DOCUMENT_END_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '[' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_collection_start(parser, YAML_FLOW_SEQUENCE_START_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '{' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_collection_start(parser, YAML_FLOW_MAPPING_START_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ']' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_collection_end(parser, YAML_FLOW_SEQUENCE_END_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '}' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_collection_end(parser, YAML_FLOW_MAPPING_END_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ',' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_entry(parser);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '-' as i32 as yaml_char_t as libc::c_int
        && (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == '\t' as i32 as yaml_char_t as libc::c_int
            || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\0' as i32 as yaml_char_t as libc::c_int))
    {
        return yaml_parser_fetch_block_entry(parser);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '?' as i32 as yaml_char_t as libc::c_int
        && ((*parser).flow_level != 0
            || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
                || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\0' as i32 as yaml_char_t as libc::c_int)))
    {
        return yaml_parser_fetch_key(parser);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ':' as i32 as yaml_char_t as libc::c_int
        && ((*parser).flow_level != 0
            || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
                || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\0' as i32 as yaml_char_t as libc::c_int)))
    {
        return yaml_parser_fetch_value(parser);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '*' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_anchor(parser, YAML_ALIAS_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '&' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_anchor(parser, YAML_ANCHOR_TOKEN);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '!' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_tag(parser);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '|' as i32 as yaml_char_t as libc::c_int
        && (*parser).flow_level == 0
    {
        return yaml_parser_fetch_block_scalar(parser, 1 as libc::c_int);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '>' as i32 as yaml_char_t as libc::c_int
        && (*parser).flow_level == 0
    {
        return yaml_parser_fetch_block_scalar(parser, 0 as libc::c_int);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '\'' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_scalar(parser, 1 as libc::c_int);
    }
    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '"' as i32 as yaml_char_t as libc::c_int
    {
        return yaml_parser_fetch_flow_scalar(parser, 0 as libc::c_int);
    }
    if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ' ' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\t' as i32 as yaml_char_t as libc::c_int
        || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\0' as i32 as yaml_char_t as libc::c_int)
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '?' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ':' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ',' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '[' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ']' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '{' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '}' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '#' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '&' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '*' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '!' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '|' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '>' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\'' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '"' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '%' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '@' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '`' as i32 as yaml_char_t as libc::c_int)
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32 as yaml_char_t as libc::c_int
            && !(*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int)
        || (*parser).flow_level == 0
            && (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '?' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ':' as i32 as yaml_char_t as libc::c_int)
            && !(*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
                || (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -88i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == -30i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 1 as libc::c_int) as isize)
                            as libc::c_int
                            == -128i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer)
                            .offset((1 as libc::c_int + 2 as libc::c_int) as isize)
                            as libc::c_int
                            == -87i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        == '\0' as i32 as yaml_char_t as libc::c_int))
    {
        return yaml_parser_fetch_plain_scalar(parser);
    }
    return yaml_parser_set_scanner_error(
        parser,
        b"while scanning for the next token\0" as *const u8 as *const libc::c_char,
        (*parser).mark,
        b"found character that cannot start any token\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn yaml_parser_stale_simple_keys(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut simple_key: *mut yaml_simple_key_t = 0 as *mut yaml_simple_key_t;
    simple_key = (*parser).simple_keys.start;
    while simple_key != (*parser).simple_keys.top {
        if (*simple_key).possible != 0
            && ((*simple_key).mark.line < (*parser).mark.line
                || ((*simple_key).mark.index).wrapping_add(1024 as libc::c_int as libc::c_ulong)
                    < (*parser).mark.index)
        {
            if (*simple_key).required != 0 {
                return yaml_parser_set_scanner_error(
                    parser,
                    b"while scanning a simple key\0" as *const u8 as *const libc::c_char,
                    (*simple_key).mark,
                    b"could not find expected ':'\0" as *const u8 as *const libc::c_char,
                );
            }
            (*simple_key).possible = 0 as libc::c_int;
        }
        simple_key = simple_key.offset(1);
        simple_key;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_save_simple_key(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut required: libc::c_int = ((*parser).flow_level == 0
        && (*parser).indent as libc::c_long == (*parser).mark.column as ptrdiff_t)
        as libc::c_int;
    if (*parser).simple_key_allowed != 0 {
        let mut simple_key: yaml_simple_key_t = yaml_simple_key_t {
            possible: 0,
            required: 0,
            token_number: 0,
            mark: yaml_mark_t {
                index: 0,
                line: 0,
                column: 0,
            },
        };
        simple_key.possible = 1 as libc::c_int;
        simple_key.required = required;
        simple_key.token_number =
            ((*parser).tokens_parsed)
                .wrapping_add(((*parser).tokens.tail).offset_from((*parser).tokens.head)
                    as libc::c_long as libc::c_ulong);
        simple_key.mark = (*parser).mark;
        if yaml_parser_remove_simple_key(parser) == 0 {
            return 0 as libc::c_int;
        }
        *((*parser).simple_keys.top).offset(-(1 as libc::c_int as isize)) = simple_key;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_remove_simple_key(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut simple_key: *mut yaml_simple_key_t =
        ((*parser).simple_keys.top).offset(-(1 as libc::c_int as isize));
    if (*simple_key).possible != 0 {
        if (*simple_key).required != 0 {
            return yaml_parser_set_scanner_error(
                parser,
                b"while scanning a simple key\0" as *const u8 as *const libc::c_char,
                (*simple_key).mark,
                b"could not find expected ':'\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    (*simple_key).possible = 0 as libc::c_int;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_increase_flow_level(
    mut parser: *mut yaml_parser_t,
) -> libc::c_int {
    let mut empty_simple_key: yaml_simple_key_t = {
        let mut init = yaml_simple_key_s {
            possible: 0 as libc::c_int,
            required: 0 as libc::c_int,
            token_number: 0 as libc::c_int as size_t,
            mark: {
                let mut init = yaml_mark_s {
                    index: 0 as libc::c_int as size_t,
                    line: 0 as libc::c_int as size_t,
                    column: 0 as libc::c_int as size_t,
                };
                init
            },
        };
        init
    };
    if if (*parser).simple_keys.top != (*parser).simple_keys.end
        || yaml_stack_extend(
            &mut (*parser).simple_keys.start as *mut *mut yaml_simple_key_t
                as *mut *mut libc::c_void,
            &mut (*parser).simple_keys.top as *mut *mut yaml_simple_key_t as *mut *mut libc::c_void,
            &mut (*parser).simple_keys.end as *mut *mut yaml_simple_key_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh459 = (*parser).simple_keys.top;
        (*parser).simple_keys.top = ((*parser).simple_keys.top).offset(1);
        *fresh459 = empty_simple_key;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    if (*parser).flow_level == 2147483647 as libc::c_int {
        (*parser).error = YAML_MEMORY_ERROR;
        return 0 as libc::c_int;
    }
    (*parser).flow_level += 1;
    (*parser).flow_level;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_decrease_flow_level(
    mut parser: *mut yaml_parser_t,
) -> libc::c_int {
    if (*parser).flow_level != 0 {
        (*parser).flow_level -= 1;
        (*parser).flow_level;
        (*parser).simple_keys.top = ((*parser).simple_keys.top).offset(-1);
        *(*parser).simple_keys.top;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_roll_indent(
    mut parser: *mut yaml_parser_t,
    mut column: ptrdiff_t,
    mut number: ptrdiff_t,
    mut type_0: yaml_token_type_t,
    mut mark: yaml_mark_t,
) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if (*parser).flow_level != 0 {
        return 1 as libc::c_int;
    }
    if ((*parser).indent as libc::c_long) < column {
        if if (*parser).indents.top != (*parser).indents.end
            || yaml_stack_extend(
                &mut (*parser).indents.start as *mut *mut libc::c_int as *mut *mut libc::c_void,
                &mut (*parser).indents.top as *mut *mut libc::c_int as *mut *mut libc::c_void,
                &mut (*parser).indents.end as *mut *mut libc::c_int as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh460 = (*parser).indents.top;
            (*parser).indents.top = ((*parser).indents.top).offset(1);
            *fresh460 = (*parser).indent;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        if column > 2147483647 as libc::c_int as libc::c_long {
            (*parser).error = YAML_MEMORY_ERROR;
            return 0 as libc::c_int;
        }
        (*parser).indent = column as libc::c_int;
        memset(
            &mut token as *mut yaml_token_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
        );
        token.type_0 = type_0;
        token.start_mark = mark;
        token.end_mark = mark;
        if number == -(1 as libc::c_int) as libc::c_long {
            if if (*parser).tokens.tail != (*parser).tokens.end
                || yaml_queue_extend(
                    &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                    &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                    &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                    &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                ) != 0
            {
                let fresh461 = (*parser).tokens.tail;
                (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
                *fresh461 = token;
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0
            {
                return 0 as libc::c_int;
            }
        } else if if (*parser).tokens.tail != (*parser).tokens.end
            || yaml_queue_extend(
                &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            ) != 0
        {
            memmove(
                ((*parser).tokens.head)
                    .offset(
                        (number as libc::c_ulong).wrapping_sub((*parser).tokens_parsed) as isize,
                    )
                    .offset(1 as libc::c_int as isize) as *mut libc::c_void,
                ((*parser).tokens.head).offset(
                    (number as libc::c_ulong).wrapping_sub((*parser).tokens_parsed) as isize,
                ) as *const libc::c_void,
                (((*parser).tokens.tail).offset_from((*parser).tokens.head) as libc::c_long
                    as libc::c_ulong)
                    .wrapping_sub((number as libc::c_ulong).wrapping_sub((*parser).tokens_parsed))
                    .wrapping_mul(::core::mem::size_of::<yaml_token_t>() as libc::c_ulong),
            );
            *((*parser).tokens.head)
                .offset((number as libc::c_ulong).wrapping_sub((*parser).tokens_parsed) as isize) =
                token;
            (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
            (*parser).tokens.tail;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_unroll_indent(
    mut parser: *mut yaml_parser_t,
    mut column: ptrdiff_t,
) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if (*parser).flow_level != 0 {
        return 1 as libc::c_int;
    }
    while (*parser).indent as libc::c_long > column {
        memset(
            &mut token as *mut yaml_token_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
        );
        token.type_0 = YAML_BLOCK_END_TOKEN;
        token.start_mark = (*parser).mark;
        token.end_mark = (*parser).mark;
        if if (*parser).tokens.tail != (*parser).tokens.end
            || yaml_queue_extend(
                &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            ) != 0
        {
            let fresh462 = (*parser).tokens.tail;
            (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
            *fresh462 = token;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        (*parser).indents.top = ((*parser).indents.top).offset(-1);
        (*parser).indent = *(*parser).indents.top;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_stream_start(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut simple_key: yaml_simple_key_t = {
        let mut init = yaml_simple_key_s {
            possible: 0 as libc::c_int,
            required: 0 as libc::c_int,
            token_number: 0 as libc::c_int as size_t,
            mark: {
                let mut init = yaml_mark_s {
                    index: 0 as libc::c_int as size_t,
                    line: 0 as libc::c_int as size_t,
                    column: 0 as libc::c_int as size_t,
                };
                init
            },
        };
        init
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    (*parser).indent = -(1 as libc::c_int);
    if if (*parser).simple_keys.top != (*parser).simple_keys.end
        || yaml_stack_extend(
            &mut (*parser).simple_keys.start as *mut *mut yaml_simple_key_t
                as *mut *mut libc::c_void,
            &mut (*parser).simple_keys.top as *mut *mut yaml_simple_key_t as *mut *mut libc::c_void,
            &mut (*parser).simple_keys.end as *mut *mut yaml_simple_key_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh463 = (*parser).simple_keys.top;
        (*parser).simple_keys.top = ((*parser).simple_keys.top).offset(1);
        *fresh463 = simple_key;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 1 as libc::c_int;
    (*parser).stream_start_produced = 1 as libc::c_int;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_STREAM_START_TOKEN;
    token.start_mark = (*parser).mark;
    token.end_mark = (*parser).mark;
    token.data.stream_start.encoding = (*parser).encoding;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh464 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh464 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_stream_end(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if (*parser).mark.column != 0 as libc::c_int as libc::c_ulong {
        (*parser).mark.column = 0 as libc::c_int as size_t;
        (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
        (*parser).mark.line;
    }
    if yaml_parser_unroll_indent(parser, -(1 as libc::c_int) as ptrdiff_t) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_STREAM_END_TOKEN;
    token.start_mark = (*parser).mark;
    token.end_mark = (*parser).mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh465 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh465 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_directive(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_unroll_indent(parser, -(1 as libc::c_int) as ptrdiff_t) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    if yaml_parser_scan_directive(parser, &mut token) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh466 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh466 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_document_indicator(
    mut parser: *mut yaml_parser_t,
    mut type_0: yaml_token_type_t,
) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_unroll_indent(parser, -(1 as libc::c_int) as ptrdiff_t) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = type_0;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh467 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh467 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_flow_collection_start(
    mut parser: *mut yaml_parser_t,
    mut type_0: yaml_token_type_t,
) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_save_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_increase_flow_level(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 1 as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = type_0;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh468 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh468 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_flow_collection_end(
    mut parser: *mut yaml_parser_t,
    mut type_0: yaml_token_type_t,
) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    if yaml_parser_decrease_flow_level(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = type_0;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh469 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh469 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_flow_entry(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 1 as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_FLOW_ENTRY_TOKEN;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh470 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh470 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_block_entry(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if (*parser).flow_level == 0 {
        if (*parser).simple_key_allowed == 0 {
            return yaml_parser_set_scanner_error(
                parser,
                0 as *const libc::c_char,
                (*parser).mark,
                b"block sequence entries are not allowed in this context\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if yaml_parser_roll_indent(
            parser,
            (*parser).mark.column as ptrdiff_t,
            -(1 as libc::c_int) as ptrdiff_t,
            YAML_BLOCK_SEQUENCE_START_TOKEN,
            (*parser).mark,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 1 as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_BLOCK_ENTRY_TOKEN;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh471 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh471 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_key(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if (*parser).flow_level == 0 {
        if (*parser).simple_key_allowed == 0 {
            return yaml_parser_set_scanner_error(
                parser,
                0 as *const libc::c_char,
                (*parser).mark,
                b"mapping keys are not allowed in this context\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if yaml_parser_roll_indent(
            parser,
            (*parser).mark.column as ptrdiff_t,
            -(1 as libc::c_int) as ptrdiff_t,
            YAML_BLOCK_MAPPING_START_TOKEN,
            (*parser).mark,
        ) == 0
        {
            return 0 as libc::c_int;
        }
    }
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = ((*parser).flow_level == 0) as libc::c_int;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_KEY_TOKEN;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh472 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh472 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_value(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    let mut simple_key: *mut yaml_simple_key_t =
        ((*parser).simple_keys.top).offset(-(1 as libc::c_int as isize));
    if (*simple_key).possible != 0 {
        memset(
            &mut token as *mut yaml_token_t as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
        );
        token.type_0 = YAML_KEY_TOKEN;
        token.start_mark = (*simple_key).mark;
        token.end_mark = (*simple_key).mark;
        if if (*parser).tokens.tail != (*parser).tokens.end
            || yaml_queue_extend(
                &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
                &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            ) != 0
        {
            memmove(
                ((*parser).tokens.head)
                    .offset(
                        ((*simple_key).token_number).wrapping_sub((*parser).tokens_parsed) as isize,
                    )
                    .offset(1 as libc::c_int as isize) as *mut libc::c_void,
                ((*parser).tokens.head).offset(
                    ((*simple_key).token_number).wrapping_sub((*parser).tokens_parsed) as isize,
                ) as *const libc::c_void,
                (((*parser).tokens.tail).offset_from((*parser).tokens.head) as libc::c_long
                    as libc::c_ulong)
                    .wrapping_sub(
                        ((*simple_key).token_number).wrapping_sub((*parser).tokens_parsed),
                    )
                    .wrapping_mul(::core::mem::size_of::<yaml_token_t>() as libc::c_ulong),
            );
            *((*parser).tokens.head).offset(
                ((*simple_key).token_number).wrapping_sub((*parser).tokens_parsed) as isize,
            ) = token;
            (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
            (*parser).tokens.tail;
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        if yaml_parser_roll_indent(
            parser,
            (*simple_key).mark.column as ptrdiff_t,
            (*simple_key).token_number as ptrdiff_t,
            YAML_BLOCK_MAPPING_START_TOKEN,
            (*simple_key).mark,
        ) == 0
        {
            return 0 as libc::c_int;
        }
        (*simple_key).possible = 0 as libc::c_int;
        (*parser).simple_key_allowed = 0 as libc::c_int;
    } else {
        if (*parser).flow_level == 0 {
            if (*parser).simple_key_allowed == 0 {
                return yaml_parser_set_scanner_error(
                    parser,
                    0 as *const libc::c_char,
                    (*parser).mark,
                    b"mapping values are not allowed in this context\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if yaml_parser_roll_indent(
                parser,
                (*parser).mark.column as ptrdiff_t,
                -(1 as libc::c_int) as ptrdiff_t,
                YAML_BLOCK_MAPPING_START_TOKEN,
                (*parser).mark,
            ) == 0
            {
                return 0 as libc::c_int;
            }
        }
        (*parser).simple_key_allowed = ((*parser).flow_level == 0) as libc::c_int;
    }
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    end_mark = (*parser).mark;
    memset(
        &mut token as *mut yaml_token_t as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
    );
    token.type_0 = YAML_VALUE_TOKEN;
    token.start_mark = start_mark;
    token.end_mark = end_mark;
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh473 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh473 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_anchor(
    mut parser: *mut yaml_parser_t,
    mut type_0: yaml_token_type_t,
) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_save_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    if yaml_parser_scan_anchor(parser, &mut token, type_0) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh474 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh474 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_tag(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_save_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    if yaml_parser_scan_tag(parser, &mut token) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh475 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh475 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_block_scalar(
    mut parser: *mut yaml_parser_t,
    mut literal: libc::c_int,
) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_remove_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 1 as libc::c_int;
    if yaml_parser_scan_block_scalar(parser, &mut token, literal) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh476 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh476 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_flow_scalar(
    mut parser: *mut yaml_parser_t,
    mut single: libc::c_int,
) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_save_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    if yaml_parser_scan_flow_scalar(parser, &mut token, single) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh477 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh477 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_fetch_plain_scalar(mut parser: *mut yaml_parser_t) -> libc::c_int {
    let mut token: yaml_token_t = yaml_token_t {
        type_0: YAML_NO_TOKEN,
        data: C2RustUnnamed {
            stream_start: C2RustUnnamed_6 {
                encoding: YAML_ANY_ENCODING,
            },
        },
        start_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
        end_mark: yaml_mark_t {
            index: 0,
            line: 0,
            column: 0,
        },
    };
    if yaml_parser_save_simple_key(parser) == 0 {
        return 0 as libc::c_int;
    }
    (*parser).simple_key_allowed = 0 as libc::c_int;
    if yaml_parser_scan_plain_scalar(parser, &mut token) == 0 {
        return 0 as libc::c_int;
    }
    if if (*parser).tokens.tail != (*parser).tokens.end
        || yaml_queue_extend(
            &mut (*parser).tokens.start as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.head as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.tail as *mut *mut yaml_token_t as *mut *mut libc::c_void,
            &mut (*parser).tokens.end as *mut *mut yaml_token_t as *mut *mut libc::c_void,
        ) != 0
    {
        let fresh478 = (*parser).tokens.tail;
        (*parser).tokens.tail = ((*parser).tokens.tail).offset(1);
        *fresh478 = token;
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        yaml_token_delete(&mut token);
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_to_next_token(mut parser: *mut yaml_parser_t) -> libc::c_int {
    loop {
        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
            && (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -17i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -69i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -65i32 as yaml_char_t as libc::c_int)
        {
            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
            (*parser).mark.index;
            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
            (*parser).mark.column;
            (*parser).unread = ((*parser).unread).wrapping_sub(1);
            (*parser).unread;
            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            );
        }
        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == ' ' as i32 as yaml_char_t as libc::c_int
            || ((*parser).flow_level != 0 || (*parser).simple_key_allowed == 0)
                && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\t' as i32 as yaml_char_t as libc::c_int
        {
            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
            (*parser).mark.index;
            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
            (*parser).mark.column;
            (*parser).unread = ((*parser).unread).wrapping_sub(1);
            (*parser).unread;
            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            );
            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                1 as libc::c_int
            } else {
                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
            } == 0
            {
                return 0 as libc::c_int;
            }
        }
        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '#' as i32 as yaml_char_t as libc::c_int
        {
            while !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\0' as i32 as yaml_char_t as libc::c_int)
            {
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                (*parser).mark.column;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                );
                if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0
                {
                    return 0 as libc::c_int;
                }
            }
        }
        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int)
        {
            break;
        }
        if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            && *((*parser).buffer.pointer).offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
        {
            (*parser).mark.index = ((*parser).mark.index as libc::c_ulong)
                .wrapping_add(2 as libc::c_int as libc::c_ulong)
                as size_t as size_t;
            (*parser).mark.column = 0 as libc::c_int as size_t;
            (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
            (*parser).mark.line;
            (*parser).unread = ((*parser).unread as libc::c_ulong)
                .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                as size_t as size_t;
            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(2 as libc::c_int as isize);
        } else {
            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -62i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -123i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -88i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == -30i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                        as libc::c_int
                        == -128i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer)
                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                        as libc::c_int
                        == -87i32 as yaml_char_t as libc::c_int
            {
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = 0 as libc::c_int as size_t;
                (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                (*parser).mark.line;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                );
            } else {
            };
        };
        if (*parser).flow_level == 0 {
            (*parser).simple_key_allowed = 1 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_directive(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut name: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut major: libc::c_int = 0;
    let mut minor: libc::c_int = 0;
    let mut handle: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut prefix: *mut yaml_char_t = 0 as *mut yaml_char_t;
    start_mark = (*parser).mark;
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    if !(yaml_parser_scan_directive_name(parser, start_mark, &mut name) == 0) {
        if strcmp(
            name as *mut libc::c_char,
            b"YAML\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            if yaml_parser_scan_version_directive_value(parser, start_mark, &mut major, &mut minor)
                == 0
            {
                current_block = 16029571914377962805;
            } else {
                end_mark = (*parser).mark;
                memset(
                    token as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                );
                (*token).type_0 = YAML_VERSION_DIRECTIVE_TOKEN;
                (*token).start_mark = start_mark;
                (*token).end_mark = end_mark;
                (*token).data.version_directive.major = major;
                (*token).data.version_directive.minor = minor;
                current_block = 1841672684692190573;
            }
        } else if strcmp(
            name as *mut libc::c_char,
            b"TAG\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
        {
            if yaml_parser_scan_tag_directive_value(parser, start_mark, &mut handle, &mut prefix)
                == 0
            {
                current_block = 16029571914377962805;
            } else {
                end_mark = (*parser).mark;
                memset(
                    token as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                );
                (*token).type_0 = YAML_TAG_DIRECTIVE_TOKEN;
                (*token).start_mark = start_mark;
                (*token).end_mark = end_mark;
                (*token).data.tag_directive.handle = handle;
                (*token).data.tag_directive.prefix = prefix;
                current_block = 1841672684692190573;
            }
        } else {
            yaml_parser_set_scanner_error(
                parser,
                b"while scanning a directive\0" as *const u8 as *const libc::c_char,
                start_mark,
                b"found unknown directive name\0" as *const u8 as *const libc::c_char,
            );
            current_block = 16029571914377962805;
        }
        match current_block {
            16029571914377962805 => {}
            _ => {
                if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0)
                {
                    loop {
                        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int)
                        {
                            current_block = 7149356873433890176;
                            break;
                        }
                        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                        (*parser).mark.index;
                        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                        (*parser).mark.column;
                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                        (*parser).unread;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) as isize,
                        );
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 16029571914377962805;
                            break;
                        }
                    }
                    match current_block {
                        16029571914377962805 => {}
                        _ => {
                            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '#' as i32 as yaml_char_t as libc::c_int
                            {
                                loop {
                                    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\r' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\n' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -62i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -123i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -30i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -128i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 2 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -88i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -30i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -128i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 2 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -87i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\0' as i32 as yaml_char_t as libc::c_int
                                    {
                                        current_block = 5601891728916014340;
                                        break;
                                    }
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                        1 as libc::c_int
                                    } else {
                                        yaml_parser_update_buffer(
                                            parser,
                                            1 as libc::c_int as size_t,
                                        )
                                    } == 0
                                    {
                                        current_block = 16029571914377962805;
                                        break;
                                    }
                                }
                            } else {
                                current_block = 5601891728916014340;
                            }
                            match current_block {
                                16029571914377962805 => {}
                                _ => {
                                    if !(*((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\r' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\n' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -62i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -123i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -30i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -128i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 2 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -88i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == -30i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -128i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 2 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == -87i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\0' as i32 as yaml_char_t as libc::c_int)
                                    {
                                        yaml_parser_set_scanner_error(
                                            parser,
                                            b"while scanning a directive\0" as *const u8
                                                as *const libc::c_char,
                                            start_mark,
                                            b"did not find expected comment or line break\0"
                                                as *const u8
                                                as *const libc::c_char,
                                        );
                                    } else {
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == -62i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (0 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -123i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (0 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (0 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -88i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (0 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (0 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -87i32 as yaml_char_t as libc::c_int
                                        {
                                            if if (*parser).unread
                                                >= 2 as libc::c_int as libc::c_ulong
                                            {
                                                1 as libc::c_int
                                            } else {
                                                yaml_parser_update_buffer(
                                                    parser,
                                                    2 as libc::c_int as size_t,
                                                )
                                            } == 0
                                            {
                                                current_block = 16029571914377962805;
                                            } else {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 1 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                                {
                                                    (*parser).mark.index = ((*parser).mark.index
                                                        as libc::c_ulong)
                                                        .wrapping_add(
                                                            2 as libc::c_int as libc::c_ulong,
                                                        )
                                                        as size_t
                                                        as size_t;
                                                    (*parser).mark.column =
                                                        0 as libc::c_int as size_t;
                                                    (*parser).mark.line =
                                                        ((*parser).mark.line).wrapping_add(1);
                                                    (*parser).mark.line;
                                                    (*parser).unread = ((*parser).unread
                                                        as libc::c_ulong)
                                                        .wrapping_sub(
                                                            2 as libc::c_int as libc::c_ulong,
                                                        )
                                                        as size_t
                                                        as size_t;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize);
                                                } else {
                                                    if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\r' as i32 as yaml_char_t as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == '\n' as i32 as yaml_char_t
                                                                as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -62i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -123i32 as yaml_char_t
                                                                    as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -30i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -128i32 as yaml_char_t
                                                                    as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 2 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -88i32 as yaml_char_t
                                                                    as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -30i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -128i32 as yaml_char_t
                                                                    as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 2 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -87i32 as yaml_char_t
                                                                    as libc::c_int
                                                    {
                                                        (*parser).mark.index =
                                                            ((*parser).mark.index).wrapping_add(1);
                                                        (*parser).mark.index;
                                                        (*parser).mark.column =
                                                            0 as libc::c_int as size_t;
                                                        (*parser).mark.line =
                                                            ((*parser).mark.line).wrapping_add(1);
                                                        (*parser).mark.line;
                                                        (*parser).unread =
                                                            ((*parser).unread).wrapping_sub(1);
                                                        (*parser).unread;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(
                                                                (if *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        0 as libc::c_int as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    & 0x80 as libc::c_int
                                                                    == 0 as libc::c_int
                                                                {
                                                                    1 as libc::c_int
                                                                } else {
                                                                    (if *((*parser).buffer.pointer)
                                                                        .offset(
                                                                            0 as libc::c_int
                                                                                as isize,
                                                                        )
                                                                        as libc::c_int
                                                                        & 0xe0 as libc::c_int
                                                                        == 0xc0 as libc::c_int
                                                                    {
                                                                        2 as libc::c_int
                                                                    } else {
                                                                        (if *((*parser)
                                                                            .buffer
                                                                            .pointer)
                                                                            .offset(
                                                                                0 as libc::c_int
                                                                                    as isize,
                                                                            )
                                                                            as libc::c_int
                                                                            & 0xf0 as libc::c_int
                                                                            == 0xe0 as libc::c_int
                                                                        {
                                                                            3 as libc::c_int
                                                                        } else {
                                                                            (if *((*parser)
                                                                                .buffer
                                                                                .pointer)
                                                                                .offset(
                                                                                    0 as libc::c_int
                                                                                        as isize,
                                                                                )
                                                                                as libc::c_int
                                                                                & 0xf8
                                                                                    as libc::c_int
                                                                                == 0xf0
                                                                                    as libc::c_int
                                                                            {
                                                                                4 as libc::c_int
                                                                            } else {
                                                                                0 as libc::c_int
                                                                            })
                                                                        })
                                                                    })
                                                                })
                                                                    as isize,
                                                            );
                                                    } else {
                                                    };
                                                };
                                                current_block = 2232869372362427478;
                                            }
                                        } else {
                                            current_block = 2232869372362427478;
                                        }
                                        match current_block {
                                            16029571914377962805 => {}
                                            _ => {
                                                yaml_free(name as *mut libc::c_void);
                                                return 1 as libc::c_int;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    yaml_free(prefix as *mut libc::c_void);
    yaml_free(handle as *mut libc::c_void);
    yaml_free(name as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_directive_name(
    mut parser: *mut yaml_parser_t,
    mut start_mark: yaml_mark_t,
    mut name: *mut *mut yaml_char_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0)
        {
            loop {
                if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    >= '0' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        <= '9' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        >= 'A' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= 'Z' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        >= 'a' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= 'z' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '_' as i32
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '-' as i32)
                {
                    current_block = 6873731126896040597;
                    break;
                }
                if if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                    || yaml_string_extend(&mut string.start, &mut string.pointer, &mut string.end)
                        != 0
                {
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } != 0
                {
                    if *(*parser).buffer.pointer as libc::c_int & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        let fresh479 = (*parser).buffer.pointer;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                        let fresh480 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        *fresh480 = *fresh479;
                    } else {
                        if *(*parser).buffer.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh481 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh482 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh482 = *fresh481;
                            let fresh483 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh484 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh484 = *fresh483;
                        } else {
                            if *(*parser).buffer.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh485 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh486 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh486 = *fresh485;
                                let fresh487 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh488 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh488 = *fresh487;
                                let fresh489 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh490 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh490 = *fresh489;
                            } else {
                                if *(*parser).buffer.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh491 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh492 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh492 = *fresh491;
                                    let fresh493 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh494 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh494 = *fresh493;
                                    let fresh495 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh496 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh496 = *fresh495;
                                    let fresh497 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh498 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh498 = *fresh497;
                                } else {
                                };
                            };
                        };
                    };
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                    (*parser).mark.column;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                } == 0
                {
                    current_block = 6107624561060187590;
                    break;
                }
                if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0
                {
                    current_block = 6107624561060187590;
                    break;
                }
            }
            match current_block {
                6107624561060187590 => {}
                _ => {
                    if string.start == string.pointer {
                        yaml_parser_set_scanner_error(
                            parser,
                            b"while scanning a directive\0" as *const u8 as *const libc::c_char,
                            start_mark,
                            b"could not find expected directive name\0" as *const u8
                                as *const libc::c_char,
                        );
                    } else if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                        as libc::c_int
                        == ' ' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\t' as i32 as yaml_char_t as libc::c_int
                        || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\r' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\n' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -62i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -123i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -30i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -128i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -88i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -30i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -128i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -87i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\0' as i32 as yaml_char_t as libc::c_int))
                    {
                        yaml_parser_set_scanner_error(
                            parser,
                            b"while scanning a directive\0" as *const u8 as *const libc::c_char,
                            start_mark,
                            b"found unexpected non-alphabetical character\0" as *const u8
                                as *const libc::c_char,
                        );
                    } else {
                        *name = string.start;
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_version_directive_value(
    mut parser: *mut yaml_parser_t,
    mut start_mark: yaml_mark_t,
    mut major: *mut libc::c_int,
    mut minor: *mut libc::c_int,
) -> libc::c_int {
    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
    } == 0
    {
        return 0 as libc::c_int;
    }
    while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == ' ' as i32 as yaml_char_t as libc::c_int
        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\t' as i32 as yaml_char_t as libc::c_int
    {
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
    }
    if yaml_parser_scan_version_directive_number(parser, start_mark, major) == 0 {
        return 0 as libc::c_int;
    }
    if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        == '.' as i32 as yaml_char_t as libc::c_int)
    {
        return yaml_parser_set_scanner_error(
            parser,
            b"while scanning a %YAML directive\0" as *const u8 as *const libc::c_char,
            start_mark,
            b"did not find expected digit or '.' character\0" as *const u8 as *const libc::c_char,
        );
    }
    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
    (*parser).mark.index;
    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
    (*parser).mark.column;
    (*parser).unread = ((*parser).unread).wrapping_sub(1);
    (*parser).unread;
    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            & 0x80 as libc::c_int
            == 0 as libc::c_int
        {
            1 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0xe0 as libc::c_int
                == 0xc0 as libc::c_int
            {
                2 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xf0 as libc::c_int
                    == 0xe0 as libc::c_int
                {
                    3 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf8 as libc::c_int
                        == 0xf0 as libc::c_int
                    {
                        4 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })
                })
            })
        }) as isize,
    );
    if yaml_parser_scan_version_directive_number(parser, start_mark, minor) == 0 {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_version_directive_number(
    mut parser: *mut yaml_parser_t,
    mut start_mark: yaml_mark_t,
    mut number: *mut libc::c_int,
) -> libc::c_int {
    let mut value: libc::c_int = 0 as libc::c_int;
    let mut length: size_t = 0 as libc::c_int as size_t;
    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
    } == 0
    {
        return 0 as libc::c_int;
    }
    while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
        >= '0' as i32 as yaml_char_t as libc::c_int
        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            <= '9' as i32 as yaml_char_t as libc::c_int
    {
        length = length.wrapping_add(1);
        if length > 9 as libc::c_int as libc::c_ulong {
            return yaml_parser_set_scanner_error(
                parser,
                b"while scanning a %YAML directive\0" as *const u8 as *const libc::c_char,
                start_mark,
                b"found extremely long version number\0" as *const u8 as *const libc::c_char,
            );
        }
        value = value * 10 as libc::c_int
            + (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                - '0' as i32 as yaml_char_t as libc::c_int);
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
    }
    if length == 0 {
        return yaml_parser_set_scanner_error(
            parser,
            b"while scanning a %YAML directive\0" as *const u8 as *const libc::c_char,
            start_mark,
            b"did not find expected version number\0" as *const u8 as *const libc::c_char,
        );
    }
    *number = value;
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_tag_directive_value(
    mut parser: *mut yaml_parser_t,
    mut start_mark: yaml_mark_t,
    mut handle: *mut *mut yaml_char_t,
    mut prefix: *mut *mut yaml_char_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut handle_value: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut prefix_value: *mut yaml_char_t = 0 as *mut yaml_char_t;
    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
    } == 0
    {
        current_block = 5771188629855923885;
    } else {
        current_block = 6239978542346980191;
    }
    '_error: loop {
        match current_block {
            5771188629855923885 => {
                yaml_free(handle_value as *mut libc::c_void);
                yaml_free(prefix_value as *mut libc::c_void);
                return 0 as libc::c_int;
            }
            _ => {
                if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == ' ' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '\t' as i32 as yaml_char_t as libc::c_int
                {
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                    (*parser).mark.column;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    );
                    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                        1 as libc::c_int
                    } else {
                        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                    } == 0
                    {
                        current_block = 5771188629855923885;
                    } else {
                        current_block = 6239978542346980191;
                    }
                } else {
                    if yaml_parser_scan_tag_handle(
                        parser,
                        1 as libc::c_int,
                        start_mark,
                        &mut handle_value,
                    ) == 0
                    {
                        current_block = 5771188629855923885;
                        continue;
                    }
                    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                        1 as libc::c_int
                    } else {
                        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                    } == 0
                    {
                        current_block = 5771188629855923885;
                        continue;
                    }
                    if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                        as libc::c_int
                        == ' ' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\t' as i32 as yaml_char_t as libc::c_int)
                    {
                        yaml_parser_set_scanner_error(
                            parser,
                            b"while scanning a %TAG directive\0" as *const u8
                                as *const libc::c_char,
                            start_mark,
                            b"did not find expected whitespace\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 5771188629855923885;
                    } else {
                        while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                        {
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                            (*parser).mark.column;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0x80 as libc::c_int
                                    == 0 as libc::c_int
                                {
                                    1 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xe0 as libc::c_int
                                        == 0xc0 as libc::c_int
                                    {
                                        2 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf0 as libc::c_int
                                            == 0xe0 as libc::c_int
                                        {
                                            3 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xf8 as libc::c_int
                                                == 0xf0 as libc::c_int
                                            {
                                                4 as libc::c_int
                                            } else {
                                                0 as libc::c_int
                                            })
                                        })
                                    })
                                }) as isize,
                            );
                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 5771188629855923885;
                                continue '_error;
                            }
                        }
                        if yaml_parser_scan_tag_uri(
                            parser,
                            1 as libc::c_int,
                            1 as libc::c_int,
                            0 as *mut yaml_char_t,
                            start_mark,
                            &mut prefix_value,
                        ) == 0
                        {
                            current_block = 5771188629855923885;
                            continue;
                        }
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 5771188629855923885;
                            continue;
                        }
                        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                            || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\r' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -62i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -123i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -87i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\0' as i32 as yaml_char_t as libc::c_int))
                        {
                            yaml_parser_set_scanner_error(
                                parser,
                                b"while scanning a %TAG directive\0" as *const u8
                                    as *const libc::c_char,
                                start_mark,
                                b"did not find expected whitespace or line break\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 5771188629855923885;
                        } else {
                            *handle = handle_value;
                            *prefix = prefix_value;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
}
unsafe extern "C" fn yaml_parser_scan_anchor(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
    mut type_0: yaml_token_type_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut length: libc::c_int = 0 as libc::c_int;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        start_mark = (*parser).mark;
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0)
        {
            loop {
                if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    >= '0' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        <= '9' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        >= 'A' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= 'Z' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        >= 'a' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= 'z' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '_' as i32
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '-' as i32)
                {
                    current_block = 17216689946888361452;
                    break;
                }
                if if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                    || yaml_string_extend(&mut string.start, &mut string.pointer, &mut string.end)
                        != 0
                {
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } != 0
                {
                    if *(*parser).buffer.pointer as libc::c_int & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        let fresh499 = (*parser).buffer.pointer;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                        let fresh500 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        *fresh500 = *fresh499;
                    } else {
                        if *(*parser).buffer.pointer as libc::c_int & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            let fresh501 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh502 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh502 = *fresh501;
                            let fresh503 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh504 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh504 = *fresh503;
                        } else {
                            if *(*parser).buffer.pointer as libc::c_int & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                let fresh505 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh506 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh506 = *fresh505;
                                let fresh507 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh508 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh508 = *fresh507;
                                let fresh509 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh510 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh510 = *fresh509;
                            } else {
                                if *(*parser).buffer.pointer as libc::c_int & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    let fresh511 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh512 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh512 = *fresh511;
                                    let fresh513 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh514 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh514 = *fresh513;
                                    let fresh515 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh516 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh516 = *fresh515;
                                    let fresh517 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh518 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh518 = *fresh517;
                                } else {
                                };
                            };
                        };
                    };
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                    (*parser).mark.column;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                } == 0
                {
                    current_block = 11019961990842886963;
                    break;
                }
                if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0
                {
                    current_block = 11019961990842886963;
                    break;
                }
                length += 1;
                length;
            }
            match current_block {
                11019961990842886963 => {}
                _ => {
                    end_mark = (*parser).mark;
                    if length == 0
                        || !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                            || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\r' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -62i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -123i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -87i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\0' as i32 as yaml_char_t as libc::c_int)
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '?' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ':' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ',' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ']' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '}' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '%' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '@' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '`' as i32 as yaml_char_t as libc::c_int)
                    {
                        yaml_parser_set_scanner_error(
                            parser,
                            if type_0 as libc::c_uint
                                == YAML_ANCHOR_TOKEN as libc::c_int as libc::c_uint
                            {
                                b"while scanning an anchor\0" as *const u8 as *const libc::c_char
                            } else {
                                b"while scanning an alias\0" as *const u8 as *const libc::c_char
                            },
                            start_mark,
                            b"did not find expected alphabetic or numeric character\0" as *const u8
                                as *const libc::c_char,
                        );
                    } else {
                        if type_0 as libc::c_uint
                            == YAML_ANCHOR_TOKEN as libc::c_int as libc::c_uint
                        {
                            memset(
                                token as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                            );
                            (*token).type_0 = YAML_ANCHOR_TOKEN;
                            (*token).start_mark = start_mark;
                            (*token).end_mark = end_mark;
                            (*token).data.anchor.value = string.start;
                        } else {
                            memset(
                                token as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                            );
                            (*token).type_0 = YAML_ALIAS_TOKEN;
                            (*token).start_mark = start_mark;
                            (*token).end_mark = end_mark;
                            (*token).data.alias.value = string.start;
                        }
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_tag(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut handle: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut suffix: *mut yaml_char_t = 0 as *mut yaml_char_t;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    start_mark = (*parser).mark;
    if !(if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
        1 as libc::c_int
    } else {
        yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
    } == 0)
    {
        if *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            == '<' as i32 as yaml_char_t as libc::c_int
        {
            handle = yaml_malloc(1 as libc::c_int as size_t) as *mut yaml_char_t;
            if handle.is_null() {
                current_block = 11893686597571198583;
            } else {
                *handle.offset(0 as libc::c_int as isize) = '\0' as i32 as yaml_char_t;
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                (*parser).mark.column;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                );
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                (*parser).mark.column;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                );
                if yaml_parser_scan_tag_uri(
                    parser,
                    1 as libc::c_int,
                    0 as libc::c_int,
                    0 as *mut yaml_char_t,
                    start_mark,
                    &mut suffix,
                ) == 0
                {
                    current_block = 11893686597571198583;
                } else if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                    as libc::c_int
                    == '>' as i32 as yaml_char_t as libc::c_int)
                {
                    yaml_parser_set_scanner_error(
                        parser,
                        b"while scanning a tag\0" as *const u8 as *const libc::c_char,
                        start_mark,
                        b"did not find the expected '>'\0" as *const u8 as *const libc::c_char,
                    );
                    current_block = 11893686597571198583;
                } else {
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                    (*parser).mark.column;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    );
                    current_block = 10652014663920648156;
                }
            }
        } else if yaml_parser_scan_tag_handle(parser, 0 as libc::c_int, start_mark, &mut handle)
            == 0
        {
            current_block = 11893686597571198583;
        } else if *handle.offset(0 as libc::c_int as isize) as libc::c_int == '!' as i32
            && *handle.offset(1 as libc::c_int as isize) as libc::c_int != '\0' as i32
            && *handle.offset(
                (strlen(handle as *mut libc::c_char))
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
            ) as libc::c_int
                == '!' as i32
        {
            if yaml_parser_scan_tag_uri(
                parser,
                0 as libc::c_int,
                0 as libc::c_int,
                0 as *mut yaml_char_t,
                start_mark,
                &mut suffix,
            ) == 0
            {
                current_block = 11893686597571198583;
            } else {
                current_block = 10652014663920648156;
            }
        } else if yaml_parser_scan_tag_uri(
            parser,
            0 as libc::c_int,
            0 as libc::c_int,
            handle,
            start_mark,
            &mut suffix,
        ) == 0
        {
            current_block = 11893686597571198583;
        } else {
            yaml_free(handle as *mut libc::c_void);
            handle = yaml_malloc(2 as libc::c_int as size_t) as *mut yaml_char_t;
            if handle.is_null() {
                current_block = 11893686597571198583;
            } else {
                *handle.offset(0 as libc::c_int as isize) = '!' as i32 as yaml_char_t;
                *handle.offset(1 as libc::c_int as isize) = '\0' as i32 as yaml_char_t;
                if *suffix.offset(0 as libc::c_int as isize) as libc::c_int == '\0' as i32 {
                    let mut tmp: *mut yaml_char_t = handle;
                    handle = suffix;
                    suffix = tmp;
                }
                current_block = 10652014663920648156;
            }
        }
        match current_block {
            11893686597571198583 => {}
            _ => {
                if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0)
                {
                    if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                        as libc::c_int
                        == ' ' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\t' as i32 as yaml_char_t as libc::c_int
                        || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\r' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\n' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -62i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -123i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -30i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -128i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -88i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == -30i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -128i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer)
                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                    as libc::c_int
                                    == -87i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\0' as i32 as yaml_char_t as libc::c_int))
                    {
                        if (*parser).flow_level == 0
                            || !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ',' as i32 as yaml_char_t as libc::c_int)
                        {
                            yaml_parser_set_scanner_error(
                                parser,
                                b"while scanning a tag\0" as *const u8 as *const libc::c_char,
                                start_mark,
                                b"did not find expected whitespace or line break\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 11893686597571198583;
                        } else {
                            current_block = 14648156034262866959;
                        }
                    } else {
                        current_block = 14648156034262866959;
                    }
                    match current_block {
                        11893686597571198583 => {}
                        _ => {
                            end_mark = (*parser).mark;
                            memset(
                                token as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                            );
                            (*token).type_0 = YAML_TAG_TOKEN;
                            (*token).start_mark = start_mark;
                            (*token).end_mark = end_mark;
                            (*token).data.tag.handle = handle;
                            (*token).data.tag.suffix = suffix;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_free(handle as *mut libc::c_void);
    yaml_free(suffix as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_tag_handle(
    mut parser: *mut yaml_parser_t,
    mut directive: libc::c_int,
    mut start_mark: yaml_mark_t,
    mut handle: *mut *mut yaml_char_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0)
        {
            if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '!' as i32 as yaml_char_t as libc::c_int)
            {
                yaml_parser_set_scanner_error(
                    parser,
                    if directive != 0 {
                        b"while scanning a tag directive\0" as *const u8 as *const libc::c_char
                    } else {
                        b"while scanning a tag\0" as *const u8 as *const libc::c_char
                    },
                    start_mark,
                    b"did not find expected '!'\0" as *const u8 as *const libc::c_char,
                );
            } else if !(if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                || yaml_string_extend(&mut string.start, &mut string.pointer, &mut string.end) != 0
            {
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } != 0
            {
                if *(*parser).buffer.pointer as libc::c_int & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    let fresh519 = (*parser).buffer.pointer;
                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                    let fresh520 = string.pointer;
                    string.pointer = (string.pointer).offset(1);
                    *fresh520 = *fresh519;
                } else {
                    if *(*parser).buffer.pointer as libc::c_int & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        let fresh521 = (*parser).buffer.pointer;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                        let fresh522 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        *fresh522 = *fresh521;
                        let fresh523 = (*parser).buffer.pointer;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                        let fresh524 = string.pointer;
                        string.pointer = (string.pointer).offset(1);
                        *fresh524 = *fresh523;
                    } else {
                        if *(*parser).buffer.pointer as libc::c_int & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            let fresh525 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh526 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh526 = *fresh525;
                            let fresh527 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh528 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh528 = *fresh527;
                            let fresh529 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh530 = string.pointer;
                            string.pointer = (string.pointer).offset(1);
                            *fresh530 = *fresh529;
                        } else {
                            if *(*parser).buffer.pointer as libc::c_int & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                let fresh531 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh532 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh532 = *fresh531;
                                let fresh533 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh534 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh534 = *fresh533;
                                let fresh535 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh536 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh536 = *fresh535;
                                let fresh537 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh538 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh538 = *fresh537;
                            } else {
                            };
                        };
                    };
                };
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                (*parser).mark.column;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                1 as libc::c_int
            } else {
                0 as libc::c_int
            } == 0)
            {
                if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0)
                {
                    loop {
                        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            >= '0' as i32 as yaml_char_t as libc::c_int
                            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                <= '9' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                >= 'A' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    <= 'Z' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                >= 'a' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    <= 'z' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '_' as i32
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '-' as i32)
                        {
                            current_block = 3640593987805443782;
                            break;
                        }
                        if if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                            || yaml_string_extend(
                                &mut string.start,
                                &mut string.pointer,
                                &mut string.end,
                            ) != 0
                        {
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } != 0
                        {
                            if *(*parser).buffer.pointer as libc::c_int & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                let fresh539 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh540 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh540 = *fresh539;
                            } else {
                                if *(*parser).buffer.pointer as libc::c_int & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    let fresh541 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh542 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh542 = *fresh541;
                                    let fresh543 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh544 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh544 = *fresh543;
                                } else {
                                    if *(*parser).buffer.pointer as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        let fresh545 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh546 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh546 = *fresh545;
                                        let fresh547 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh548 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh548 = *fresh547;
                                        let fresh549 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh550 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh550 = *fresh549;
                                    } else {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            let fresh551 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh552 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh552 = *fresh551;
                                            let fresh553 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh554 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh554 = *fresh553;
                                            let fresh555 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh556 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh556 = *fresh555;
                                            let fresh557 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh558 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh558 = *fresh557;
                                        } else {
                                        };
                                    };
                                };
                            };
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                            (*parser).mark.column;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                            1 as libc::c_int
                        } else {
                            0 as libc::c_int
                        } == 0
                        {
                            current_block = 5738165165822926723;
                            break;
                        }
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 5738165165822926723;
                            break;
                        }
                    }
                    match current_block {
                        5738165165822926723 => {}
                        _ => {
                            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '!' as i32 as yaml_char_t as libc::c_int
                            {
                                if if if (string.pointer).offset(5 as libc::c_int as isize)
                                    < string.end
                                    || yaml_string_extend(
                                        &mut string.start,
                                        &mut string.pointer,
                                        &mut string.end,
                                    ) != 0
                                {
                                    1 as libc::c_int
                                } else {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    0 as libc::c_int
                                } != 0
                                {
                                    if *(*parser).buffer.pointer as libc::c_int
                                        & 0x80 as libc::c_int
                                        == 0 as libc::c_int
                                    {
                                        let fresh559 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh560 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh560 = *fresh559;
                                    } else {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0xe0 as libc::c_int
                                            == 0xc0 as libc::c_int
                                        {
                                            let fresh561 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh562 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh562 = *fresh561;
                                            let fresh563 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh564 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh564 = *fresh563;
                                        } else {
                                            if *(*parser).buffer.pointer as libc::c_int
                                                & 0xf0 as libc::c_int
                                                == 0xe0 as libc::c_int
                                            {
                                                let fresh565 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh566 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh566 = *fresh565;
                                                let fresh567 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh568 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh568 = *fresh567;
                                                let fresh569 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh570 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh570 = *fresh569;
                                            } else {
                                                if *(*parser).buffer.pointer as libc::c_int
                                                    & 0xf8 as libc::c_int
                                                    == 0xf0 as libc::c_int
                                                {
                                                    let fresh571 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh572 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh572 = *fresh571;
                                                    let fresh573 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh574 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh574 = *fresh573;
                                                    let fresh575 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh576 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh576 = *fresh575;
                                                    let fresh577 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh578 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh578 = *fresh577;
                                                } else {
                                                };
                                            };
                                        };
                                    };
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    1 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                } == 0
                                {
                                    current_block = 5738165165822926723;
                                } else {
                                    current_block = 17860125682698302841;
                                }
                            } else if directive != 0
                                && !(*(string.start).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '!' as i32
                                    && *(string.start).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\0' as i32)
                            {
                                yaml_parser_set_scanner_error(
                                    parser,
                                    b"while parsing a tag directive\0" as *const u8
                                        as *const libc::c_char,
                                    start_mark,
                                    b"did not find expected '!'\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 5738165165822926723;
                            } else {
                                current_block = 17860125682698302841;
                            }
                            match current_block {
                                5738165165822926723 => {}
                                _ => {
                                    *handle = string.start;
                                    return 1 as libc::c_int;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_tag_uri(
    mut parser: *mut yaml_parser_t,
    mut uri_char: libc::c_int,
    mut directive: libc::c_int,
    mut head: *mut yaml_char_t,
    mut start_mark: yaml_mark_t,
    mut uri: *mut *mut yaml_char_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut length: size_t = if !head.is_null() {
        strlen(head as *mut libc::c_char)
    } else {
        0 as libc::c_int as libc::c_ulong
    };
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0
    {
        current_block = 7130474914167427671;
    } else {
        current_block = 6239978542346980191;
    }
    '_error: loop {
        match current_block {
            7130474914167427671 => {
                yaml_free(string.start as *mut libc::c_void);
                string.end = 0 as *mut yaml_char_t;
                string.pointer = string.end;
                string.start = string.pointer;
                return 0 as libc::c_int;
            }
            _ => {
                if (string.end).offset_from(string.start) as libc::c_long as size_t <= length {
                    if !(yaml_string_extend(
                        &mut string.start,
                        &mut string.pointer,
                        &mut string.end,
                    ) == 0)
                    {
                        current_block = 6239978542346980191;
                        continue;
                    }
                    (*parser).error = YAML_MEMORY_ERROR;
                    current_block = 7130474914167427671;
                } else {
                    if length > 1 as libc::c_int as libc::c_ulong {
                        memcpy(
                            string.start as *mut libc::c_void,
                            head.offset(1 as libc::c_int as isize) as *const libc::c_void,
                            length.wrapping_sub(1 as libc::c_int as libc::c_ulong),
                        );
                        string.pointer =
                            (string.pointer).offset(
                                length.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                            );
                    }
                    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                        1 as libc::c_int
                    } else {
                        yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                    } == 0
                    {
                        current_block = 7130474914167427671;
                        continue;
                    }
                    while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                        as libc::c_int
                        >= '0' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= '9' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            >= 'A' as i32 as yaml_char_t as libc::c_int
                            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                <= 'Z' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            >= 'a' as i32 as yaml_char_t as libc::c_int
                            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                <= 'z' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '_' as i32
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '-' as i32
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ';' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '/' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '?' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ':' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '@' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '&' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '=' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '+' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '$' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '.' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '%' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '!' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '~' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '*' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\'' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '(' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ')' as i32 as yaml_char_t as libc::c_int
                        || uri_char != 0
                            && (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ',' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '[' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == ']' as i32 as yaml_char_t as libc::c_int)
                    {
                        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '%' as i32 as yaml_char_t as libc::c_int
                        {
                            if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                                || yaml_string_extend(
                                    &mut string.start,
                                    &mut string.pointer,
                                    &mut string.end,
                                ) != 0
                            {
                                1 as libc::c_int
                            } else {
                                (*parser).error = YAML_MEMORY_ERROR;
                                0 as libc::c_int
                            } == 0
                            {
                                current_block = 7130474914167427671;
                                continue '_error;
                            }
                            if yaml_parser_scan_uri_escapes(
                                parser,
                                directive,
                                start_mark,
                                &mut string,
                            ) == 0
                            {
                                current_block = 7130474914167427671;
                                continue '_error;
                            }
                        } else if if if (string.pointer).offset(5 as libc::c_int as isize)
                            < string.end
                            || yaml_string_extend(
                                &mut string.start,
                                &mut string.pointer,
                                &mut string.end,
                            ) != 0
                        {
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } != 0
                        {
                            if *(*parser).buffer.pointer as libc::c_int & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                let fresh579 = (*parser).buffer.pointer;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                let fresh580 = string.pointer;
                                string.pointer = (string.pointer).offset(1);
                                *fresh580 = *fresh579;
                            } else {
                                if *(*parser).buffer.pointer as libc::c_int & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    let fresh581 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh582 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh582 = *fresh581;
                                    let fresh583 = (*parser).buffer.pointer;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                                    let fresh584 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh584 = *fresh583;
                                } else {
                                    if *(*parser).buffer.pointer as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        let fresh585 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh586 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh586 = *fresh585;
                                        let fresh587 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh588 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh588 = *fresh587;
                                        let fresh589 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh590 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh590 = *fresh589;
                                    } else {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            let fresh591 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh592 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh592 = *fresh591;
                                            let fresh593 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh594 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh594 = *fresh593;
                                            let fresh595 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh596 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh596 = *fresh595;
                                            let fresh597 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh598 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh598 = *fresh597;
                                        } else {
                                        };
                                    };
                                };
                            };
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                            (*parser).mark.column;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                            1 as libc::c_int
                        } else {
                            0 as libc::c_int
                        } == 0
                        {
                            current_block = 7130474914167427671;
                            continue '_error;
                        }
                        length = length.wrapping_add(1);
                        length;
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 7130474914167427671;
                            continue '_error;
                        }
                    }
                    if length == 0 {
                        if if (string.pointer).offset(5 as libc::c_int as isize) < string.end
                            || yaml_string_extend(
                                &mut string.start,
                                &mut string.pointer,
                                &mut string.end,
                            ) != 0
                        {
                            1 as libc::c_int
                        } else {
                            (*parser).error = YAML_MEMORY_ERROR;
                            0 as libc::c_int
                        } == 0
                        {
                            current_block = 7130474914167427671;
                            continue;
                        }
                        yaml_parser_set_scanner_error(
                            parser,
                            if directive != 0 {
                                b"while parsing a %TAG directive\0" as *const u8
                                    as *const libc::c_char
                            } else {
                                b"while parsing a tag\0" as *const u8 as *const libc::c_char
                            },
                            start_mark,
                            b"did not find expected tag URI\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 7130474914167427671;
                    } else {
                        *uri = string.start;
                        return 1 as libc::c_int;
                    }
                }
            }
        }
    }
}
unsafe extern "C" fn yaml_parser_scan_uri_escapes(
    mut parser: *mut yaml_parser_t,
    mut directive: libc::c_int,
    mut start_mark: yaml_mark_t,
    mut string: *mut yaml_string_t,
) -> libc::c_int {
    let mut width: libc::c_int = 0 as libc::c_int;
    loop {
        let mut octet: libc::c_uchar = 0 as libc::c_int as libc::c_uchar;
        if if (*parser).unread >= 3 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 3 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '%' as i32 as yaml_char_t as libc::c_int
            && (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                >= '0' as i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    <= '9' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    >= 'A' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        <= 'F' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    >= 'a' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                        as libc::c_int
                        <= 'f' as i32 as yaml_char_t as libc::c_int)
            && (*((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                >= '0' as i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    <= '9' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    >= 'A' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                        as libc::c_int
                        <= 'F' as i32 as yaml_char_t as libc::c_int
                || *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    >= 'a' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                        as libc::c_int
                        <= 'f' as i32 as yaml_char_t as libc::c_int))
        {
            return yaml_parser_set_scanner_error(
                parser,
                if directive != 0 {
                    b"while parsing a %TAG directive\0" as *const u8 as *const libc::c_char
                } else {
                    b"while parsing a tag\0" as *const u8 as *const libc::c_char
                },
                start_mark,
                b"did not find URI escaped octet\0" as *const u8 as *const libc::c_char,
            );
        }
        octet = (((if *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
            >= 'A' as i32 as yaml_char_t as libc::c_int
            && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                <= 'F' as i32 as yaml_char_t as libc::c_int
        {
            *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                - 'A' as i32 as yaml_char_t as libc::c_int
                + 10 as libc::c_int
        } else {
            (if *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                >= 'a' as i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    <= 'f' as i32 as yaml_char_t as libc::c_int
            {
                *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    - 'a' as i32 as yaml_char_t as libc::c_int
                    + 10 as libc::c_int
            } else {
                *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    - '0' as i32 as yaml_char_t as libc::c_int
            })
        }) << 4 as libc::c_int)
            + (if *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                >= 'A' as i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    <= 'F' as i32 as yaml_char_t as libc::c_int
            {
                *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    - 'A' as i32 as yaml_char_t as libc::c_int
                    + 10 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                    >= 'a' as i32 as yaml_char_t as libc::c_int
                    && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                        <= 'f' as i32 as yaml_char_t as libc::c_int
                {
                    *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                        - 'a' as i32 as yaml_char_t as libc::c_int
                        + 10 as libc::c_int
                } else {
                    *((*parser).buffer.pointer).offset(2 as libc::c_int as isize) as libc::c_int
                        - '0' as i32 as yaml_char_t as libc::c_int
                })
            })) as libc::c_uchar;
        if width == 0 {
            width = if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
                1 as libc::c_int
            } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
                2 as libc::c_int
            } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
                3 as libc::c_int
            } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            };
            if width == 0 {
                return yaml_parser_set_scanner_error(
                    parser,
                    if directive != 0 {
                        b"while parsing a %TAG directive\0" as *const u8 as *const libc::c_char
                    } else {
                        b"while parsing a tag\0" as *const u8 as *const libc::c_char
                    },
                    start_mark,
                    b"found an incorrect leading UTF-8 octet\0" as *const u8 as *const libc::c_char,
                );
            }
        } else if octet as libc::c_int & 0xc0 as libc::c_int != 0x80 as libc::c_int {
            return yaml_parser_set_scanner_error(
                parser,
                if directive != 0 {
                    b"while parsing a %TAG directive\0" as *const u8 as *const libc::c_char
                } else {
                    b"while parsing a tag\0" as *const u8 as *const libc::c_char
                },
                start_mark,
                b"found an incorrect trailing UTF-8 octet\0" as *const u8 as *const libc::c_char,
            );
        }
        let fresh599 = (*string).pointer;
        (*string).pointer = ((*string).pointer).offset(1);
        *fresh599 = octet;
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
        (*parser).mark.index;
        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
        (*parser).mark.column;
        (*parser).unread = ((*parser).unread).wrapping_sub(1);
        (*parser).unread;
        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                & 0x80 as libc::c_int
                == 0 as libc::c_int
            {
                1 as libc::c_int
            } else {
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0xe0 as libc::c_int
                    == 0xc0 as libc::c_int
                {
                    2 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xf0 as libc::c_int
                        == 0xe0 as libc::c_int
                    {
                        3 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf8 as libc::c_int
                            == 0xf0 as libc::c_int
                        {
                            4 as libc::c_int
                        } else {
                            0 as libc::c_int
                        })
                    })
                })
            }) as isize,
        );
        width -= 1;
        if !(width != 0) {
            break;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_block_scalar(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
    mut literal: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut leading_break: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut trailing_breaks: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut chomping: libc::c_int = 0 as libc::c_int;
    let mut increment: libc::c_int = 0 as libc::c_int;
    let mut indent: libc::c_int = 0 as libc::c_int;
    let mut leading_blank: libc::c_int = 0 as libc::c_int;
    let mut trailing_blank: libc::c_int = 0 as libc::c_int;
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        leading_break.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
        if !(if !(leading_break.start).is_null() {
            leading_break.pointer = leading_break.start;
            leading_break.end = (leading_break.start).offset(16 as libc::c_int as isize);
            memset(
                leading_break.start as *mut libc::c_void,
                0 as libc::c_int,
                16 as libc::c_int as libc::c_ulong,
            );
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0)
        {
            trailing_breaks.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
            if !(if !(trailing_breaks.start).is_null() {
                trailing_breaks.pointer = trailing_breaks.start;
                trailing_breaks.end = (trailing_breaks.start).offset(16 as libc::c_int as isize);
                memset(
                    trailing_breaks.start as *mut libc::c_void,
                    0 as libc::c_int,
                    16 as libc::c_int as libc::c_ulong,
                );
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                start_mark = (*parser).mark;
                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                (*parser).mark.index;
                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                (*parser).mark.column;
                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                (*parser).unread;
                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0x80 as libc::c_int
                        == 0 as libc::c_int
                    {
                        1 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xe0 as libc::c_int
                            == 0xc0 as libc::c_int
                        {
                            2 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf0 as libc::c_int
                                == 0xe0 as libc::c_int
                            {
                                3 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf8 as libc::c_int
                                    == 0xf0 as libc::c_int
                                {
                                    4 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                            })
                        })
                    }) as isize,
                );
                if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                    1 as libc::c_int
                } else {
                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                } == 0)
                {
                    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '+' as i32 as yaml_char_t as libc::c_int
                        || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '-' as i32 as yaml_char_t as libc::c_int
                    {
                        chomping = if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '+' as i32 as yaml_char_t as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            -(1 as libc::c_int)
                        };
                        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                        (*parser).mark.index;
                        (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                        (*parser).mark.column;
                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                        (*parser).unread;
                        (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0x80 as libc::c_int
                                == 0 as libc::c_int
                            {
                                1 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xe0 as libc::c_int
                                    == 0xc0 as libc::c_int
                                {
                                    2 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf0 as libc::c_int
                                        == 0xe0 as libc::c_int
                                    {
                                        3 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf8 as libc::c_int
                                            == 0xf0 as libc::c_int
                                        {
                                            4 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        })
                                    })
                                })
                            }) as isize,
                        );
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 11378994378708029365;
                        } else if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            >= '0' as i32 as yaml_char_t as libc::c_int
                            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                <= '9' as i32 as yaml_char_t as libc::c_int
                        {
                            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '0' as i32 as yaml_char_t as libc::c_int
                            {
                                yaml_parser_set_scanner_error(
                                    parser,
                                    b"while scanning a block scalar\0" as *const u8
                                        as *const libc::c_char,
                                    start_mark,
                                    b"found an indentation indicator equal to 0\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 11378994378708029365;
                            } else {
                                increment = *((*parser).buffer.pointer)
                                    .offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    - '0' as i32 as yaml_char_t as libc::c_int;
                                (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                (*parser).mark.index;
                                (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                (*parser).mark.column;
                                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                (*parser).unread;
                                (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0x80 as libc::c_int
                                        == 0 as libc::c_int
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xe0 as libc::c_int
                                            == 0xc0 as libc::c_int
                                        {
                                            2 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xf0 as libc::c_int
                                                == 0xe0 as libc::c_int
                                            {
                                                3 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf8 as libc::c_int
                                                    == 0xf0 as libc::c_int
                                                {
                                                    4 as libc::c_int
                                                } else {
                                                    0 as libc::c_int
                                                })
                                            })
                                        })
                                    }) as isize,
                                );
                                current_block = 6669252993407410313;
                            }
                        } else {
                            current_block = 6669252993407410313;
                        }
                    } else if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                        as libc::c_int
                        >= '0' as i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            <= '9' as i32 as yaml_char_t as libc::c_int
                    {
                        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '0' as i32 as yaml_char_t as libc::c_int
                        {
                            yaml_parser_set_scanner_error(
                                parser,
                                b"while scanning a block scalar\0" as *const u8
                                    as *const libc::c_char,
                                start_mark,
                                b"found an indentation indicator equal to 0\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 11378994378708029365;
                        } else {
                            increment = *((*parser).buffer.pointer)
                                .offset(0 as libc::c_int as isize)
                                as libc::c_int
                                - '0' as i32 as yaml_char_t as libc::c_int;
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                            (*parser).mark.column;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0x80 as libc::c_int
                                    == 0 as libc::c_int
                                {
                                    1 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xe0 as libc::c_int
                                        == 0xc0 as libc::c_int
                                    {
                                        2 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf0 as libc::c_int
                                            == 0xe0 as libc::c_int
                                        {
                                            3 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xf8 as libc::c_int
                                                == 0xf0 as libc::c_int
                                            {
                                                4 as libc::c_int
                                            } else {
                                                0 as libc::c_int
                                            })
                                        })
                                    })
                                }) as isize,
                            );
                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 11378994378708029365;
                            } else {
                                if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '+' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '-' as i32 as yaml_char_t as libc::c_int
                                {
                                    chomping = if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '+' as i32 as yaml_char_t as libc::c_int
                                    {
                                        1 as libc::c_int
                                    } else {
                                        -(1 as libc::c_int)
                                    };
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                }
                                current_block = 6669252993407410313;
                            }
                        }
                    } else {
                        current_block = 6669252993407410313;
                    }
                    match current_block {
                        11378994378708029365 => {}
                        _ => {
                            if !(if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0)
                            {
                                loop {
                                    if !(*((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == ' ' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\t' as i32 as yaml_char_t as libc::c_int)
                                    {
                                        current_block = 11932355480408055363;
                                        break;
                                    }
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                    if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                        1 as libc::c_int
                                    } else {
                                        yaml_parser_update_buffer(
                                            parser,
                                            1 as libc::c_int as size_t,
                                        )
                                    } == 0
                                    {
                                        current_block = 11378994378708029365;
                                        break;
                                    }
                                }
                                match current_block {
                                    11378994378708029365 => {}
                                    _ => {
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '#' as i32 as yaml_char_t as libc::c_int
                                        {
                                            loop {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -62i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -123i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 2 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -88i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 2 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -87i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\0' as i32 as yaml_char_t as libc::c_int
                                                {
                                                    current_block = 9520865839495247062;
                                                    break;
                                                }
                                                (*parser).mark.index =
                                                    ((*parser).mark.index).wrapping_add(1);
                                                (*parser).mark.index;
                                                (*parser).mark.column =
                                                    ((*parser).mark.column).wrapping_add(1);
                                                (*parser).mark.column;
                                                (*parser).unread =
                                                    ((*parser).unread).wrapping_sub(1);
                                                (*parser).unread;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0x80 as libc::c_int
                                                            == 0 as libc::c_int
                                                        {
                                                            1 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xe0 as libc::c_int
                                                                == 0xc0 as libc::c_int
                                                            {
                                                                2 as libc::c_int
                                                            } else {
                                                                (if *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        0 as libc::c_int as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    & 0xf0 as libc::c_int
                                                                    == 0xe0 as libc::c_int
                                                                {
                                                                    3 as libc::c_int
                                                                } else {
                                                                    (if *((*parser).buffer.pointer)
                                                                        .offset(
                                                                            0 as libc::c_int
                                                                                as isize,
                                                                        )
                                                                        as libc::c_int
                                                                        & 0xf8 as libc::c_int
                                                                        == 0xf0 as libc::c_int
                                                                    {
                                                                        4 as libc::c_int
                                                                    } else {
                                                                        0 as libc::c_int
                                                                    })
                                                                })
                                                            })
                                                        })
                                                            as isize,
                                                    );
                                                if if (*parser).unread
                                                    >= 1 as libc::c_int as libc::c_ulong
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    yaml_parser_update_buffer(
                                                        parser,
                                                        1 as libc::c_int as size_t,
                                                    )
                                                } == 0
                                                {
                                                    current_block = 11378994378708029365;
                                                    break;
                                                }
                                            }
                                        } else {
                                            current_block = 9520865839495247062;
                                        }
                                        match current_block {
                                            11378994378708029365 => {}
                                            _ => {
                                                if !(*((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\n' as i32 as yaml_char_t
                                                            as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -62i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -123i32 as yaml_char_t
                                                                as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t
                                                                as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 2 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -88i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 1 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t
                                                                as libc::c_int
                                                        && *((*parser).buffer.pointer).offset(
                                                            (0 as libc::c_int + 2 as libc::c_int)
                                                                as isize,
                                                        )
                                                            as libc::c_int
                                                            == -87i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\0' as i32 as yaml_char_t
                                                            as libc::c_int)
                                                {
                                                    yaml_parser_set_scanner_error(
                                                        parser,
                                                        b"while scanning a block scalar\0" as *const u8
                                                            as *const libc::c_char,
                                                        start_mark,
                                                        b"did not find expected comment or line break\0"
                                                            as *const u8 as *const libc::c_char,
                                                    );
                                                } else {
                                                    if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\r' as i32 as yaml_char_t as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == '\n' as i32 as yaml_char_t
                                                                as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -62i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -123i32 as yaml_char_t
                                                                    as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -30i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -128i32 as yaml_char_t
                                                                    as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 2 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -88i32 as yaml_char_t
                                                                    as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -30i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 1 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -128i32 as yaml_char_t
                                                                    as libc::c_int
                                                            && *((*parser).buffer.pointer).offset(
                                                                (0 as libc::c_int
                                                                    + 2 as libc::c_int)
                                                                    as isize,
                                                            )
                                                                as libc::c_int
                                                                == -87i32 as yaml_char_t
                                                                    as libc::c_int
                                                    {
                                                        if if (*parser).unread
                                                            >= 2 as libc::c_int as libc::c_ulong
                                                        {
                                                            1 as libc::c_int
                                                        } else {
                                                            yaml_parser_update_buffer(
                                                                parser,
                                                                2 as libc::c_int as size_t,
                                                            )
                                                        } == 0
                                                        {
                                                            current_block = 11378994378708029365;
                                                        } else {
                                                            if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                == '\r' as i32 as yaml_char_t
                                                                    as libc::c_int
                                                                && *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        (0 as libc::c_int
                                                                            + 1 as libc::c_int)
                                                                            as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    == '\n' as i32 as yaml_char_t
                                                                        as libc::c_int
                                                            {
                                                                (*parser).mark.index =
                                                                    ((*parser).mark.index
                                                                        as libc::c_ulong)
                                                                        .wrapping_add(
                                                                            2 as libc::c_int
                                                                                as libc::c_ulong,
                                                                        )
                                                                        as size_t
                                                                        as size_t;
                                                                (*parser).mark.column =
                                                                    0 as libc::c_int as size_t;
                                                                (*parser).mark.line =
                                                                    ((*parser).mark.line)
                                                                        .wrapping_add(1);
                                                                (*parser).mark.line;
                                                                (*parser).unread = ((*parser).unread
                                                                    as libc::c_ulong)
                                                                    .wrapping_sub(
                                                                        2 as libc::c_int
                                                                            as libc::c_ulong,
                                                                    )
                                                                    as size_t
                                                                    as size_t;
                                                                (*parser).buffer.pointer =
                                                                    ((*parser).buffer.pointer)
                                                                        .offset(
                                                                            2 as libc::c_int
                                                                                as isize,
                                                                        );
                                                            } else {
                                                                if *((*parser).buffer.pointer)
                                                                    .offset(0 as libc::c_int as isize) as libc::c_int
                                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                                    || *((*parser).buffer.pointer)
                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                                                    || *((*parser).buffer.pointer)
                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                        == -62i32 as yaml_char_t as libc::c_int
                                                                        && *((*parser).buffer.pointer)
                                                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                            as libc::c_int == -123i32 as yaml_char_t as libc::c_int
                                                                    || *((*parser).buffer.pointer)
                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                        == -30i32 as yaml_char_t as libc::c_int
                                                                        && *((*parser).buffer.pointer)
                                                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                            as libc::c_int == -128i32 as yaml_char_t as libc::c_int
                                                                        && *((*parser).buffer.pointer)
                                                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                                                            as libc::c_int == -88i32 as yaml_char_t as libc::c_int
                                                                    || *((*parser).buffer.pointer)
                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                        == -30i32 as yaml_char_t as libc::c_int
                                                                        && *((*parser).buffer.pointer)
                                                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                            as libc::c_int == -128i32 as yaml_char_t as libc::c_int
                                                                        && *((*parser).buffer.pointer)
                                                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                                                            as libc::c_int == -87i32 as yaml_char_t as libc::c_int
                                                                {
                                                                    (*parser)
                                                                        .mark
                                                                        .index = ((*parser).mark.index).wrapping_add(1);
                                                                    (*parser).mark.index;
                                                                    (*parser).mark.column = 0 as libc::c_int as size_t;
                                                                    (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                                                    (*parser).mark.line;
                                                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                                                    (*parser).unread;
                                                                    (*parser)
                                                                        .buffer
                                                                        .pointer = ((*parser).buffer.pointer)
                                                                        .offset(
                                                                            (if *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                & 0x80 as libc::c_int == 0 as libc::c_int
                                                                            {
                                                                                1 as libc::c_int
                                                                            } else {
                                                                                (if *((*parser).buffer.pointer)
                                                                                    .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                    & 0xe0 as libc::c_int == 0xc0 as libc::c_int
                                                                                {
                                                                                    2 as libc::c_int
                                                                                } else {
                                                                                    (if *((*parser).buffer.pointer)
                                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                        & 0xf0 as libc::c_int == 0xe0 as libc::c_int
                                                                                    {
                                                                                        3 as libc::c_int
                                                                                    } else {
                                                                                        (if *((*parser).buffer.pointer)
                                                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                            & 0xf8 as libc::c_int == 0xf0 as libc::c_int
                                                                                        {
                                                                                            4 as libc::c_int
                                                                                        } else {
                                                                                            0 as libc::c_int
                                                                                        })
                                                                                    })
                                                                                })
                                                                            }) as isize,
                                                                        );
                                                                } else {};
                                                            };
                                                            current_block = 11743904203796629665;
                                                        }
                                                    } else {
                                                        current_block = 11743904203796629665;
                                                    }
                                                    match current_block {
                                                        11378994378708029365 => {}
                                                        _ => {
                                                            end_mark = (*parser).mark;
                                                            if increment != 0 {
                                                                indent = if (*parser).indent
                                                                    >= 0 as libc::c_int
                                                                {
                                                                    (*parser).indent + increment
                                                                } else {
                                                                    increment
                                                                };
                                                            }
                                                            if !(yaml_parser_scan_block_scalar_breaks(
                                                                parser,
                                                                &mut indent,
                                                                &mut trailing_breaks,
                                                                start_mark,
                                                                &mut end_mark,
                                                            ) == 0)
                                                            {
                                                                if !(if (*parser).unread
                                                                    >= 1 as libc::c_int as libc::c_ulong
                                                                {
                                                                    1 as libc::c_int
                                                                } else {
                                                                    yaml_parser_update_buffer(
                                                                        parser,
                                                                        1 as libc::c_int as size_t,
                                                                    )
                                                                } == 0)
                                                                {
                                                                    's_226: loop {
                                                                        if !((*parser).mark.column as libc::c_int == indent
                                                                            && !(*((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\0' as i32 as yaml_char_t as libc::c_int))
                                                                        {
                                                                            current_block = 5807581744382915773;
                                                                            break;
                                                                        }
                                                                        trailing_blank = (*((*parser).buffer.pointer)
                                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                                            == ' ' as i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\t' as i32 as yaml_char_t as libc::c_int)
                                                                            as libc::c_int;
                                                                        if literal == 0
                                                                            && *leading_break.start as libc::c_int == '\n' as i32
                                                                            && leading_blank == 0 && trailing_blank == 0
                                                                        {
                                                                            if *trailing_breaks.start as libc::c_int == '\0' as i32 {
                                                                                if if (string.pointer).offset(5 as libc::c_int as isize)
                                                                                    < string.end
                                                                                    || yaml_string_extend(
                                                                                        &mut string.start,
                                                                                        &mut string.pointer,
                                                                                        &mut string.end,
                                                                                    ) != 0
                                                                                {
                                                                                    1 as libc::c_int
                                                                                } else {
                                                                                    (*parser).error = YAML_MEMORY_ERROR;
                                                                                    0 as libc::c_int
                                                                                } == 0
                                                                                {
                                                                                    current_block = 11378994378708029365;
                                                                                    break;
                                                                                }
                                                                                let fresh600 = string.pointer;
                                                                                string.pointer = (string.pointer).offset(1);
                                                                                *fresh600 = ' ' as i32 as yaml_char_t;
                                                                            }
                                                                            leading_break.pointer = leading_break.start;
                                                                            memset(
                                                                                leading_break.start as *mut libc::c_void,
                                                                                0 as libc::c_int,
                                                                                (leading_break.end).offset_from(leading_break.start)
                                                                                    as libc::c_long as libc::c_ulong,
                                                                            );
                                                                        } else {
                                                                            if if yaml_string_join(
                                                                                &mut string.start,
                                                                                &mut string.pointer,
                                                                                &mut string.end,
                                                                                &mut leading_break.start,
                                                                                &mut leading_break.pointer,
                                                                                &mut leading_break.end,
                                                                            ) != 0
                                                                            {
                                                                                leading_break.pointer = leading_break.start;
                                                                                1 as libc::c_int
                                                                            } else {
                                                                                (*parser).error = YAML_MEMORY_ERROR;
                                                                                0 as libc::c_int
                                                                            } == 0
                                                                            {
                                                                                current_block = 11378994378708029365;
                                                                                break;
                                                                            }
                                                                            leading_break.pointer = leading_break.start;
                                                                            memset(
                                                                                leading_break.start as *mut libc::c_void,
                                                                                0 as libc::c_int,
                                                                                (leading_break.end).offset_from(leading_break.start)
                                                                                    as libc::c_long as libc::c_ulong,
                                                                            );
                                                                        }
                                                                        if if yaml_string_join(
                                                                            &mut string.start,
                                                                            &mut string.pointer,
                                                                            &mut string.end,
                                                                            &mut trailing_breaks.start,
                                                                            &mut trailing_breaks.pointer,
                                                                            &mut trailing_breaks.end,
                                                                        ) != 0
                                                                        {
                                                                            trailing_breaks.pointer = trailing_breaks.start;
                                                                            1 as libc::c_int
                                                                        } else {
                                                                            (*parser).error = YAML_MEMORY_ERROR;
                                                                            0 as libc::c_int
                                                                        } == 0
                                                                        {
                                                                            current_block = 11378994378708029365;
                                                                            break;
                                                                        }
                                                                        trailing_breaks.pointer = trailing_breaks.start;
                                                                        memset(
                                                                            trailing_breaks.start as *mut libc::c_void,
                                                                            0 as libc::c_int,
                                                                            (trailing_breaks.end).offset_from(trailing_breaks.start)
                                                                                as libc::c_long as libc::c_ulong,
                                                                        );
                                                                        leading_blank = (*((*parser).buffer.pointer)
                                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                                            == ' ' as i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\t' as i32 as yaml_char_t as libc::c_int)
                                                                            as libc::c_int;
                                                                        while !(*((*parser).buffer.pointer)
                                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == -62i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                                    as libc::c_int == -123i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == -30i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                                    as libc::c_int == -128i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                                                                    as libc::c_int == -88i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == -30i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                                                                    as libc::c_int == -128i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                                                                    as libc::c_int == -87i32 as yaml_char_t as libc::c_int
                                                                            || *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\0' as i32 as yaml_char_t as libc::c_int)
                                                                        {
                                                                            if if if (string.pointer).offset(5 as libc::c_int as isize)
                                                                                < string.end
                                                                                || yaml_string_extend(
                                                                                    &mut string.start,
                                                                                    &mut string.pointer,
                                                                                    &mut string.end,
                                                                                ) != 0
                                                                            {
                                                                                1 as libc::c_int
                                                                            } else {
                                                                                (*parser).error = YAML_MEMORY_ERROR;
                                                                                0 as libc::c_int
                                                                            } != 0
                                                                            {
                                                                                if *(*parser).buffer.pointer as libc::c_int
                                                                                    & 0x80 as libc::c_int == 0 as libc::c_int
                                                                                {
                                                                                    let fresh601 = (*parser).buffer.pointer;
                                                                                    (*parser)
                                                                                        .buffer
                                                                                        .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                    let fresh602 = string.pointer;
                                                                                    string.pointer = (string.pointer).offset(1);
                                                                                    *fresh602 = *fresh601;
                                                                                } else {
                                                                                    if *(*parser).buffer.pointer as libc::c_int
                                                                                        & 0xe0 as libc::c_int == 0xc0 as libc::c_int
                                                                                    {
                                                                                        let fresh603 = (*parser).buffer.pointer;
                                                                                        (*parser)
                                                                                            .buffer
                                                                                            .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                        let fresh604 = string.pointer;
                                                                                        string.pointer = (string.pointer).offset(1);
                                                                                        *fresh604 = *fresh603;
                                                                                        let fresh605 = (*parser).buffer.pointer;
                                                                                        (*parser)
                                                                                            .buffer
                                                                                            .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                        let fresh606 = string.pointer;
                                                                                        string.pointer = (string.pointer).offset(1);
                                                                                        *fresh606 = *fresh605;
                                                                                    } else {
                                                                                        if *(*parser).buffer.pointer as libc::c_int
                                                                                            & 0xf0 as libc::c_int == 0xe0 as libc::c_int
                                                                                        {
                                                                                            let fresh607 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh608 = string.pointer;
                                                                                            string.pointer = (string.pointer).offset(1);
                                                                                            *fresh608 = *fresh607;
                                                                                            let fresh609 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh610 = string.pointer;
                                                                                            string.pointer = (string.pointer).offset(1);
                                                                                            *fresh610 = *fresh609;
                                                                                            let fresh611 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh612 = string.pointer;
                                                                                            string.pointer = (string.pointer).offset(1);
                                                                                            *fresh612 = *fresh611;
                                                                                        } else {
                                                                                            if *(*parser).buffer.pointer as libc::c_int
                                                                                                & 0xf8 as libc::c_int == 0xf0 as libc::c_int
                                                                                            {
                                                                                                let fresh613 = (*parser).buffer.pointer;
                                                                                                (*parser)
                                                                                                    .buffer
                                                                                                    .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                                let fresh614 = string.pointer;
                                                                                                string.pointer = (string.pointer).offset(1);
                                                                                                *fresh614 = *fresh613;
                                                                                                let fresh615 = (*parser).buffer.pointer;
                                                                                                (*parser)
                                                                                                    .buffer
                                                                                                    .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                                let fresh616 = string.pointer;
                                                                                                string.pointer = (string.pointer).offset(1);
                                                                                                *fresh616 = *fresh615;
                                                                                                let fresh617 = (*parser).buffer.pointer;
                                                                                                (*parser)
                                                                                                    .buffer
                                                                                                    .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                                let fresh618 = string.pointer;
                                                                                                string.pointer = (string.pointer).offset(1);
                                                                                                *fresh618 = *fresh617;
                                                                                                let fresh619 = (*parser).buffer.pointer;
                                                                                                (*parser)
                                                                                                    .buffer
                                                                                                    .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                                let fresh620 = string.pointer;
                                                                                                string.pointer = (string.pointer).offset(1);
                                                                                                *fresh620 = *fresh619;
                                                                                            } else {};
                                                                                        };
                                                                                    };
                                                                                };
                                                                                (*parser)
                                                                                    .mark
                                                                                    .index = ((*parser).mark.index).wrapping_add(1);
                                                                                (*parser).mark.index;
                                                                                (*parser)
                                                                                    .mark
                                                                                    .column = ((*parser).mark.column).wrapping_add(1);
                                                                                (*parser).mark.column;
                                                                                (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                                                                (*parser).unread;
                                                                                1 as libc::c_int
                                                                            } else {
                                                                                0 as libc::c_int
                                                                            } == 0
                                                                            {
                                                                                current_block = 11378994378708029365;
                                                                                break 's_226;
                                                                            }
                                                                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong
                                                                            {
                                                                                1 as libc::c_int
                                                                            } else {
                                                                                yaml_parser_update_buffer(
                                                                                    parser,
                                                                                    1 as libc::c_int as size_t,
                                                                                )
                                                                            } == 0
                                                                            {
                                                                                current_block = 11378994378708029365;
                                                                                break 's_226;
                                                                            }
                                                                        }
                                                                        if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong
                                                                        {
                                                                            1 as libc::c_int
                                                                        } else {
                                                                            yaml_parser_update_buffer(
                                                                                parser,
                                                                                2 as libc::c_int as size_t,
                                                                            )
                                                                        } == 0
                                                                        {
                                                                            current_block = 11378994378708029365;
                                                                            break;
                                                                        }
                                                                        if if if (leading_break.pointer)
                                                                            .offset(5 as libc::c_int as isize) < leading_break.end
                                                                            || yaml_string_extend(
                                                                                &mut leading_break.start,
                                                                                &mut leading_break.pointer,
                                                                                &mut leading_break.end,
                                                                            ) != 0
                                                                        {
                                                                            1 as libc::c_int
                                                                        } else {
                                                                            (*parser).error = YAML_MEMORY_ERROR;
                                                                            0 as libc::c_int
                                                                        } != 0
                                                                        {
                                                                            if *((*parser).buffer.pointer)
                                                                                .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                == '\r' as i32 as yaml_char_t as libc::c_int
                                                                                && *((*parser).buffer.pointer)
                                                                                    .offset(1 as libc::c_int as isize) as libc::c_int
                                                                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                                                            {
                                                                                let fresh621 = leading_break.pointer;
                                                                                leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                *fresh621 = '\n' as i32 as yaml_char_t;
                                                                                (*parser)
                                                                                    .buffer
                                                                                    .pointer = ((*parser).buffer.pointer)
                                                                                    .offset(2 as libc::c_int as isize);
                                                                                (*parser)
                                                                                    .mark
                                                                                    .index = ((*parser).mark.index as libc::c_ulong)
                                                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong) as size_t
                                                                                    as size_t;
                                                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                                                (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                                                                (*parser).mark.line;
                                                                                (*parser)
                                                                                    .unread = ((*parser).unread as libc::c_ulong)
                                                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong) as size_t
                                                                                    as size_t;
                                                                            } else {
                                                                                if *((*parser).buffer.pointer)
                                                                                    .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                                                    || *((*parser).buffer.pointer)
                                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                                                                {
                                                                                    let fresh622 = leading_break.pointer;
                                                                                    leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                    *fresh622 = '\n' as i32 as yaml_char_t;
                                                                                    (*parser)
                                                                                        .buffer
                                                                                        .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                    (*parser).buffer.pointer;
                                                                                    (*parser)
                                                                                        .mark
                                                                                        .index = ((*parser).mark.index).wrapping_add(1);
                                                                                    (*parser).mark.index;
                                                                                    (*parser).mark.column = 0 as libc::c_int as size_t;
                                                                                    (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                                                                    (*parser).mark.line;
                                                                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                                                                    (*parser).unread;
                                                                                } else {
                                                                                    if *((*parser).buffer.pointer)
                                                                                        .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                        == -62i32 as yaml_char_t as libc::c_int
                                                                                        && *((*parser).buffer.pointer)
                                                                                            .offset(1 as libc::c_int as isize) as libc::c_int
                                                                                            == -123i32 as yaml_char_t as libc::c_int
                                                                                    {
                                                                                        let fresh623 = leading_break.pointer;
                                                                                        leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                        *fresh623 = '\n' as i32 as yaml_char_t;
                                                                                        (*parser)
                                                                                            .buffer
                                                                                            .pointer = ((*parser).buffer.pointer)
                                                                                            .offset(2 as libc::c_int as isize);
                                                                                        (*parser)
                                                                                            .mark
                                                                                            .index = ((*parser).mark.index).wrapping_add(1);
                                                                                        (*parser).mark.index;
                                                                                        (*parser).mark.column = 0 as libc::c_int as size_t;
                                                                                        (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                                                                        (*parser).mark.line;
                                                                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                                                                        (*parser).unread;
                                                                                    } else {
                                                                                        if *((*parser).buffer.pointer)
                                                                                            .offset(0 as libc::c_int as isize) as libc::c_int
                                                                                            == -30i32 as yaml_char_t as libc::c_int
                                                                                            && *((*parser).buffer.pointer)
                                                                                                .offset(1 as libc::c_int as isize) as libc::c_int
                                                                                                == -128i32 as yaml_char_t as libc::c_int
                                                                                            && (*((*parser).buffer.pointer)
                                                                                                .offset(2 as libc::c_int as isize) as libc::c_int
                                                                                                == -88i32 as yaml_char_t as libc::c_int
                                                                                                || *((*parser).buffer.pointer)
                                                                                                    .offset(2 as libc::c_int as isize) as libc::c_int
                                                                                                    == -87i32 as yaml_char_t as libc::c_int)
                                                                                        {
                                                                                            let fresh624 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh625 = leading_break.pointer;
                                                                                            leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                            *fresh625 = *fresh624;
                                                                                            let fresh626 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh627 = leading_break.pointer;
                                                                                            leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                            *fresh627 = *fresh626;
                                                                                            let fresh628 = (*parser).buffer.pointer;
                                                                                            (*parser)
                                                                                                .buffer
                                                                                                .pointer = ((*parser).buffer.pointer).offset(1);
                                                                                            let fresh629 = leading_break.pointer;
                                                                                            leading_break.pointer = (leading_break.pointer).offset(1);
                                                                                            *fresh629 = *fresh628;
                                                                                            (*parser)
                                                                                                .mark
                                                                                                .index = ((*parser).mark.index).wrapping_add(1);
                                                                                            (*parser).mark.index;
                                                                                            (*parser).mark.column = 0 as libc::c_int as size_t;
                                                                                            (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                                                                            (*parser).mark.line;
                                                                                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                                                                            (*parser).unread;
                                                                                        } else {};
                                                                                    };
                                                                                };
                                                                            };
                                                                            1 as libc::c_int
                                                                        } else {
                                                                            0 as libc::c_int
                                                                        } == 0
                                                                        {
                                                                            current_block = 11378994378708029365;
                                                                            break;
                                                                        }
                                                                        if yaml_parser_scan_block_scalar_breaks(
                                                                            parser,
                                                                            &mut indent,
                                                                            &mut trailing_breaks,
                                                                            start_mark,
                                                                            &mut end_mark,
                                                                        ) == 0
                                                                        {
                                                                            current_block = 11378994378708029365;
                                                                            break;
                                                                        }
                                                                    }
                                                                    match current_block {
                                                                        11378994378708029365 => {}
                                                                        _ => {
                                                                            if chomping != -(1 as libc::c_int) {
                                                                                if if yaml_string_join(
                                                                                    &mut string.start,
                                                                                    &mut string.pointer,
                                                                                    &mut string.end,
                                                                                    &mut leading_break.start,
                                                                                    &mut leading_break.pointer,
                                                                                    &mut leading_break.end,
                                                                                ) != 0
                                                                                {
                                                                                    leading_break.pointer = leading_break.start;
                                                                                    1 as libc::c_int
                                                                                } else {
                                                                                    (*parser).error = YAML_MEMORY_ERROR;
                                                                                    0 as libc::c_int
                                                                                } == 0
                                                                                {
                                                                                    current_block = 11378994378708029365;
                                                                                } else {
                                                                                    current_block = 981995395831942902;
                                                                                }
                                                                            } else {
                                                                                current_block = 981995395831942902;
                                                                            }
                                                                            match current_block {
                                                                                11378994378708029365 => {}
                                                                                _ => {
                                                                                    if chomping == 1 as libc::c_int {
                                                                                        if if yaml_string_join(
                                                                                            &mut string.start,
                                                                                            &mut string.pointer,
                                                                                            &mut string.end,
                                                                                            &mut trailing_breaks.start,
                                                                                            &mut trailing_breaks.pointer,
                                                                                            &mut trailing_breaks.end,
                                                                                        ) != 0
                                                                                        {
                                                                                            trailing_breaks.pointer = trailing_breaks.start;
                                                                                            1 as libc::c_int
                                                                                        } else {
                                                                                            (*parser).error = YAML_MEMORY_ERROR;
                                                                                            0 as libc::c_int
                                                                                        } == 0
                                                                                        {
                                                                                            current_block = 11378994378708029365;
                                                                                        } else {
                                                                                            current_block = 16779030619667747692;
                                                                                        }
                                                                                    } else {
                                                                                        current_block = 16779030619667747692;
                                                                                    }
                                                                                    match current_block {
                                                                                        11378994378708029365 => {}
                                                                                        _ => {
                                                                                            memset(
                                                                                                token as *mut libc::c_void,
                                                                                                0 as libc::c_int,
                                                                                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                                                                                            );
                                                                                            (*token).type_0 = YAML_SCALAR_TOKEN;
                                                                                            (*token).start_mark = start_mark;
                                                                                            (*token).end_mark = end_mark;
                                                                                            (*token).data.scalar.value = string.start;
                                                                                            (*token)
                                                                                                .data
                                                                                                .scalar
                                                                                                .length = (string.pointer).offset_from(string.start)
                                                                                                as libc::c_long as size_t;
                                                                                            (*token)
                                                                                                .data
                                                                                                .scalar
                                                                                                .style = (if literal != 0 {
                                                                                                YAML_LITERAL_SCALAR_STYLE as libc::c_int
                                                                                            } else {
                                                                                                YAML_FOLDED_SCALAR_STYLE as libc::c_int
                                                                                            }) as yaml_scalar_style_t;
                                                                                            yaml_free(leading_break.start as *mut libc::c_void);
                                                                                            leading_break.end = 0 as *mut yaml_char_t;
                                                                                            leading_break.pointer = leading_break.end;
                                                                                            leading_break.start = leading_break.pointer;
                                                                                            yaml_free(trailing_breaks.start as *mut libc::c_void);
                                                                                            trailing_breaks.end = 0 as *mut yaml_char_t;
                                                                                            trailing_breaks.pointer = trailing_breaks.end;
                                                                                            trailing_breaks.start = trailing_breaks.pointer;
                                                                                            return 1 as libc::c_int;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    yaml_free(leading_break.start as *mut libc::c_void);
    leading_break.end = 0 as *mut yaml_char_t;
    leading_break.pointer = leading_break.end;
    leading_break.start = leading_break.pointer;
    yaml_free(trailing_breaks.start as *mut libc::c_void);
    trailing_breaks.end = 0 as *mut yaml_char_t;
    trailing_breaks.pointer = trailing_breaks.end;
    trailing_breaks.start = trailing_breaks.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_block_scalar_breaks(
    mut parser: *mut yaml_parser_t,
    mut indent: *mut libc::c_int,
    mut breaks: *mut yaml_string_t,
    mut start_mark: yaml_mark_t,
    mut end_mark: *mut yaml_mark_t,
) -> libc::c_int {
    let mut max_indent: libc::c_int = 0 as libc::c_int;
    *end_mark = (*parser).mark;
    loop {
        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        while (*indent == 0 || ((*parser).mark.column as libc::c_int) < *indent)
            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == ' ' as i32 as yaml_char_t as libc::c_int
        {
            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
            (*parser).mark.index;
            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
            (*parser).mark.column;
            (*parser).unread = ((*parser).unread).wrapping_sub(1);
            (*parser).unread;
            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    & 0x80 as libc::c_int
                    == 0 as libc::c_int
                {
                    1 as libc::c_int
                } else {
                    (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        & 0xe0 as libc::c_int
                        == 0xc0 as libc::c_int
                    {
                        2 as libc::c_int
                    } else {
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0xf0 as libc::c_int
                            == 0xe0 as libc::c_int
                        {
                            3 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xf8 as libc::c_int
                                == 0xf0 as libc::c_int
                            {
                                4 as libc::c_int
                            } else {
                                0 as libc::c_int
                            })
                        })
                    })
                }) as isize,
            );
            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                1 as libc::c_int
            } else {
                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
            } == 0
            {
                return 0 as libc::c_int;
            }
        }
        if (*parser).mark.column as libc::c_int > max_indent {
            max_indent = (*parser).mark.column as libc::c_int;
        }
        if (*indent == 0 || ((*parser).mark.column as libc::c_int) < *indent)
            && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\t' as i32 as yaml_char_t as libc::c_int
        {
            return yaml_parser_set_scanner_error(
                parser,
                b"while scanning a block scalar\0" as *const u8 as *const libc::c_char,
                start_mark,
                b"found a tab character where an indentation space is expected\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
            == '\r' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\n' as i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -62i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -123i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -88i32 as yaml_char_t as libc::c_int
            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == -30i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                    as libc::c_int
                    == -128i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer)
                    .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                    as libc::c_int
                    == -87i32 as yaml_char_t as libc::c_int)
        {
            break;
        }
        if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
            1 as libc::c_int
        } else {
            yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
        } == 0
        {
            return 0 as libc::c_int;
        }
        if if if ((*breaks).pointer).offset(5 as libc::c_int as isize) < (*breaks).end
            || yaml_string_extend(
                &mut (*breaks).start,
                &mut (*breaks).pointer,
                &mut (*breaks).end,
            ) != 0
        {
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } != 0
        {
            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                == '\r' as i32 as yaml_char_t as libc::c_int
                && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize) as libc::c_int
                    == '\n' as i32 as yaml_char_t as libc::c_int
            {
                let fresh630 = (*breaks).pointer;
                (*breaks).pointer = ((*breaks).pointer).offset(1);
                *fresh630 = '\n' as i32 as yaml_char_t;
                (*parser).buffer.pointer =
                    ((*parser).buffer.pointer).offset(2 as libc::c_int as isize);
                (*parser).mark.index = ((*parser).mark.index as libc::c_ulong)
                    .wrapping_add(2 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
                (*parser).mark.column = 0 as libc::c_int as size_t;
                (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                (*parser).mark.line;
                (*parser).unread = ((*parser).unread as libc::c_ulong)
                    .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                    as size_t as size_t;
            } else {
                if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                    == '\r' as i32 as yaml_char_t as libc::c_int
                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == '\n' as i32 as yaml_char_t as libc::c_int
                {
                    let fresh631 = (*breaks).pointer;
                    (*breaks).pointer = ((*breaks).pointer).offset(1);
                    *fresh631 = '\n' as i32 as yaml_char_t;
                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                    (*parser).buffer.pointer;
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = 0 as libc::c_int as size_t;
                    (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                    (*parser).mark.line;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                } else {
                    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize) as libc::c_int
                        == -62i32 as yaml_char_t as libc::c_int
                        && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                            as libc::c_int
                            == -123i32 as yaml_char_t as libc::c_int
                    {
                        let fresh632 = (*breaks).pointer;
                        (*breaks).pointer = ((*breaks).pointer).offset(1);
                        *fresh632 = '\n' as i32 as yaml_char_t;
                        (*parser).buffer.pointer =
                            ((*parser).buffer.pointer).offset(2 as libc::c_int as isize);
                        (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                        (*parser).mark.index;
                        (*parser).mark.column = 0 as libc::c_int as size_t;
                        (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                        (*parser).mark.line;
                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                        (*parser).unread;
                    } else {
                        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == -30i32 as yaml_char_t as libc::c_int
                            && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                as libc::c_int
                                == -128i32 as yaml_char_t as libc::c_int
                            && (*((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                as libc::c_int
                                == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                    as libc::c_int
                                    == -87i32 as yaml_char_t as libc::c_int)
                        {
                            let fresh633 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh634 = (*breaks).pointer;
                            (*breaks).pointer = ((*breaks).pointer).offset(1);
                            *fresh634 = *fresh633;
                            let fresh635 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh636 = (*breaks).pointer;
                            (*breaks).pointer = ((*breaks).pointer).offset(1);
                            *fresh636 = *fresh635;
                            let fresh637 = (*parser).buffer.pointer;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(1);
                            let fresh638 = (*breaks).pointer;
                            (*breaks).pointer = ((*breaks).pointer).offset(1);
                            *fresh638 = *fresh637;
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = 0 as libc::c_int as size_t;
                            (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                            (*parser).mark.line;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                        } else {
                        };
                    };
                };
            };
            1 as libc::c_int
        } else {
            0 as libc::c_int
        } == 0
        {
            return 0 as libc::c_int;
        }
        *end_mark = (*parser).mark;
    }
    if *indent == 0 {
        *indent = max_indent;
        if *indent < (*parser).indent + 1 as libc::c_int {
            *indent = (*parser).indent + 1 as libc::c_int;
        }
        if *indent < 1 as libc::c_int {
            *indent = 1 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_flow_scalar(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
    mut single: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut leading_break: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut trailing_breaks: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut whitespaces: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut leading_blanks: libc::c_int = 0;
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        leading_break.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
        if !(if !(leading_break.start).is_null() {
            leading_break.pointer = leading_break.start;
            leading_break.end = (leading_break.start).offset(16 as libc::c_int as isize);
            memset(
                leading_break.start as *mut libc::c_void,
                0 as libc::c_int,
                16 as libc::c_int as libc::c_ulong,
            );
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0)
        {
            trailing_breaks.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
            if !(if !(trailing_breaks.start).is_null() {
                trailing_breaks.pointer = trailing_breaks.start;
                trailing_breaks.end = (trailing_breaks.start).offset(16 as libc::c_int as isize);
                memset(
                    trailing_breaks.start as *mut libc::c_void,
                    0 as libc::c_int,
                    16 as libc::c_int as libc::c_ulong,
                );
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                whitespaces.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
                if !(if !(whitespaces.start).is_null() {
                    whitespaces.pointer = whitespaces.start;
                    whitespaces.end = (whitespaces.start).offset(16 as libc::c_int as isize);
                    memset(
                        whitespaces.start as *mut libc::c_void,
                        0 as libc::c_int,
                        16 as libc::c_int as libc::c_ulong,
                    );
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    start_mark = (*parser).mark;
                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                    (*parser).mark.index;
                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                    (*parser).mark.column;
                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                    (*parser).unread;
                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                        (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            & 0x80 as libc::c_int
                            == 0 as libc::c_int
                        {
                            1 as libc::c_int
                        } else {
                            (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                & 0xe0 as libc::c_int
                                == 0xc0 as libc::c_int
                            {
                                2 as libc::c_int
                            } else {
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0xf0 as libc::c_int
                                    == 0xe0 as libc::c_int
                                {
                                    3 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xf8 as libc::c_int
                                        == 0xf0 as libc::c_int
                                    {
                                        4 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    })
                                })
                            })
                        }) as isize,
                    );
                    's_44: loop {
                        if if (*parser).unread >= 4 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 4 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 13020313174005651352;
                            break;
                        }
                        if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
                            && (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '-' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                    as libc::c_int
                                    == '-' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                    as libc::c_int
                                    == '-' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '.' as i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '.' as i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                        as libc::c_int
                                        == '.' as i32 as yaml_char_t as libc::c_int)
                            && (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                as libc::c_int
                                == ' ' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\t' as i32 as yaml_char_t as libc::c_int
                                || (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -62i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -123i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -88i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -87i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\0' as i32 as yaml_char_t as libc::c_int))
                        {
                            yaml_parser_set_scanner_error(
                                parser,
                                b"while scanning a quoted scalar\0" as *const u8
                                    as *const libc::c_char,
                                start_mark,
                                b"found unexpected document indicator\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 13020313174005651352;
                            break;
                        } else if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '\0' as i32 as yaml_char_t as libc::c_int
                        {
                            yaml_parser_set_scanner_error(
                                parser,
                                b"while scanning a quoted scalar\0" as *const u8
                                    as *const libc::c_char,
                                start_mark,
                                b"found unexpected end of stream\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 13020313174005651352;
                            break;
                        } else {
                            if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 13020313174005651352;
                                break;
                            }
                            leading_blanks = 0 as libc::c_int;
                            while !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ' ' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\t' as i32 as yaml_char_t as libc::c_int
                                || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -62i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -123i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -88i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -87i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\0' as i32 as yaml_char_t as libc::c_int))
                            {
                                if single != 0
                                    && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\'' as i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\'' as i32 as yaml_char_t as libc::c_int
                                {
                                    if if (string.pointer).offset(5 as libc::c_int as isize)
                                        < string.end
                                        || yaml_string_extend(
                                            &mut string.start,
                                            &mut string.pointer,
                                            &mut string.end,
                                        ) != 0
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break 's_44;
                                    }
                                    let fresh639 = string.pointer;
                                    string.pointer = (string.pointer).offset(1);
                                    *fresh639 = '\'' as i32 as yaml_char_t;
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                } else {
                                    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == (if single != 0 { '\'' as i32 } else { '"' as i32 })
                                            as yaml_char_t
                                            as libc::c_int
                                    {
                                        break;
                                    }
                                    if single == 0
                                        && *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\\' as i32 as yaml_char_t as libc::c_int
                                        && (*((*parser).buffer.pointer)
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -62i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -123i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -88i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -87i32 as yaml_char_t as libc::c_int)
                                    {
                                        if if (*parser).unread >= 3 as libc::c_int as libc::c_ulong
                                        {
                                            1 as libc::c_int
                                        } else {
                                            yaml_parser_update_buffer(
                                                parser,
                                                3 as libc::c_int as size_t,
                                            )
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break 's_44;
                                        }
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                            .offset(
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0x80 as libc::c_int
                                                    == 0 as libc::c_int
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xe0 as libc::c_int
                                                        == 0xc0 as libc::c_int
                                                    {
                                                        2 as libc::c_int
                                                    } else {
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0xf0 as libc::c_int
                                                            == 0xe0 as libc::c_int
                                                        {
                                                            3 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xf8 as libc::c_int
                                                                == 0xf0 as libc::c_int
                                                            {
                                                                4 as libc::c_int
                                                            } else {
                                                                0 as libc::c_int
                                                            })
                                                        })
                                                    })
                                                })
                                                    as isize,
                                            );
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer).offset(
                                                (0 as libc::c_int + 1 as libc::c_int) as isize,
                                            )
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                        {
                                            (*parser).mark.index = ((*parser).mark.index
                                                as libc::c_ulong)
                                                .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                            (*parser).mark.column = 0 as libc::c_int as size_t;
                                            (*parser).mark.line =
                                                ((*parser).mark.line).wrapping_add(1);
                                            (*parser).mark.line;
                                            (*parser).unread = ((*parser).unread as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                            (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                                .offset(2 as libc::c_int as isize);
                                        } else {
                                            if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\r' as i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -62i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 1 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == -123i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -30i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 1 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == -128i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 2 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == -88i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -30i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 1 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == -128i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer).offset(
                                                        (0 as libc::c_int + 2 as libc::c_int)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == -87i32 as yaml_char_t as libc::c_int
                                            {
                                                (*parser).mark.index =
                                                    ((*parser).mark.index).wrapping_add(1);
                                                (*parser).mark.index;
                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                (*parser).mark.line =
                                                    ((*parser).mark.line).wrapping_add(1);
                                                (*parser).mark.line;
                                                (*parser).unread =
                                                    ((*parser).unread).wrapping_sub(1);
                                                (*parser).unread;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0x80 as libc::c_int
                                                            == 0 as libc::c_int
                                                        {
                                                            1 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xe0 as libc::c_int
                                                                == 0xc0 as libc::c_int
                                                            {
                                                                2 as libc::c_int
                                                            } else {
                                                                (if *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        0 as libc::c_int as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    & 0xf0 as libc::c_int
                                                                    == 0xe0 as libc::c_int
                                                                {
                                                                    3 as libc::c_int
                                                                } else {
                                                                    (if *((*parser).buffer.pointer)
                                                                        .offset(
                                                                            0 as libc::c_int
                                                                                as isize,
                                                                        )
                                                                        as libc::c_int
                                                                        & 0xf8 as libc::c_int
                                                                        == 0xf0 as libc::c_int
                                                                    {
                                                                        4 as libc::c_int
                                                                    } else {
                                                                        0 as libc::c_int
                                                                    })
                                                                })
                                                            })
                                                        })
                                                            as isize,
                                                    );
                                            } else {
                                            };
                                        };
                                        leading_blanks = 1 as libc::c_int;
                                        break;
                                    } else if single == 0
                                        && *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\\' as i32 as yaml_char_t as libc::c_int
                                    {
                                        let mut code_length: size_t = 0 as libc::c_int as size_t;
                                        if if (string.pointer).offset(5 as libc::c_int as isize)
                                            < string.end
                                            || yaml_string_extend(
                                                &mut string.start,
                                                &mut string.pointer,
                                                &mut string.end,
                                            ) != 0
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break 's_44;
                                        }
                                        match *((*parser).buffer.pointer)
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_int
                                        {
                                            48 => {
                                                let fresh640 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh640 = '\0' as i32 as yaml_char_t;
                                            }
                                            97 => {
                                                let fresh641 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh641 = '\u{7}' as i32 as yaml_char_t;
                                            }
                                            98 => {
                                                let fresh642 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh642 = '\u{8}' as i32 as yaml_char_t;
                                            }
                                            116 | 9 => {
                                                let fresh643 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh643 = '\t' as i32 as yaml_char_t;
                                            }
                                            110 => {
                                                let fresh644 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh644 = '\n' as i32 as yaml_char_t;
                                            }
                                            118 => {
                                                let fresh645 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh645 = '\u{b}' as i32 as yaml_char_t;
                                            }
                                            102 => {
                                                let fresh646 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh646 = '\u{c}' as i32 as yaml_char_t;
                                            }
                                            114 => {
                                                let fresh647 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh647 = '\r' as i32 as yaml_char_t;
                                            }
                                            101 => {
                                                let fresh648 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh648 = '\u{1b}' as i32 as yaml_char_t;
                                            }
                                            32 => {
                                                let fresh649 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh649 = ' ' as i32 as yaml_char_t;
                                            }
                                            34 => {
                                                let fresh650 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh650 = '"' as i32 as yaml_char_t;
                                            }
                                            47 => {
                                                let fresh651 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh651 = '/' as i32 as yaml_char_t;
                                            }
                                            92 => {
                                                let fresh652 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh652 = '\\' as i32 as yaml_char_t;
                                            }
                                            78 => {
                                                let fresh653 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh653 = -62i32 as yaml_char_t;
                                                let fresh654 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh654 = -123i32 as yaml_char_t;
                                            }
                                            95 => {
                                                let fresh655 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh655 = -62i32 as yaml_char_t;
                                                let fresh656 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh656 = -96i32 as yaml_char_t;
                                            }
                                            76 => {
                                                let fresh657 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh657 = -30i32 as yaml_char_t;
                                                let fresh658 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh658 = -128i32 as yaml_char_t;
                                                let fresh659 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh659 = -88i32 as yaml_char_t;
                                            }
                                            80 => {
                                                let fresh660 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh660 = -30i32 as yaml_char_t;
                                                let fresh661 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh661 = -128i32 as yaml_char_t;
                                                let fresh662 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh662 = -87i32 as yaml_char_t;
                                            }
                                            120 => {
                                                code_length = 2 as libc::c_int as size_t;
                                            }
                                            117 => {
                                                code_length = 4 as libc::c_int as size_t;
                                            }
                                            85 => {
                                                code_length = 8 as libc::c_int as size_t;
                                            }
                                            _ => {
                                                yaml_parser_set_scanner_error(
                                                    parser,
                                                    b"while parsing a quoted scalar\0" as *const u8
                                                        as *const libc::c_char,
                                                    start_mark,
                                                    b"found unknown escape character\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                                current_block = 13020313174005651352;
                                                break 's_44;
                                            }
                                        }
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                            .offset(
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0x80 as libc::c_int
                                                    == 0 as libc::c_int
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xe0 as libc::c_int
                                                        == 0xc0 as libc::c_int
                                                    {
                                                        2 as libc::c_int
                                                    } else {
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0xf0 as libc::c_int
                                                            == 0xe0 as libc::c_int
                                                        {
                                                            3 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xf8 as libc::c_int
                                                                == 0xf0 as libc::c_int
                                                            {
                                                                4 as libc::c_int
                                                            } else {
                                                                0 as libc::c_int
                                                            })
                                                        })
                                                    })
                                                })
                                                    as isize,
                                            );
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                            .offset(
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0x80 as libc::c_int
                                                    == 0 as libc::c_int
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xe0 as libc::c_int
                                                        == 0xc0 as libc::c_int
                                                    {
                                                        2 as libc::c_int
                                                    } else {
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0xf0 as libc::c_int
                                                            == 0xe0 as libc::c_int
                                                        {
                                                            3 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xf8 as libc::c_int
                                                                == 0xf0 as libc::c_int
                                                            {
                                                                4 as libc::c_int
                                                            } else {
                                                                0 as libc::c_int
                                                            })
                                                        })
                                                    })
                                                })
                                                    as isize,
                                            );
                                        if code_length != 0 {
                                            let mut value: libc::c_uint =
                                                0 as libc::c_int as libc::c_uint;
                                            let mut k: size_t = 0;
                                            if if (*parser).unread >= code_length {
                                                1 as libc::c_int
                                            } else {
                                                yaml_parser_update_buffer(parser, code_length)
                                            } == 0
                                            {
                                                current_block = 13020313174005651352;
                                                break 's_44;
                                            }
                                            k = 0 as libc::c_int as size_t;
                                            while k < code_length {
                                                if !(*((*parser).buffer.pointer).offset(k as isize)
                                                    as libc::c_int
                                                    >= '0' as i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer)
                                                        .offset(k as isize)
                                                        as libc::c_int
                                                        <= '9' as i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(k as isize)
                                                        as libc::c_int
                                                        >= 'A' as i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer)
                                                            .offset(k as isize)
                                                            as libc::c_int
                                                            <= 'F' as i32 as yaml_char_t
                                                                as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(k as isize)
                                                        as libc::c_int
                                                        >= 'a' as i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer)
                                                            .offset(k as isize)
                                                            as libc::c_int
                                                            <= 'f' as i32 as yaml_char_t
                                                                as libc::c_int)
                                                {
                                                    yaml_parser_set_scanner_error(
                                                        parser,
                                                        b"while parsing a quoted scalar\0"
                                                            as *const u8
                                                            as *const libc::c_char,
                                                        start_mark,
                                                        b"did not find expected hexdecimal number\0"
                                                            as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                    current_block = 13020313174005651352;
                                                    break 's_44;
                                                } else {
                                                    value = (value << 4 as libc::c_int)
                                                        .wrapping_add(
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(k as isize)
                                                                as libc::c_int
                                                                >= 'A' as i32 as yaml_char_t
                                                                    as libc::c_int
                                                                && *((*parser).buffer.pointer)
                                                                    .offset(k as isize)
                                                                    as libc::c_int
                                                                    <= 'F' as i32 as yaml_char_t
                                                                        as libc::c_int
                                                            {
                                                                *((*parser).buffer.pointer)
                                                                    .offset(k as isize)
                                                                    as libc::c_int
                                                                    - 'A' as i32 as yaml_char_t
                                                                        as libc::c_int
                                                                    + 10 as libc::c_int
                                                            } else {
                                                                (if *((*parser).buffer.pointer)
                                                                    .offset(k as isize)
                                                                    as libc::c_int
                                                                    >= 'a' as i32 as yaml_char_t
                                                                        as libc::c_int
                                                                    && *((*parser).buffer.pointer)
                                                                        .offset(k as isize)
                                                                        as libc::c_int
                                                                        <= 'f' as i32 as yaml_char_t
                                                                            as libc::c_int
                                                                {
                                                                    *((*parser).buffer.pointer)
                                                                        .offset(k as isize)
                                                                        as libc::c_int
                                                                        - 'a' as i32 as yaml_char_t
                                                                            as libc::c_int
                                                                        + 10 as libc::c_int
                                                                } else {
                                                                    *((*parser).buffer.pointer)
                                                                        .offset(k as isize)
                                                                        as libc::c_int
                                                                        - '0' as i32 as yaml_char_t
                                                                            as libc::c_int
                                                                })
                                                            })
                                                                as libc::c_uint,
                                                        );
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                            if value >= 0xd800 as libc::c_int as libc::c_uint
                                                && value <= 0xdfff as libc::c_int as libc::c_uint
                                                || value > 0x10ffff as libc::c_int as libc::c_uint
                                            {
                                                yaml_parser_set_scanner_error(
                                                    parser,
                                                    b"while parsing a quoted scalar\0" as *const u8
                                                        as *const libc::c_char,
                                                    start_mark,
                                                    b"found invalid Unicode character escape code\0"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                );
                                                current_block = 13020313174005651352;
                                                break 's_44;
                                            } else {
                                                if value <= 0x7f as libc::c_int as libc::c_uint {
                                                    let fresh663 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh663 = value as yaml_char_t;
                                                } else if value
                                                    <= 0x7ff as libc::c_int as libc::c_uint
                                                {
                                                    let fresh664 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh664 = (0xc0 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(value >> 6 as libc::c_int)
                                                        as yaml_char_t;
                                                    let fresh665 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh665 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                } else if value
                                                    <= 0xffff as libc::c_int as libc::c_uint
                                                {
                                                    let fresh666 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh666 = (0xe0 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(value >> 12 as libc::c_int)
                                                        as yaml_char_t;
                                                    let fresh667 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh667 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value >> 6 as libc::c_int
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                    let fresh668 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh668 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                } else {
                                                    let fresh669 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh669 = (0xf0 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(value >> 18 as libc::c_int)
                                                        as yaml_char_t;
                                                    let fresh670 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh670 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value >> 12 as libc::c_int
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                    let fresh671 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh671 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value >> 6 as libc::c_int
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                    let fresh672 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh672 = (0x80 as libc::c_int
                                                        as libc::c_uint)
                                                        .wrapping_add(
                                                            value
                                                                & 0x3f as libc::c_int
                                                                    as libc::c_uint,
                                                        )
                                                        as yaml_char_t;
                                                }
                                                k = 0 as libc::c_int as size_t;
                                                while k < code_length {
                                                    (*parser).mark.index =
                                                        ((*parser).mark.index).wrapping_add(1);
                                                    (*parser).mark.index;
                                                    (*parser).mark.column =
                                                        ((*parser).mark.column).wrapping_add(1);
                                                    (*parser).mark.column;
                                                    (*parser).unread =
                                                        ((*parser).unread).wrapping_sub(1);
                                                    (*parser).unread;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0x80 as libc::c_int
                                                                == 0 as libc::c_int
                                                            {
                                                                1 as libc::c_int
                                                            } else {
                                                                (if *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        0 as libc::c_int as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    & 0xe0 as libc::c_int
                                                                    == 0xc0 as libc::c_int
                                                                {
                                                                    2 as libc::c_int
                                                                } else {
                                                                    (if *((*parser).buffer.pointer)
                                                                        .offset(
                                                                            0 as libc::c_int
                                                                                as isize,
                                                                        )
                                                                        as libc::c_int
                                                                        & 0xf0 as libc::c_int
                                                                        == 0xe0 as libc::c_int
                                                                    {
                                                                        3 as libc::c_int
                                                                    } else {
                                                                        (if *((*parser)
                                                                            .buffer
                                                                            .pointer)
                                                                            .offset(
                                                                                0 as libc::c_int
                                                                                    as isize,
                                                                            )
                                                                            as libc::c_int
                                                                            & 0xf8 as libc::c_int
                                                                            == 0xf0 as libc::c_int
                                                                        {
                                                                            4 as libc::c_int
                                                                        } else {
                                                                            0 as libc::c_int
                                                                        })
                                                                    })
                                                                })
                                                            })
                                                                as isize,
                                                        );
                                                    k = k.wrapping_add(1);
                                                    k;
                                                }
                                            }
                                        }
                                    } else if if if (string.pointer)
                                        .offset(5 as libc::c_int as isize)
                                        < string.end
                                        || yaml_string_extend(
                                            &mut string.start,
                                            &mut string.pointer,
                                            &mut string.end,
                                        ) != 0
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } != 0
                                    {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            let fresh673 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh674 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh674 = *fresh673;
                                        } else {
                                            if *(*parser).buffer.pointer as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                let fresh675 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh676 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh676 = *fresh675;
                                                let fresh677 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh678 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh678 = *fresh677;
                                            } else {
                                                if *(*parser).buffer.pointer as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    let fresh679 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh680 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh680 = *fresh679;
                                                    let fresh681 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh682 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh682 = *fresh681;
                                                    let fresh683 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh684 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh684 = *fresh683;
                                                } else {
                                                    if *(*parser).buffer.pointer as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        let fresh685 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh686 = string.pointer;
                                                        string.pointer = (string.pointer).offset(1);
                                                        *fresh686 = *fresh685;
                                                        let fresh687 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh688 = string.pointer;
                                                        string.pointer = (string.pointer).offset(1);
                                                        *fresh688 = *fresh687;
                                                        let fresh689 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh690 = string.pointer;
                                                        string.pointer = (string.pointer).offset(1);
                                                        *fresh690 = *fresh689;
                                                        let fresh691 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh692 = string.pointer;
                                                        string.pointer = (string.pointer).offset(1);
                                                        *fresh692 = *fresh691;
                                                    } else {
                                                    };
                                                };
                                            };
                                        };
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        1 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break 's_44;
                                    }
                                }
                                if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
                                    1 as libc::c_int
                                } else {
                                    yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
                                } == 0
                                {
                                    current_block = 13020313174005651352;
                                    break 's_44;
                                }
                            }
                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 13020313174005651352;
                                break;
                            }
                            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == (if single != 0 { '\'' as i32 } else { '"' as i32 })
                                    as yaml_char_t as libc::c_int
                            {
                                current_block = 10468276026569382870;
                                break;
                            }
                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 13020313174005651352;
                                break;
                            }
                            while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ' ' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\t' as i32 as yaml_char_t as libc::c_int
                                || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -62i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -123i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -88i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -87i32 as yaml_char_t as libc::c_int)
                            {
                                if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == ' ' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\t' as i32 as yaml_char_t as libc::c_int
                                {
                                    if leading_blanks == 0 {
                                        if if if (whitespaces.pointer)
                                            .offset(5 as libc::c_int as isize)
                                            < whitespaces.end
                                            || yaml_string_extend(
                                                &mut whitespaces.start,
                                                &mut whitespaces.pointer,
                                                &mut whitespaces.end,
                                            ) != 0
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } != 0
                                        {
                                            if *(*parser).buffer.pointer as libc::c_int
                                                & 0x80 as libc::c_int
                                                == 0 as libc::c_int
                                            {
                                                let fresh693 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh694 = whitespaces.pointer;
                                                whitespaces.pointer =
                                                    (whitespaces.pointer).offset(1);
                                                *fresh694 = *fresh693;
                                            } else {
                                                if *(*parser).buffer.pointer as libc::c_int
                                                    & 0xe0 as libc::c_int
                                                    == 0xc0 as libc::c_int
                                                {
                                                    let fresh695 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh696 = whitespaces.pointer;
                                                    whitespaces.pointer =
                                                        (whitespaces.pointer).offset(1);
                                                    *fresh696 = *fresh695;
                                                    let fresh697 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh698 = whitespaces.pointer;
                                                    whitespaces.pointer =
                                                        (whitespaces.pointer).offset(1);
                                                    *fresh698 = *fresh697;
                                                } else {
                                                    if *(*parser).buffer.pointer as libc::c_int
                                                        & 0xf0 as libc::c_int
                                                        == 0xe0 as libc::c_int
                                                    {
                                                        let fresh699 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh700 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh700 = *fresh699;
                                                        let fresh701 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh702 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh702 = *fresh701;
                                                        let fresh703 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh704 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh704 = *fresh703;
                                                    } else {
                                                        if *(*parser).buffer.pointer as libc::c_int
                                                            & 0xf8 as libc::c_int
                                                            == 0xf0 as libc::c_int
                                                        {
                                                            let fresh705 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh706 = whitespaces.pointer;
                                                            whitespaces.pointer =
                                                                (whitespaces.pointer).offset(1);
                                                            *fresh706 = *fresh705;
                                                            let fresh707 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh708 = whitespaces.pointer;
                                                            whitespaces.pointer =
                                                                (whitespaces.pointer).offset(1);
                                                            *fresh708 = *fresh707;
                                                            let fresh709 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh710 = whitespaces.pointer;
                                                            whitespaces.pointer =
                                                                (whitespaces.pointer).offset(1);
                                                            *fresh710 = *fresh709;
                                                            let fresh711 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh712 = whitespaces.pointer;
                                                            whitespaces.pointer =
                                                                (whitespaces.pointer).offset(1);
                                                            *fresh712 = *fresh711;
                                                        } else {
                                                        };
                                                    };
                                                };
                                            };
                                            (*parser).mark.index =
                                                ((*parser).mark.index).wrapping_add(1);
                                            (*parser).mark.index;
                                            (*parser).mark.column =
                                                ((*parser).mark.column).wrapping_add(1);
                                            (*parser).mark.column;
                                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                            (*parser).unread;
                                            1 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break 's_44;
                                        }
                                    } else {
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                            .offset(
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0x80 as libc::c_int
                                                    == 0 as libc::c_int
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xe0 as libc::c_int
                                                        == 0xc0 as libc::c_int
                                                    {
                                                        2 as libc::c_int
                                                    } else {
                                                        (if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            & 0xf0 as libc::c_int
                                                            == 0xe0 as libc::c_int
                                                        {
                                                            3 as libc::c_int
                                                        } else {
                                                            (if *((*parser).buffer.pointer)
                                                                .offset(0 as libc::c_int as isize)
                                                                as libc::c_int
                                                                & 0xf8 as libc::c_int
                                                                == 0xf0 as libc::c_int
                                                            {
                                                                4 as libc::c_int
                                                            } else {
                                                                0 as libc::c_int
                                                            })
                                                        })
                                                    })
                                                })
                                                    as isize,
                                            );
                                    }
                                } else {
                                    if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
                                        1 as libc::c_int
                                    } else {
                                        yaml_parser_update_buffer(
                                            parser,
                                            2 as libc::c_int as size_t,
                                        )
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break 's_44;
                                    }
                                    if leading_blanks == 0 {
                                        whitespaces.pointer = whitespaces.start;
                                        memset(
                                            whitespaces.start as *mut libc::c_void,
                                            0 as libc::c_int,
                                            (whitespaces.end).offset_from(whitespaces.start)
                                                as libc::c_long
                                                as libc::c_ulong,
                                        );
                                        if if if (leading_break.pointer)
                                            .offset(5 as libc::c_int as isize)
                                            < leading_break.end
                                            || yaml_string_extend(
                                                &mut leading_break.start,
                                                &mut leading_break.pointer,
                                                &mut leading_break.end,
                                            ) != 0
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } != 0
                                        {
                                            if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\r' as i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer)
                                                    .offset(1 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                            {
                                                let fresh713 = leading_break.pointer;
                                                leading_break.pointer =
                                                    (leading_break.pointer).offset(1);
                                                *fresh713 = '\n' as i32 as yaml_char_t;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer)
                                                        .offset(2 as libc::c_int as isize);
                                                (*parser).mark.index = ((*parser).mark.index
                                                    as libc::c_ulong)
                                                    .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                                    as size_t
                                                    as size_t;
                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                (*parser).mark.line =
                                                    ((*parser).mark.line).wrapping_add(1);
                                                (*parser).mark.line;
                                                (*parser).unread = ((*parser).unread
                                                    as libc::c_ulong)
                                                    .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                                    as size_t
                                                    as size_t;
                                            } else {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                                    || *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                                {
                                                    let fresh714 = leading_break.pointer;
                                                    leading_break.pointer =
                                                        (leading_break.pointer).offset(1);
                                                    *fresh714 = '\n' as i32 as yaml_char_t;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    (*parser).buffer.pointer;
                                                    (*parser).mark.index =
                                                        ((*parser).mark.index).wrapping_add(1);
                                                    (*parser).mark.index;
                                                    (*parser).mark.column =
                                                        0 as libc::c_int as size_t;
                                                    (*parser).mark.line =
                                                        ((*parser).mark.line).wrapping_add(1);
                                                    (*parser).mark.line;
                                                    (*parser).unread =
                                                        ((*parser).unread).wrapping_sub(1);
                                                    (*parser).unread;
                                                } else {
                                                    if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -62i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer)
                                                            .offset(1 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -123i32 as yaml_char_t as libc::c_int
                                                    {
                                                        let fresh715 = leading_break.pointer;
                                                        leading_break.pointer =
                                                            (leading_break.pointer).offset(1);
                                                        *fresh715 = '\n' as i32 as yaml_char_t;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer)
                                                                .offset(2 as libc::c_int as isize);
                                                        (*parser).mark.index =
                                                            ((*parser).mark.index).wrapping_add(1);
                                                        (*parser).mark.index;
                                                        (*parser).mark.column =
                                                            0 as libc::c_int as size_t;
                                                        (*parser).mark.line =
                                                            ((*parser).mark.line).wrapping_add(1);
                                                        (*parser).mark.line;
                                                        (*parser).unread =
                                                            ((*parser).unread).wrapping_sub(1);
                                                        (*parser).unread;
                                                    } else {
                                                        if *((*parser).buffer.pointer)
                                                            .offset(0 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -30i32 as yaml_char_t as libc::c_int
                                                            && *((*parser).buffer.pointer)
                                                                .offset(1 as libc::c_int as isize)
                                                                as libc::c_int
                                                                == -128i32 as yaml_char_t
                                                                    as libc::c_int
                                                            && (*((*parser).buffer.pointer)
                                                                .offset(2 as libc::c_int as isize)
                                                                as libc::c_int
                                                                == -88i32 as yaml_char_t
                                                                    as libc::c_int
                                                                || *((*parser).buffer.pointer)
                                                                    .offset(
                                                                        2 as libc::c_int as isize,
                                                                    )
                                                                    as libc::c_int
                                                                    == -87i32 as yaml_char_t
                                                                        as libc::c_int)
                                                        {
                                                            let fresh716 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh717 = leading_break.pointer;
                                                            leading_break.pointer =
                                                                (leading_break.pointer).offset(1);
                                                            *fresh717 = *fresh716;
                                                            let fresh718 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh719 = leading_break.pointer;
                                                            leading_break.pointer =
                                                                (leading_break.pointer).offset(1);
                                                            *fresh719 = *fresh718;
                                                            let fresh720 = (*parser).buffer.pointer;
                                                            (*parser).buffer.pointer =
                                                                ((*parser).buffer.pointer)
                                                                    .offset(1);
                                                            let fresh721 = leading_break.pointer;
                                                            leading_break.pointer =
                                                                (leading_break.pointer).offset(1);
                                                            *fresh721 = *fresh720;
                                                            (*parser).mark.index =
                                                                ((*parser).mark.index)
                                                                    .wrapping_add(1);
                                                            (*parser).mark.index;
                                                            (*parser).mark.column =
                                                                0 as libc::c_int as size_t;
                                                            (*parser).mark.line =
                                                                ((*parser).mark.line)
                                                                    .wrapping_add(1);
                                                            (*parser).mark.line;
                                                            (*parser).unread =
                                                                ((*parser).unread).wrapping_sub(1);
                                                            (*parser).unread;
                                                        } else {
                                                        };
                                                    };
                                                };
                                            };
                                            1 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break 's_44;
                                        }
                                        leading_blanks = 1 as libc::c_int;
                                    } else if if if (trailing_breaks.pointer)
                                        .offset(5 as libc::c_int as isize)
                                        < trailing_breaks.end
                                        || yaml_string_extend(
                                            &mut trailing_breaks.start,
                                            &mut trailing_breaks.pointer,
                                            &mut trailing_breaks.end,
                                        ) != 0
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } != 0
                                    {
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                        {
                                            let fresh722 = trailing_breaks.pointer;
                                            trailing_breaks.pointer =
                                                (trailing_breaks.pointer).offset(1);
                                            *fresh722 = '\n' as i32 as yaml_char_t;
                                            (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                                .offset(2 as libc::c_int as isize);
                                            (*parser).mark.index = ((*parser).mark.index
                                                as libc::c_ulong)
                                                .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                            (*parser).mark.column = 0 as libc::c_int as size_t;
                                            (*parser).mark.line =
                                                ((*parser).mark.line).wrapping_add(1);
                                            (*parser).mark.line;
                                            (*parser).unread = ((*parser).unread as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                        } else {
                                            if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\r' as i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                            {
                                                let fresh723 = trailing_breaks.pointer;
                                                trailing_breaks.pointer =
                                                    (trailing_breaks.pointer).offset(1);
                                                *fresh723 = '\n' as i32 as yaml_char_t;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                (*parser).buffer.pointer;
                                                (*parser).mark.index =
                                                    ((*parser).mark.index).wrapping_add(1);
                                                (*parser).mark.index;
                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                (*parser).mark.line =
                                                    ((*parser).mark.line).wrapping_add(1);
                                                (*parser).mark.line;
                                                (*parser).unread =
                                                    ((*parser).unread).wrapping_sub(1);
                                                (*parser).unread;
                                            } else {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -62i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer)
                                                        .offset(1 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -123i32 as yaml_char_t as libc::c_int
                                                {
                                                    let fresh724 = trailing_breaks.pointer;
                                                    trailing_breaks.pointer =
                                                        (trailing_breaks.pointer).offset(1);
                                                    *fresh724 = '\n' as i32 as yaml_char_t;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize);
                                                    (*parser).mark.index =
                                                        ((*parser).mark.index).wrapping_add(1);
                                                    (*parser).mark.index;
                                                    (*parser).mark.column =
                                                        0 as libc::c_int as size_t;
                                                    (*parser).mark.line =
                                                        ((*parser).mark.line).wrapping_add(1);
                                                    (*parser).mark.line;
                                                    (*parser).unread =
                                                        ((*parser).unread).wrapping_sub(1);
                                                    (*parser).unread;
                                                } else {
                                                    if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer)
                                                            .offset(1 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t as libc::c_int
                                                        && (*((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -88i32 as yaml_char_t as libc::c_int
                                                            || *((*parser).buffer.pointer)
                                                                .offset(2 as libc::c_int as isize)
                                                                as libc::c_int
                                                                == -87i32 as yaml_char_t
                                                                    as libc::c_int)
                                                    {
                                                        let fresh725 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh726 = trailing_breaks.pointer;
                                                        trailing_breaks.pointer =
                                                            (trailing_breaks.pointer).offset(1);
                                                        *fresh726 = *fresh725;
                                                        let fresh727 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh728 = trailing_breaks.pointer;
                                                        trailing_breaks.pointer =
                                                            (trailing_breaks.pointer).offset(1);
                                                        *fresh728 = *fresh727;
                                                        let fresh729 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh730 = trailing_breaks.pointer;
                                                        trailing_breaks.pointer =
                                                            (trailing_breaks.pointer).offset(1);
                                                        *fresh730 = *fresh729;
                                                        (*parser).mark.index =
                                                            ((*parser).mark.index).wrapping_add(1);
                                                        (*parser).mark.index;
                                                        (*parser).mark.column =
                                                            0 as libc::c_int as size_t;
                                                        (*parser).mark.line =
                                                            ((*parser).mark.line).wrapping_add(1);
                                                        (*parser).mark.line;
                                                        (*parser).unread =
                                                            ((*parser).unread).wrapping_sub(1);
                                                        (*parser).unread;
                                                    } else {
                                                    };
                                                };
                                            };
                                        };
                                        1 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break 's_44;
                                    }
                                }
                                if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                    1 as libc::c_int
                                } else {
                                    yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                                } == 0
                                {
                                    current_block = 13020313174005651352;
                                    break 's_44;
                                }
                            }
                            if leading_blanks != 0 {
                                if *(leading_break.start).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32
                                {
                                    if *(trailing_breaks.start).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\0' as i32
                                    {
                                        if if (string.pointer).offset(5 as libc::c_int as isize)
                                            < string.end
                                            || yaml_string_extend(
                                                &mut string.start,
                                                &mut string.pointer,
                                                &mut string.end,
                                            ) != 0
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break;
                                        }
                                        let fresh731 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh731 = ' ' as i32 as yaml_char_t;
                                    } else {
                                        if if yaml_string_join(
                                            &mut string.start,
                                            &mut string.pointer,
                                            &mut string.end,
                                            &mut trailing_breaks.start,
                                            &mut trailing_breaks.pointer,
                                            &mut trailing_breaks.end,
                                        ) != 0
                                        {
                                            trailing_breaks.pointer = trailing_breaks.start;
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 13020313174005651352;
                                            break;
                                        }
                                        trailing_breaks.pointer = trailing_breaks.start;
                                        memset(
                                            trailing_breaks.start as *mut libc::c_void,
                                            0 as libc::c_int,
                                            (trailing_breaks.end).offset_from(trailing_breaks.start)
                                                as libc::c_long
                                                as libc::c_ulong,
                                        );
                                    }
                                    leading_break.pointer = leading_break.start;
                                    memset(
                                        leading_break.start as *mut libc::c_void,
                                        0 as libc::c_int,
                                        (leading_break.end).offset_from(leading_break.start)
                                            as libc::c_long
                                            as libc::c_ulong,
                                    );
                                } else {
                                    if if yaml_string_join(
                                        &mut string.start,
                                        &mut string.pointer,
                                        &mut string.end,
                                        &mut leading_break.start,
                                        &mut leading_break.pointer,
                                        &mut leading_break.end,
                                    ) != 0
                                    {
                                        leading_break.pointer = leading_break.start;
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break;
                                    }
                                    if if yaml_string_join(
                                        &mut string.start,
                                        &mut string.pointer,
                                        &mut string.end,
                                        &mut trailing_breaks.start,
                                        &mut trailing_breaks.pointer,
                                        &mut trailing_breaks.end,
                                    ) != 0
                                    {
                                        trailing_breaks.pointer = trailing_breaks.start;
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 13020313174005651352;
                                        break;
                                    }
                                    leading_break.pointer = leading_break.start;
                                    memset(
                                        leading_break.start as *mut libc::c_void,
                                        0 as libc::c_int,
                                        (leading_break.end).offset_from(leading_break.start)
                                            as libc::c_long
                                            as libc::c_ulong,
                                    );
                                    trailing_breaks.pointer = trailing_breaks.start;
                                    memset(
                                        trailing_breaks.start as *mut libc::c_void,
                                        0 as libc::c_int,
                                        (trailing_breaks.end).offset_from(trailing_breaks.start)
                                            as libc::c_long
                                            as libc::c_ulong,
                                    );
                                }
                            } else {
                                if if yaml_string_join(
                                    &mut string.start,
                                    &mut string.pointer,
                                    &mut string.end,
                                    &mut whitespaces.start,
                                    &mut whitespaces.pointer,
                                    &mut whitespaces.end,
                                ) != 0
                                {
                                    whitespaces.pointer = whitespaces.start;
                                    1 as libc::c_int
                                } else {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    0 as libc::c_int
                                } == 0
                                {
                                    current_block = 13020313174005651352;
                                    break;
                                }
                                whitespaces.pointer = whitespaces.start;
                                memset(
                                    whitespaces.start as *mut libc::c_void,
                                    0 as libc::c_int,
                                    (whitespaces.end).offset_from(whitespaces.start) as libc::c_long
                                        as libc::c_ulong,
                                );
                            }
                        }
                    }
                    match current_block {
                        13020313174005651352 => {}
                        _ => {
                            (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                            (*parser).mark.index;
                            (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                            (*parser).mark.column;
                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                            (*parser).unread;
                            (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                (if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    & 0x80 as libc::c_int
                                    == 0 as libc::c_int
                                {
                                    1 as libc::c_int
                                } else {
                                    (if *((*parser).buffer.pointer)
                                        .offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        & 0xe0 as libc::c_int
                                        == 0xc0 as libc::c_int
                                    {
                                        2 as libc::c_int
                                    } else {
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0xf0 as libc::c_int
                                            == 0xe0 as libc::c_int
                                        {
                                            3 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xf8 as libc::c_int
                                                == 0xf0 as libc::c_int
                                            {
                                                4 as libc::c_int
                                            } else {
                                                0 as libc::c_int
                                            })
                                        })
                                    })
                                }) as isize,
                            );
                            end_mark = (*parser).mark;
                            memset(
                                token as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                            );
                            (*token).type_0 = YAML_SCALAR_TOKEN;
                            (*token).start_mark = start_mark;
                            (*token).end_mark = end_mark;
                            (*token).data.scalar.value = string.start;
                            (*token).data.scalar.length = (string.pointer).offset_from(string.start)
                                as libc::c_long
                                as size_t;
                            (*token).data.scalar.style = (if single != 0 {
                                YAML_SINGLE_QUOTED_SCALAR_STYLE as libc::c_int
                            } else {
                                YAML_DOUBLE_QUOTED_SCALAR_STYLE as libc::c_int
                            })
                                as yaml_scalar_style_t;
                            yaml_free(leading_break.start as *mut libc::c_void);
                            leading_break.end = 0 as *mut yaml_char_t;
                            leading_break.pointer = leading_break.end;
                            leading_break.start = leading_break.pointer;
                            yaml_free(trailing_breaks.start as *mut libc::c_void);
                            trailing_breaks.end = 0 as *mut yaml_char_t;
                            trailing_breaks.pointer = trailing_breaks.end;
                            trailing_breaks.start = trailing_breaks.pointer;
                            yaml_free(whitespaces.start as *mut libc::c_void);
                            whitespaces.end = 0 as *mut yaml_char_t;
                            whitespaces.pointer = whitespaces.end;
                            whitespaces.start = whitespaces.pointer;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    yaml_free(leading_break.start as *mut libc::c_void);
    leading_break.end = 0 as *mut yaml_char_t;
    leading_break.pointer = leading_break.end;
    leading_break.start = leading_break.pointer;
    yaml_free(trailing_breaks.start as *mut libc::c_void);
    trailing_breaks.end = 0 as *mut yaml_char_t;
    trailing_breaks.pointer = trailing_breaks.end;
    trailing_breaks.start = trailing_breaks.pointer;
    yaml_free(whitespaces.start as *mut libc::c_void);
    whitespaces.end = 0 as *mut yaml_char_t;
    whitespaces.pointer = whitespaces.end;
    whitespaces.start = whitespaces.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_parser_scan_plain_scalar(
    mut parser: *mut yaml_parser_t,
    mut token: *mut yaml_token_t,
) -> libc::c_int {
    let mut current_block: u64;
    let mut start_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut end_mark: yaml_mark_t = yaml_mark_t {
        index: 0,
        line: 0,
        column: 0,
    };
    let mut string: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut leading_break: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut trailing_breaks: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut whitespaces: yaml_string_t = {
        let mut init = yaml_string_t {
            start: 0 as *mut yaml_char_t,
            end: 0 as *mut yaml_char_t,
            pointer: 0 as *mut yaml_char_t,
        };
        init
    };
    let mut leading_blanks: libc::c_int = 0 as libc::c_int;
    let mut indent: libc::c_int = (*parser).indent + 1 as libc::c_int;
    string.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
    if !(if !(string.start).is_null() {
        string.pointer = string.start;
        string.end = (string.start).offset(16 as libc::c_int as isize);
        memset(
            string.start as *mut libc::c_void,
            0 as libc::c_int,
            16 as libc::c_int as libc::c_ulong,
        );
        1 as libc::c_int
    } else {
        (*parser).error = YAML_MEMORY_ERROR;
        0 as libc::c_int
    } == 0)
    {
        leading_break.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
        if !(if !(leading_break.start).is_null() {
            leading_break.pointer = leading_break.start;
            leading_break.end = (leading_break.start).offset(16 as libc::c_int as isize);
            memset(
                leading_break.start as *mut libc::c_void,
                0 as libc::c_int,
                16 as libc::c_int as libc::c_ulong,
            );
            1 as libc::c_int
        } else {
            (*parser).error = YAML_MEMORY_ERROR;
            0 as libc::c_int
        } == 0)
        {
            trailing_breaks.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
            if !(if !(trailing_breaks.start).is_null() {
                trailing_breaks.pointer = trailing_breaks.start;
                trailing_breaks.end = (trailing_breaks.start).offset(16 as libc::c_int as isize);
                memset(
                    trailing_breaks.start as *mut libc::c_void,
                    0 as libc::c_int,
                    16 as libc::c_int as libc::c_ulong,
                );
                1 as libc::c_int
            } else {
                (*parser).error = YAML_MEMORY_ERROR;
                0 as libc::c_int
            } == 0)
            {
                whitespaces.start = yaml_malloc(16 as libc::c_int as size_t) as *mut yaml_char_t;
                if !(if !(whitespaces.start).is_null() {
                    whitespaces.pointer = whitespaces.start;
                    whitespaces.end = (whitespaces.start).offset(16 as libc::c_int as isize);
                    memset(
                        whitespaces.start as *mut libc::c_void,
                        0 as libc::c_int,
                        16 as libc::c_int as libc::c_ulong,
                    );
                    1 as libc::c_int
                } else {
                    (*parser).error = YAML_MEMORY_ERROR;
                    0 as libc::c_int
                } == 0)
                {
                    end_mark = (*parser).mark;
                    start_mark = end_mark;
                    's_43: loop {
                        if if (*parser).unread >= 4 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 4 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 7426998641459994183;
                            break;
                        }
                        if (*parser).mark.column == 0 as libc::c_int as libc::c_ulong
                            && (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '-' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                    as libc::c_int
                                    == '-' as i32 as yaml_char_t as libc::c_int
                                && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                    as libc::c_int
                                    == '-' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '.' as i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '.' as i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer).offset(2 as libc::c_int as isize)
                                        as libc::c_int
                                        == '.' as i32 as yaml_char_t as libc::c_int)
                            && (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                as libc::c_int
                                == ' ' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\t' as i32 as yaml_char_t as libc::c_int
                                || (*((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\r' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\n' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -62i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -123i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -88i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == -30i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -128i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset((3 as libc::c_int + 2 as libc::c_int) as isize)
                                            as libc::c_int
                                            == -87i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(3 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\0' as i32 as yaml_char_t as libc::c_int))
                        {
                            current_block = 16415152177862271243;
                            break;
                        }
                        if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == '#' as i32 as yaml_char_t as libc::c_int
                        {
                            current_block = 16415152177862271243;
                            break;
                        }
                        while !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                            || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\r' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -62i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -123i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -87i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\0' as i32 as yaml_char_t as libc::c_int))
                        {
                            if (*parser).flow_level != 0
                                && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == ':' as i32 as yaml_char_t as libc::c_int
                                && (*((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                    as libc::c_int
                                    == ',' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '?' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '[' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == ']' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '{' as i32 as yaml_char_t as libc::c_int
                                    || *((*parser).buffer.pointer).offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == '}' as i32 as yaml_char_t as libc::c_int)
                            {
                                yaml_parser_set_scanner_error(
                                    parser,
                                    b"while scanning a plain scalar\0" as *const u8
                                        as *const libc::c_char,
                                    start_mark,
                                    b"found unexpected ':'\0" as *const u8 as *const libc::c_char,
                                );
                                current_block = 7426998641459994183;
                                break 's_43;
                            } else {
                                if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == ':' as i32 as yaml_char_t as libc::c_int
                                    && (*((*parser).buffer.pointer)
                                        .offset(1 as libc::c_int as isize)
                                        as libc::c_int
                                        == ' ' as i32 as yaml_char_t as libc::c_int
                                        || *((*parser).buffer.pointer)
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\t' as i32 as yaml_char_t as libc::c_int
                                        || (*((*parser).buffer.pointer)
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -62i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -123i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -88i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == -30i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 1 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -128i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer).offset(
                                                    (1 as libc::c_int + 2 as libc::c_int) as isize,
                                                )
                                                    as libc::c_int
                                                    == -87i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\0' as i32 as yaml_char_t as libc::c_int))
                                    || (*parser).flow_level != 0
                                        && (*((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == ',' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '[' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == ']' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '{' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '}' as i32 as yaml_char_t as libc::c_int)
                                {
                                    break;
                                }
                                if leading_blanks != 0 || whitespaces.start != whitespaces.pointer {
                                    if leading_blanks != 0 {
                                        if *(leading_break.start).offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\n' as i32
                                        {
                                            if *(trailing_breaks.start)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\0' as i32
                                            {
                                                if if (string.pointer)
                                                    .offset(5 as libc::c_int as isize)
                                                    < string.end
                                                    || yaml_string_extend(
                                                        &mut string.start,
                                                        &mut string.pointer,
                                                        &mut string.end,
                                                    ) != 0
                                                {
                                                    1 as libc::c_int
                                                } else {
                                                    (*parser).error = YAML_MEMORY_ERROR;
                                                    0 as libc::c_int
                                                } == 0
                                                {
                                                    current_block = 7426998641459994183;
                                                    break 's_43;
                                                }
                                                let fresh732 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh732 = ' ' as i32 as yaml_char_t;
                                            } else {
                                                if if yaml_string_join(
                                                    &mut string.start,
                                                    &mut string.pointer,
                                                    &mut string.end,
                                                    &mut trailing_breaks.start,
                                                    &mut trailing_breaks.pointer,
                                                    &mut trailing_breaks.end,
                                                ) != 0
                                                {
                                                    trailing_breaks.pointer = trailing_breaks.start;
                                                    1 as libc::c_int
                                                } else {
                                                    (*parser).error = YAML_MEMORY_ERROR;
                                                    0 as libc::c_int
                                                } == 0
                                                {
                                                    current_block = 7426998641459994183;
                                                    break 's_43;
                                                }
                                                trailing_breaks.pointer = trailing_breaks.start;
                                                memset(
                                                    trailing_breaks.start as *mut libc::c_void,
                                                    0 as libc::c_int,
                                                    (trailing_breaks.end)
                                                        .offset_from(trailing_breaks.start)
                                                        as libc::c_long
                                                        as libc::c_ulong,
                                                );
                                            }
                                            leading_break.pointer = leading_break.start;
                                            memset(
                                                leading_break.start as *mut libc::c_void,
                                                0 as libc::c_int,
                                                (leading_break.end).offset_from(leading_break.start)
                                                    as libc::c_long
                                                    as libc::c_ulong,
                                            );
                                        } else {
                                            if if yaml_string_join(
                                                &mut string.start,
                                                &mut string.pointer,
                                                &mut string.end,
                                                &mut leading_break.start,
                                                &mut leading_break.pointer,
                                                &mut leading_break.end,
                                            ) != 0
                                            {
                                                leading_break.pointer = leading_break.start;
                                                1 as libc::c_int
                                            } else {
                                                (*parser).error = YAML_MEMORY_ERROR;
                                                0 as libc::c_int
                                            } == 0
                                            {
                                                current_block = 7426998641459994183;
                                                break 's_43;
                                            }
                                            if if yaml_string_join(
                                                &mut string.start,
                                                &mut string.pointer,
                                                &mut string.end,
                                                &mut trailing_breaks.start,
                                                &mut trailing_breaks.pointer,
                                                &mut trailing_breaks.end,
                                            ) != 0
                                            {
                                                trailing_breaks.pointer = trailing_breaks.start;
                                                1 as libc::c_int
                                            } else {
                                                (*parser).error = YAML_MEMORY_ERROR;
                                                0 as libc::c_int
                                            } == 0
                                            {
                                                current_block = 7426998641459994183;
                                                break 's_43;
                                            }
                                            leading_break.pointer = leading_break.start;
                                            memset(
                                                leading_break.start as *mut libc::c_void,
                                                0 as libc::c_int,
                                                (leading_break.end).offset_from(leading_break.start)
                                                    as libc::c_long
                                                    as libc::c_ulong,
                                            );
                                            trailing_breaks.pointer = trailing_breaks.start;
                                            memset(
                                                trailing_breaks.start as *mut libc::c_void,
                                                0 as libc::c_int,
                                                (trailing_breaks.end)
                                                    .offset_from(trailing_breaks.start)
                                                    as libc::c_long
                                                    as libc::c_ulong,
                                            );
                                        }
                                        leading_blanks = 0 as libc::c_int;
                                    } else {
                                        if if yaml_string_join(
                                            &mut string.start,
                                            &mut string.pointer,
                                            &mut string.end,
                                            &mut whitespaces.start,
                                            &mut whitespaces.pointer,
                                            &mut whitespaces.end,
                                        ) != 0
                                        {
                                            whitespaces.pointer = whitespaces.start;
                                            1 as libc::c_int
                                        } else {
                                            (*parser).error = YAML_MEMORY_ERROR;
                                            0 as libc::c_int
                                        } == 0
                                        {
                                            current_block = 7426998641459994183;
                                            break 's_43;
                                        }
                                        whitespaces.pointer = whitespaces.start;
                                        memset(
                                            whitespaces.start as *mut libc::c_void,
                                            0 as libc::c_int,
                                            (whitespaces.end).offset_from(whitespaces.start)
                                                as libc::c_long
                                                as libc::c_ulong,
                                        );
                                    }
                                }
                                if if if (string.pointer).offset(5 as libc::c_int as isize)
                                    < string.end
                                    || yaml_string_extend(
                                        &mut string.start,
                                        &mut string.pointer,
                                        &mut string.end,
                                    ) != 0
                                {
                                    1 as libc::c_int
                                } else {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    0 as libc::c_int
                                } != 0
                                {
                                    if *(*parser).buffer.pointer as libc::c_int
                                        & 0x80 as libc::c_int
                                        == 0 as libc::c_int
                                    {
                                        let fresh733 = (*parser).buffer.pointer;
                                        (*parser).buffer.pointer =
                                            ((*parser).buffer.pointer).offset(1);
                                        let fresh734 = string.pointer;
                                        string.pointer = (string.pointer).offset(1);
                                        *fresh734 = *fresh733;
                                    } else {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0xe0 as libc::c_int
                                            == 0xc0 as libc::c_int
                                        {
                                            let fresh735 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh736 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh736 = *fresh735;
                                            let fresh737 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh738 = string.pointer;
                                            string.pointer = (string.pointer).offset(1);
                                            *fresh738 = *fresh737;
                                        } else {
                                            if *(*parser).buffer.pointer as libc::c_int
                                                & 0xf0 as libc::c_int
                                                == 0xe0 as libc::c_int
                                            {
                                                let fresh739 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh740 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh740 = *fresh739;
                                                let fresh741 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh742 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh742 = *fresh741;
                                                let fresh743 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh744 = string.pointer;
                                                string.pointer = (string.pointer).offset(1);
                                                *fresh744 = *fresh743;
                                            } else {
                                                if *(*parser).buffer.pointer as libc::c_int
                                                    & 0xf8 as libc::c_int
                                                    == 0xf0 as libc::c_int
                                                {
                                                    let fresh745 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh746 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh746 = *fresh745;
                                                    let fresh747 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh748 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh748 = *fresh747;
                                                    let fresh749 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh750 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh750 = *fresh749;
                                                    let fresh751 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh752 = string.pointer;
                                                    string.pointer = (string.pointer).offset(1);
                                                    *fresh752 = *fresh751;
                                                } else {
                                                };
                                            };
                                        };
                                    };
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    1 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                } == 0
                                {
                                    current_block = 7426998641459994183;
                                    break 's_43;
                                }
                                end_mark = (*parser).mark;
                                if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
                                    1 as libc::c_int
                                } else {
                                    yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
                                } == 0
                                {
                                    current_block = 7426998641459994183;
                                    break 's_43;
                                }
                            }
                        }
                        if !(*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                            || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\r' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -62i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -123i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -87i32 as yaml_char_t as libc::c_int))
                        {
                            current_block = 16415152177862271243;
                            break;
                        }
                        if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                            1 as libc::c_int
                        } else {
                            yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                        } == 0
                        {
                            current_block = 7426998641459994183;
                            break;
                        }
                        while *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                            as libc::c_int
                            == ' ' as i32 as yaml_char_t as libc::c_int
                            || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\t' as i32 as yaml_char_t as libc::c_int
                            || (*((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == '\r' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -62i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -123i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -88i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == -30i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 1 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -128i32 as yaml_char_t as libc::c_int
                                    && *((*parser).buffer.pointer)
                                        .offset((0 as libc::c_int + 2 as libc::c_int) as isize)
                                        as libc::c_int
                                        == -87i32 as yaml_char_t as libc::c_int)
                        {
                            if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                as libc::c_int
                                == ' ' as i32 as yaml_char_t as libc::c_int
                                || *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                    as libc::c_int
                                    == '\t' as i32 as yaml_char_t as libc::c_int
                            {
                                if leading_blanks != 0
                                    && ((*parser).mark.column as libc::c_int) < indent
                                    && *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\t' as i32 as yaml_char_t as libc::c_int
                                {
                                    yaml_parser_set_scanner_error(
                                        parser,
                                        b"while scanning a plain scalar\0" as *const u8
                                            as *const libc::c_char,
                                        start_mark,
                                        b"found a tab character that violates indentation\0"
                                            as *const u8
                                            as *const libc::c_char,
                                    );
                                    current_block = 7426998641459994183;
                                    break 's_43;
                                } else if leading_blanks == 0 {
                                    if if if (whitespaces.pointer).offset(5 as libc::c_int as isize)
                                        < whitespaces.end
                                        || yaml_string_extend(
                                            &mut whitespaces.start,
                                            &mut whitespaces.pointer,
                                            &mut whitespaces.end,
                                        ) != 0
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } != 0
                                    {
                                        if *(*parser).buffer.pointer as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            let fresh753 = (*parser).buffer.pointer;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            let fresh754 = whitespaces.pointer;
                                            whitespaces.pointer = (whitespaces.pointer).offset(1);
                                            *fresh754 = *fresh753;
                                        } else {
                                            if *(*parser).buffer.pointer as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                let fresh755 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh756 = whitespaces.pointer;
                                                whitespaces.pointer =
                                                    (whitespaces.pointer).offset(1);
                                                *fresh756 = *fresh755;
                                                let fresh757 = (*parser).buffer.pointer;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                let fresh758 = whitespaces.pointer;
                                                whitespaces.pointer =
                                                    (whitespaces.pointer).offset(1);
                                                *fresh758 = *fresh757;
                                            } else {
                                                if *(*parser).buffer.pointer as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    let fresh759 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh760 = whitespaces.pointer;
                                                    whitespaces.pointer =
                                                        (whitespaces.pointer).offset(1);
                                                    *fresh760 = *fresh759;
                                                    let fresh761 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh762 = whitespaces.pointer;
                                                    whitespaces.pointer =
                                                        (whitespaces.pointer).offset(1);
                                                    *fresh762 = *fresh761;
                                                    let fresh763 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh764 = whitespaces.pointer;
                                                    whitespaces.pointer =
                                                        (whitespaces.pointer).offset(1);
                                                    *fresh764 = *fresh763;
                                                } else {
                                                    if *(*parser).buffer.pointer as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        let fresh765 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh766 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh766 = *fresh765;
                                                        let fresh767 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh768 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh768 = *fresh767;
                                                        let fresh769 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh770 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh770 = *fresh769;
                                                        let fresh771 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh772 = whitespaces.pointer;
                                                        whitespaces.pointer =
                                                            (whitespaces.pointer).offset(1);
                                                        *fresh772 = *fresh771;
                                                    } else {
                                                    };
                                                };
                                            };
                                        };
                                        (*parser).mark.index =
                                            ((*parser).mark.index).wrapping_add(1);
                                        (*parser).mark.index;
                                        (*parser).mark.column =
                                            ((*parser).mark.column).wrapping_add(1);
                                        (*parser).mark.column;
                                        (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                        (*parser).unread;
                                        1 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 7426998641459994183;
                                        break 's_43;
                                    }
                                } else {
                                    (*parser).mark.index = ((*parser).mark.index).wrapping_add(1);
                                    (*parser).mark.index;
                                    (*parser).mark.column = ((*parser).mark.column).wrapping_add(1);
                                    (*parser).mark.column;
                                    (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                    (*parser).unread;
                                    (*parser).buffer.pointer = ((*parser).buffer.pointer).offset(
                                        (if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            & 0x80 as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            1 as libc::c_int
                                        } else {
                                            (if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                & 0xe0 as libc::c_int
                                                == 0xc0 as libc::c_int
                                            {
                                                2 as libc::c_int
                                            } else {
                                                (if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    & 0xf0 as libc::c_int
                                                    == 0xe0 as libc::c_int
                                                {
                                                    3 as libc::c_int
                                                } else {
                                                    (if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        & 0xf8 as libc::c_int
                                                        == 0xf0 as libc::c_int
                                                    {
                                                        4 as libc::c_int
                                                    } else {
                                                        0 as libc::c_int
                                                    })
                                                })
                                            })
                                        }) as isize,
                                    );
                                }
                            } else {
                                if if (*parser).unread >= 2 as libc::c_int as libc::c_ulong {
                                    1 as libc::c_int
                                } else {
                                    yaml_parser_update_buffer(parser, 2 as libc::c_int as size_t)
                                } == 0
                                {
                                    current_block = 7426998641459994183;
                                    break 's_43;
                                }
                                if leading_blanks == 0 {
                                    whitespaces.pointer = whitespaces.start;
                                    memset(
                                        whitespaces.start as *mut libc::c_void,
                                        0 as libc::c_int,
                                        (whitespaces.end).offset_from(whitespaces.start)
                                            as libc::c_long
                                            as libc::c_ulong,
                                    );
                                    if if if (leading_break.pointer)
                                        .offset(5 as libc::c_int as isize)
                                        < leading_break.end
                                        || yaml_string_extend(
                                            &mut leading_break.start,
                                            &mut leading_break.pointer,
                                            &mut leading_break.end,
                                        ) != 0
                                    {
                                        1 as libc::c_int
                                    } else {
                                        (*parser).error = YAML_MEMORY_ERROR;
                                        0 as libc::c_int
                                    } != 0
                                    {
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            && *((*parser).buffer.pointer)
                                                .offset(1 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                        {
                                            let fresh773 = leading_break.pointer;
                                            leading_break.pointer =
                                                (leading_break.pointer).offset(1);
                                            *fresh773 = '\n' as i32 as yaml_char_t;
                                            (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                                .offset(2 as libc::c_int as isize);
                                            (*parser).mark.index = ((*parser).mark.index
                                                as libc::c_ulong)
                                                .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                            (*parser).mark.column = 0 as libc::c_int as size_t;
                                            (*parser).mark.line =
                                                ((*parser).mark.line).wrapping_add(1);
                                            (*parser).mark.line;
                                            (*parser).unread = ((*parser).unread as libc::c_ulong)
                                                .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                                as size_t
                                                as size_t;
                                        } else {
                                            if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\r' as i32 as yaml_char_t as libc::c_int
                                                || *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == '\n' as i32 as yaml_char_t as libc::c_int
                                            {
                                                let fresh774 = leading_break.pointer;
                                                leading_break.pointer =
                                                    (leading_break.pointer).offset(1);
                                                *fresh774 = '\n' as i32 as yaml_char_t;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer).offset(1);
                                                (*parser).buffer.pointer;
                                                (*parser).mark.index =
                                                    ((*parser).mark.index).wrapping_add(1);
                                                (*parser).mark.index;
                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                (*parser).mark.line =
                                                    ((*parser).mark.line).wrapping_add(1);
                                                (*parser).mark.line;
                                                (*parser).unread =
                                                    ((*parser).unread).wrapping_sub(1);
                                                (*parser).unread;
                                            } else {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -62i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer)
                                                        .offset(1 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -123i32 as yaml_char_t as libc::c_int
                                                {
                                                    let fresh775 = leading_break.pointer;
                                                    leading_break.pointer =
                                                        (leading_break.pointer).offset(1);
                                                    *fresh775 = '\n' as i32 as yaml_char_t;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize);
                                                    (*parser).mark.index =
                                                        ((*parser).mark.index).wrapping_add(1);
                                                    (*parser).mark.index;
                                                    (*parser).mark.column =
                                                        0 as libc::c_int as size_t;
                                                    (*parser).mark.line =
                                                        ((*parser).mark.line).wrapping_add(1);
                                                    (*parser).mark.line;
                                                    (*parser).unread =
                                                        ((*parser).unread).wrapping_sub(1);
                                                    (*parser).unread;
                                                } else {
                                                    if *((*parser).buffer.pointer)
                                                        .offset(0 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -30i32 as yaml_char_t as libc::c_int
                                                        && *((*parser).buffer.pointer)
                                                            .offset(1 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -128i32 as yaml_char_t as libc::c_int
                                                        && (*((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -88i32 as yaml_char_t as libc::c_int
                                                            || *((*parser).buffer.pointer)
                                                                .offset(2 as libc::c_int as isize)
                                                                as libc::c_int
                                                                == -87i32 as yaml_char_t
                                                                    as libc::c_int)
                                                    {
                                                        let fresh776 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh777 = leading_break.pointer;
                                                        leading_break.pointer =
                                                            (leading_break.pointer).offset(1);
                                                        *fresh777 = *fresh776;
                                                        let fresh778 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh779 = leading_break.pointer;
                                                        leading_break.pointer =
                                                            (leading_break.pointer).offset(1);
                                                        *fresh779 = *fresh778;
                                                        let fresh780 = (*parser).buffer.pointer;
                                                        (*parser).buffer.pointer =
                                                            ((*parser).buffer.pointer).offset(1);
                                                        let fresh781 = leading_break.pointer;
                                                        leading_break.pointer =
                                                            (leading_break.pointer).offset(1);
                                                        *fresh781 = *fresh780;
                                                        (*parser).mark.index =
                                                            ((*parser).mark.index).wrapping_add(1);
                                                        (*parser).mark.index;
                                                        (*parser).mark.column =
                                                            0 as libc::c_int as size_t;
                                                        (*parser).mark.line =
                                                            ((*parser).mark.line).wrapping_add(1);
                                                        (*parser).mark.line;
                                                        (*parser).unread =
                                                            ((*parser).unread).wrapping_sub(1);
                                                        (*parser).unread;
                                                    } else {
                                                    };
                                                };
                                            };
                                        };
                                        1 as libc::c_int
                                    } else {
                                        0 as libc::c_int
                                    } == 0
                                    {
                                        current_block = 7426998641459994183;
                                        break 's_43;
                                    }
                                    leading_blanks = 1 as libc::c_int;
                                } else if if if (trailing_breaks.pointer)
                                    .offset(5 as libc::c_int as isize)
                                    < trailing_breaks.end
                                    || yaml_string_extend(
                                        &mut trailing_breaks.start,
                                        &mut trailing_breaks.pointer,
                                        &mut trailing_breaks.end,
                                    ) != 0
                                {
                                    1 as libc::c_int
                                } else {
                                    (*parser).error = YAML_MEMORY_ERROR;
                                    0 as libc::c_int
                                } != 0
                                {
                                    if *((*parser).buffer.pointer).offset(0 as libc::c_int as isize)
                                        as libc::c_int
                                        == '\r' as i32 as yaml_char_t as libc::c_int
                                        && *((*parser).buffer.pointer)
                                            .offset(1 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\n' as i32 as yaml_char_t as libc::c_int
                                    {
                                        let fresh782 = trailing_breaks.pointer;
                                        trailing_breaks.pointer =
                                            (trailing_breaks.pointer).offset(1);
                                        *fresh782 = '\n' as i32 as yaml_char_t;
                                        (*parser).buffer.pointer = ((*parser).buffer.pointer)
                                            .offset(2 as libc::c_int as isize);
                                        (*parser).mark.index = ((*parser).mark.index
                                            as libc::c_ulong)
                                            .wrapping_add(2 as libc::c_int as libc::c_ulong)
                                            as size_t
                                            as size_t;
                                        (*parser).mark.column = 0 as libc::c_int as size_t;
                                        (*parser).mark.line = ((*parser).mark.line).wrapping_add(1);
                                        (*parser).mark.line;
                                        (*parser).unread = ((*parser).unread as libc::c_ulong)
                                            .wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                            as size_t
                                            as size_t;
                                    } else {
                                        if *((*parser).buffer.pointer)
                                            .offset(0 as libc::c_int as isize)
                                            as libc::c_int
                                            == '\r' as i32 as yaml_char_t as libc::c_int
                                            || *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == '\n' as i32 as yaml_char_t as libc::c_int
                                        {
                                            let fresh783 = trailing_breaks.pointer;
                                            trailing_breaks.pointer =
                                                (trailing_breaks.pointer).offset(1);
                                            *fresh783 = '\n' as i32 as yaml_char_t;
                                            (*parser).buffer.pointer =
                                                ((*parser).buffer.pointer).offset(1);
                                            (*parser).buffer.pointer;
                                            (*parser).mark.index =
                                                ((*parser).mark.index).wrapping_add(1);
                                            (*parser).mark.index;
                                            (*parser).mark.column = 0 as libc::c_int as size_t;
                                            (*parser).mark.line =
                                                ((*parser).mark.line).wrapping_add(1);
                                            (*parser).mark.line;
                                            (*parser).unread = ((*parser).unread).wrapping_sub(1);
                                            (*parser).unread;
                                        } else {
                                            if *((*parser).buffer.pointer)
                                                .offset(0 as libc::c_int as isize)
                                                as libc::c_int
                                                == -62i32 as yaml_char_t as libc::c_int
                                                && *((*parser).buffer.pointer)
                                                    .offset(1 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -123i32 as yaml_char_t as libc::c_int
                                            {
                                                let fresh784 = trailing_breaks.pointer;
                                                trailing_breaks.pointer =
                                                    (trailing_breaks.pointer).offset(1);
                                                *fresh784 = '\n' as i32 as yaml_char_t;
                                                (*parser).buffer.pointer =
                                                    ((*parser).buffer.pointer)
                                                        .offset(2 as libc::c_int as isize);
                                                (*parser).mark.index =
                                                    ((*parser).mark.index).wrapping_add(1);
                                                (*parser).mark.index;
                                                (*parser).mark.column = 0 as libc::c_int as size_t;
                                                (*parser).mark.line =
                                                    ((*parser).mark.line).wrapping_add(1);
                                                (*parser).mark.line;
                                                (*parser).unread =
                                                    ((*parser).unread).wrapping_sub(1);
                                                (*parser).unread;
                                            } else {
                                                if *((*parser).buffer.pointer)
                                                    .offset(0 as libc::c_int as isize)
                                                    as libc::c_int
                                                    == -30i32 as yaml_char_t as libc::c_int
                                                    && *((*parser).buffer.pointer)
                                                        .offset(1 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -128i32 as yaml_char_t as libc::c_int
                                                    && (*((*parser).buffer.pointer)
                                                        .offset(2 as libc::c_int as isize)
                                                        as libc::c_int
                                                        == -88i32 as yaml_char_t as libc::c_int
                                                        || *((*parser).buffer.pointer)
                                                            .offset(2 as libc::c_int as isize)
                                                            as libc::c_int
                                                            == -87i32 as yaml_char_t as libc::c_int)
                                                {
                                                    let fresh785 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh786 = trailing_breaks.pointer;
                                                    trailing_breaks.pointer =
                                                        (trailing_breaks.pointer).offset(1);
                                                    *fresh786 = *fresh785;
                                                    let fresh787 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh788 = trailing_breaks.pointer;
                                                    trailing_breaks.pointer =
                                                        (trailing_breaks.pointer).offset(1);
                                                    *fresh788 = *fresh787;
                                                    let fresh789 = (*parser).buffer.pointer;
                                                    (*parser).buffer.pointer =
                                                        ((*parser).buffer.pointer).offset(1);
                                                    let fresh790 = trailing_breaks.pointer;
                                                    trailing_breaks.pointer =
                                                        (trailing_breaks.pointer).offset(1);
                                                    *fresh790 = *fresh789;
                                                    (*parser).mark.index =
                                                        ((*parser).mark.index).wrapping_add(1);
                                                    (*parser).mark.index;
                                                    (*parser).mark.column =
                                                        0 as libc::c_int as size_t;
                                                    (*parser).mark.line =
                                                        ((*parser).mark.line).wrapping_add(1);
                                                    (*parser).mark.line;
                                                    (*parser).unread =
                                                        ((*parser).unread).wrapping_sub(1);
                                                    (*parser).unread;
                                                } else {
                                                };
                                            };
                                        };
                                    };
                                    1 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                } == 0
                                {
                                    current_block = 7426998641459994183;
                                    break 's_43;
                                }
                            }
                            if if (*parser).unread >= 1 as libc::c_int as libc::c_ulong {
                                1 as libc::c_int
                            } else {
                                yaml_parser_update_buffer(parser, 1 as libc::c_int as size_t)
                            } == 0
                            {
                                current_block = 7426998641459994183;
                                break 's_43;
                            }
                        }
                        if (*parser).flow_level == 0
                            && ((*parser).mark.column as libc::c_int) < indent
                        {
                            current_block = 16415152177862271243;
                            break;
                        }
                    }
                    match current_block {
                        7426998641459994183 => {}
                        _ => {
                            memset(
                                token as *mut libc::c_void,
                                0 as libc::c_int,
                                ::core::mem::size_of::<yaml_token_t>() as libc::c_ulong,
                            );
                            (*token).type_0 = YAML_SCALAR_TOKEN;
                            (*token).start_mark = start_mark;
                            (*token).end_mark = end_mark;
                            (*token).data.scalar.value = string.start;
                            (*token).data.scalar.length = (string.pointer).offset_from(string.start)
                                as libc::c_long
                                as size_t;
                            (*token).data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
                            if leading_blanks != 0 {
                                (*parser).simple_key_allowed = 1 as libc::c_int;
                            }
                            yaml_free(leading_break.start as *mut libc::c_void);
                            leading_break.end = 0 as *mut yaml_char_t;
                            leading_break.pointer = leading_break.end;
                            leading_break.start = leading_break.pointer;
                            yaml_free(trailing_breaks.start as *mut libc::c_void);
                            trailing_breaks.end = 0 as *mut yaml_char_t;
                            trailing_breaks.pointer = trailing_breaks.end;
                            trailing_breaks.start = trailing_breaks.pointer;
                            yaml_free(whitespaces.start as *mut libc::c_void);
                            whitespaces.end = 0 as *mut yaml_char_t;
                            whitespaces.pointer = whitespaces.end;
                            whitespaces.start = whitespaces.pointer;
                            return 1 as libc::c_int;
                        }
                    }
                }
            }
        }
    }
    yaml_free(string.start as *mut libc::c_void);
    string.end = 0 as *mut yaml_char_t;
    string.pointer = string.end;
    string.start = string.pointer;
    yaml_free(leading_break.start as *mut libc::c_void);
    leading_break.end = 0 as *mut yaml_char_t;
    leading_break.pointer = leading_break.end;
    leading_break.start = leading_break.pointer;
    yaml_free(trailing_breaks.start as *mut libc::c_void);
    trailing_breaks.end = 0 as *mut yaml_char_t;
    trailing_breaks.pointer = trailing_breaks.end;
    trailing_breaks.start = trailing_breaks.pointer;
    yaml_free(whitespaces.start as *mut libc::c_void);
    whitespaces.end = 0 as *mut yaml_char_t;
    whitespaces.pointer = whitespaces.end;
    whitespaces.start = whitespaces.pointer;
    return 0 as libc::c_int;
}
unsafe extern "C" fn yaml_emitter_set_writer_error(
    mut emitter: *mut yaml_emitter_t,
    mut problem: *const libc::c_char,
) -> libc::c_int {
    (*emitter).error = YAML_WRITER_ERROR;
    (*emitter).problem = problem;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn yaml_emitter_flush(mut emitter: *mut yaml_emitter_t) -> libc::c_int {
    let mut low: libc::c_int = 0;
    let mut high: libc::c_int = 0;
    if !emitter.is_null() {
    } else {
        __assert_fail(
            b"emitter\0" as *const u8 as *const libc::c_char,
            b"./writer.c\0" as *const u8 as *const libc::c_char,
            36 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"int yaml_emitter_flush(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_66090: {
        if !emitter.is_null() {
        } else {
            __assert_fail(
                b"emitter\0" as *const u8 as *const libc::c_char,
                b"./writer.c\0" as *const u8 as *const libc::c_char,
                36 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"int yaml_emitter_flush(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if ((*emitter).write_handler).is_some() {
    } else {
        __assert_fail(
            b"emitter->write_handler\0" as *const u8 as *const libc::c_char,
            b"./writer.c\0" as *const u8 as *const libc::c_char,
            37 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"int yaml_emitter_flush(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_66053: {
        if ((*emitter).write_handler).is_some() {
        } else {
            __assert_fail(
                b"emitter->write_handler\0" as *const u8 as *const libc::c_char,
                b"./writer.c\0" as *const u8 as *const libc::c_char,
                37 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"int yaml_emitter_flush(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    if (*emitter).encoding as u64 != 0 {
    } else {
        __assert_fail(
            b"emitter->encoding\0" as *const u8 as *const libc::c_char,
            b"./writer.c\0" as *const u8 as *const libc::c_char,
            38 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                b"int yaml_emitter_flush(yaml_emitter_t *)\0",
            ))
            .as_ptr(),
        );
    }
    'c_66016: {
        if (*emitter).encoding as u64 != 0 {
        } else {
            __assert_fail(
                b"emitter->encoding\0" as *const u8 as *const libc::c_char,
                b"./writer.c\0" as *const u8 as *const libc::c_char,
                38 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<&[u8; 41], &[libc::c_char; 41]>(
                    b"int yaml_emitter_flush(yaml_emitter_t *)\0",
                ))
                .as_ptr(),
            );
        }
    };
    (*emitter).buffer.last = (*emitter).buffer.pointer;
    (*emitter).buffer.pointer = (*emitter).buffer.start;
    if (*emitter).buffer.start == (*emitter).buffer.last {
        return 1 as libc::c_int;
    }
    if (*emitter).encoding as libc::c_uint == YAML_UTF8_ENCODING as libc::c_int as libc::c_uint {
        if ((*emitter).write_handler).expect("non-null function pointer")(
            (*emitter).write_handler_data,
            (*emitter).buffer.start,
            ((*emitter).buffer.last).offset_from((*emitter).buffer.start) as libc::c_long as size_t,
        ) != 0
        {
            (*emitter).buffer.last = (*emitter).buffer.start;
            (*emitter).buffer.pointer = (*emitter).buffer.start;
            return 1 as libc::c_int;
        } else {
            return yaml_emitter_set_writer_error(
                emitter,
                b"write error\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    low = if (*emitter).encoding as libc::c_uint
        == YAML_UTF16LE_ENCODING as libc::c_int as libc::c_uint
    {
        0 as libc::c_int
    } else {
        1 as libc::c_int
    };
    high = if (*emitter).encoding as libc::c_uint
        == YAML_UTF16LE_ENCODING as libc::c_int as libc::c_uint
    {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    while (*emitter).buffer.pointer != (*emitter).buffer.last {
        let mut octet: libc::c_uchar = 0;
        let mut width: libc::c_uint = 0;
        let mut value: libc::c_uint = 0;
        let mut k: size_t = 0;
        octet = *((*emitter).buffer.pointer).offset(0 as libc::c_int as isize);
        width = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
            1 as libc::c_int
        } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
            2 as libc::c_int
        } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
            3 as libc::c_int
        } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
            4 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        value = (if octet as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
            octet as libc::c_int & 0x7f as libc::c_int
        } else if octet as libc::c_int & 0xe0 as libc::c_int == 0xc0 as libc::c_int {
            octet as libc::c_int & 0x1f as libc::c_int
        } else if octet as libc::c_int & 0xf0 as libc::c_int == 0xe0 as libc::c_int {
            octet as libc::c_int & 0xf as libc::c_int
        } else if octet as libc::c_int & 0xf8 as libc::c_int == 0xf0 as libc::c_int {
            octet as libc::c_int & 0x7 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        k = 1 as libc::c_int as size_t;
        while k < width as libc::c_ulong {
            octet = *((*emitter).buffer.pointer).offset(k as isize);
            value = (value << 6 as libc::c_int)
                .wrapping_add((octet as libc::c_int & 0x3f as libc::c_int) as libc::c_uint);
            k = k.wrapping_add(1);
            k;
        }
        (*emitter).buffer.pointer = ((*emitter).buffer.pointer).offset(width as isize);
        if value < 0x10000 as libc::c_int as libc::c_uint {
            *((*emitter).raw_buffer.last).offset(high as isize) =
                (value >> 8 as libc::c_int) as libc::c_uchar;
            *((*emitter).raw_buffer.last).offset(low as isize) =
                (value & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
            (*emitter).raw_buffer.last =
                ((*emitter).raw_buffer.last).offset(2 as libc::c_int as isize);
        } else {
            value = value.wrapping_sub(0x10000 as libc::c_int as libc::c_uint);
            *((*emitter).raw_buffer.last).offset(high as isize) =
                (0xd8 as libc::c_int as libc::c_uint).wrapping_add(value >> 18 as libc::c_int)
                    as libc::c_uchar;
            *((*emitter).raw_buffer.last).offset(low as isize) =
                (value >> 10 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
            *((*emitter).raw_buffer.last).offset((high + 2 as libc::c_int) as isize) =
                (0xdc as libc::c_int as libc::c_uint)
                    .wrapping_add(value >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint)
                    as libc::c_uchar;
            *((*emitter).raw_buffer.last).offset((low + 2 as libc::c_int) as isize) =
                (value & 0xff as libc::c_int as libc::c_uint) as libc::c_uchar;
            (*emitter).raw_buffer.last =
                ((*emitter).raw_buffer.last).offset(4 as libc::c_int as isize);
        }
    }
    if ((*emitter).write_handler).expect("non-null function pointer")(
        (*emitter).write_handler_data,
        (*emitter).raw_buffer.start,
        ((*emitter).raw_buffer.last).offset_from((*emitter).raw_buffer.start) as libc::c_long
            as size_t,
    ) != 0
    {
        (*emitter).buffer.last = (*emitter).buffer.start;
        (*emitter).buffer.pointer = (*emitter).buffer.start;
        (*emitter).raw_buffer.last = (*emitter).raw_buffer.start;
        (*emitter).raw_buffer.pointer = (*emitter).raw_buffer.start;
        return 1 as libc::c_int;
    } else {
        return yaml_emitter_set_writer_error(
            emitter,
            b"write error\0" as *const u8 as *const libc::c_char,
        );
    };
}
